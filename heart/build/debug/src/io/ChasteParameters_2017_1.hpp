// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef HEART_SRC_IO_CHASTE_PARAMETERS_2017_1_HPP
#define HEART_SRC_IO_CHASTE_PARAMETERS_2017_1_HPP

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
// LCOV_EXCL_START
/** @autogenerated */
#include <streambuf>
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      class time_type;
      class dimensionless_type;
      class conductivity_type;
      class stimulus_strength_type;
      class surface_stimulus_strength_type;
      class inverse_length_type;
      class capacitance_type;
      class apply_drug_type;
      class ic50_type;
      class location_type;
      class domain_type;
      class axis_type;
      class ionic_models_available_type;
      class ionic_model_selection_type;
      class dynamically_loaded_ionic_model_type;
      class path_type;
      class relative_to_type;
      class ionic_model_region_type;
      class ionic_models_type;
      class apd_map_type;
      class upstrokes_map_type;
      class max_upstrokes_velocity_map_type;
      class conduction_velocity_map_type;
      class node_number_type;
      class media_type;
      class point_type;
      class box_type;
      class ellipsoid_type;
      class stimulus_type;
      class set_parameter_type;
      class electrodes_type;
      class cell_heterogeneity_type;
      class conductivity_heterogeneity_type;
      class slab_type;
      class sheet_type;
      class fibre_type;
      class load_mesh_type;
      class mesh_type;
      class conductivities_type;
      class var_type;
      class output_variables_type;
      class yesno_type;
      class output_visualizer_type;
      class time_steps_type;
      class ksp_tolerances_type;
      class ksp_solver_type;
      class ksp_preconditioner_type;
      class mesh_partitioning_type;
      class checkpoint_type;
      class adaptivity_parameters_type;
      class cell_heterogeneities_type;
      class stimuli_type;
      class simulation_type;
      class resume_simulation_type;
      class physiological_type;
      class numerical_type;
      class postprocessing_type;
      class chaste_parameters_type;
      class purkinje_physiological_type;
      class purkinje_simulation_type;
      class ConductivityHeterogeneities;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      class time_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
      {
        public:
        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        time_type (const ::xml_schema::decimal&);

        time_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        time_type (const time_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual time_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        time_type&
        operator= (const time_type& x);

        virtual 
        ~time_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class dimensionless_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
      {
        public:
        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        dimensionless_type (const ::xml_schema::decimal&);

        dimensionless_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        dimensionless_type (const dimensionless_type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        virtual dimensionless_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        dimensionless_type&
        operator= (const dimensionless_type& x);

        virtual 
        ~dimensionless_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class conductivity_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
      {
        public:
        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        conductivity_type (const ::xml_schema::decimal&);

        conductivity_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        conductivity_type (const conductivity_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        virtual conductivity_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        conductivity_type&
        operator= (const conductivity_type& x);

        virtual 
        ~conductivity_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class stimulus_strength_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
      {
        public:
        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        stimulus_strength_type (const ::xml_schema::decimal&);

        stimulus_strength_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        stimulus_strength_type (const stimulus_strength_type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        virtual stimulus_strength_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        stimulus_strength_type&
        operator= (const stimulus_strength_type& x);

        virtual 
        ~stimulus_strength_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class surface_stimulus_strength_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
      {
        public:
        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        surface_stimulus_strength_type (const ::xml_schema::decimal&);

        surface_stimulus_strength_type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        surface_stimulus_strength_type (const surface_stimulus_strength_type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        virtual surface_stimulus_strength_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        surface_stimulus_strength_type&
        operator= (const surface_stimulus_strength_type& x);

        virtual 
        ~surface_stimulus_strength_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class inverse_length_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
      {
        public:
        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        inverse_length_type (const ::xml_schema::decimal&);

        inverse_length_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        inverse_length_type (const inverse_length_type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        virtual inverse_length_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        inverse_length_type&
        operator= (const inverse_length_type& x);

        virtual 
        ~inverse_length_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class capacitance_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
      {
        public:
        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        capacitance_type (const ::xml_schema::decimal&);

        capacitance_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        capacitance_type (const capacitance_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        virtual capacitance_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        capacitance_type&
        operator= (const capacitance_type& x);

        virtual 
        ~capacitance_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class apply_drug_type: public ::xml_schema::type
      {
        public:
        // IC50
        //
        typedef ::chaste::parameters::v2017_1::ic50_type IC50_type;
        typedef ::xsd::cxx::tree::sequence< IC50_type > IC50_sequence;
        typedef IC50_sequence::iterator IC50_iterator;
        typedef IC50_sequence::const_iterator IC50_const_iterator;
        typedef ::xsd::cxx::tree::traits< IC50_type, char > IC50_traits;

        const IC50_sequence&
        IC50 () const;

        IC50_sequence&
        IC50 ();

        void
        IC50 (const IC50_sequence& s);

        // concentration
        //
        typedef ::xml_schema::double_ concentration_type;
        typedef ::xsd::cxx::tree::traits< concentration_type, char, ::xsd::cxx::tree::schema_type::double_ > concentration_traits;

        const concentration_type&
        concentration () const;

        concentration_type&
        concentration ();

        void
        concentration (const concentration_type& x);

        // Constructors.
        //
        apply_drug_type (const concentration_type&);

        apply_drug_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        apply_drug_type (const apply_drug_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual apply_drug_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        apply_drug_type&
        operator= (const apply_drug_type& x);

        virtual 
        ~apply_drug_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        IC50_sequence IC50_;
        ::xsd::cxx::tree::one< concentration_type > concentration_;
      };

      class ic50_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
      {
        public:
        // current
        //
        typedef ::xml_schema::string current_type;
        typedef ::xsd::cxx::tree::traits< current_type, char > current_traits;

        const current_type&
        current () const;

        current_type&
        current ();

        void
        current (const current_type& x);

        void
        current (::std::unique_ptr< current_type > p);

        // hill
        //
        typedef ::xml_schema::double_ hill_type;
        typedef ::xsd::cxx::tree::traits< hill_type, char, ::xsd::cxx::tree::schema_type::double_ > hill_traits;

        const hill_type&
        hill () const;

        hill_type&
        hill ();

        void
        hill (const hill_type& x);

        static hill_type
        hill_default_value ();

        // Constructors.
        //
        ic50_type (const ::xml_schema::double_&,
                   const current_type&);

        ic50_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        ic50_type (const ic50_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual ic50_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ic50_type&
        operator= (const ic50_type& x);

        virtual 
        ~ic50_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< current_type > current_;
        ::xsd::cxx::tree::one< hill_type > hill_;
      };

      class location_type: public ::xml_schema::type
      {
        public:
        // Cuboid
        //
        typedef ::chaste::parameters::v2017_1::box_type Cuboid_type;
        typedef ::xsd::cxx::tree::optional< Cuboid_type > Cuboid_optional;
        typedef ::xsd::cxx::tree::traits< Cuboid_type, char > Cuboid_traits;

        const Cuboid_optional&
        Cuboid () const;

        Cuboid_optional&
        Cuboid ();

        void
        Cuboid (const Cuboid_type& x);

        void
        Cuboid (const Cuboid_optional& x);

        void
        Cuboid (::std::unique_ptr< Cuboid_type > p);

        // Ellipsoid
        //
        typedef ::chaste::parameters::v2017_1::ellipsoid_type Ellipsoid_type;
        typedef ::xsd::cxx::tree::optional< Ellipsoid_type > Ellipsoid_optional;
        typedef ::xsd::cxx::tree::traits< Ellipsoid_type, char > Ellipsoid_traits;

        const Ellipsoid_optional&
        Ellipsoid () const;

        Ellipsoid_optional&
        Ellipsoid ();

        void
        Ellipsoid (const Ellipsoid_type& x);

        void
        Ellipsoid (const Ellipsoid_optional& x);

        void
        Ellipsoid (::std::unique_ptr< Ellipsoid_type > p);

        // NotUsed
        //
        typedef ::xml_schema::boolean NotUsed_type;
        typedef ::xsd::cxx::tree::optional< NotUsed_type > NotUsed_optional;
        typedef ::xsd::cxx::tree::traits< NotUsed_type, char > NotUsed_traits;

        const NotUsed_optional&
        NotUsed () const;

        NotUsed_optional&
        NotUsed ();

        void
        NotUsed (const NotUsed_type& x);

        void
        NotUsed (const NotUsed_optional& x);

        static NotUsed_type
        NotUsed_default_value ();

        // EpiLayer
        //
        typedef ::chaste::parameters::v2017_1::dimensionless_type EpiLayer_type;
        typedef ::xsd::cxx::tree::optional< EpiLayer_type > EpiLayer_optional;
        typedef ::xsd::cxx::tree::traits< EpiLayer_type, char > EpiLayer_traits;

        const EpiLayer_optional&
        EpiLayer () const;

        EpiLayer_optional&
        EpiLayer ();

        void
        EpiLayer (const EpiLayer_type& x);

        void
        EpiLayer (const EpiLayer_optional& x);

        void
        EpiLayer (::std::unique_ptr< EpiLayer_type > p);

        // MidLayer
        //
        typedef ::chaste::parameters::v2017_1::dimensionless_type MidLayer_type;
        typedef ::xsd::cxx::tree::optional< MidLayer_type > MidLayer_optional;
        typedef ::xsd::cxx::tree::traits< MidLayer_type, char > MidLayer_traits;

        const MidLayer_optional&
        MidLayer () const;

        MidLayer_optional&
        MidLayer ();

        void
        MidLayer (const MidLayer_type& x);

        void
        MidLayer (const MidLayer_optional& x);

        void
        MidLayer (::std::unique_ptr< MidLayer_type > p);

        // EndoLayer
        //
        typedef ::chaste::parameters::v2017_1::dimensionless_type EndoLayer_type;
        typedef ::xsd::cxx::tree::optional< EndoLayer_type > EndoLayer_optional;
        typedef ::xsd::cxx::tree::traits< EndoLayer_type, char > EndoLayer_traits;

        const EndoLayer_optional&
        EndoLayer () const;

        EndoLayer_optional&
        EndoLayer ();

        void
        EndoLayer (const EndoLayer_type& x);

        void
        EndoLayer (const EndoLayer_optional& x);

        void
        EndoLayer (::std::unique_ptr< EndoLayer_type > p);

        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        location_type ();

        location_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        location_type (const location_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual location_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        location_type&
        operator= (const location_type& x);

        virtual 
        ~location_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        Cuboid_optional Cuboid_;
        Ellipsoid_optional Ellipsoid_;
        NotUsed_optional NotUsed_;
        EpiLayer_optional EpiLayer_;
        MidLayer_optional MidLayer_;
        EndoLayer_optional EndoLayer_;
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class domain_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          Mono,
          Bi,
          BiWithBath
        };

        domain_type (value v);

        domain_type (const char* v);

        domain_type (const ::std::string& v);

        domain_type (const ::xml_schema::string& v);

        domain_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        domain_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        domain_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        domain_type (const domain_type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        virtual domain_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        domain_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_domain_type_convert ();
        }

        protected:
        value
        _xsd_domain_type_convert () const;

        public:
        static const char* const _xsd_domain_type_literals_[3];
        static const value _xsd_domain_type_indexes_[3];
      };

      class axis_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          x,
          y,
          z
        };

        axis_type (value v);

        axis_type (const char* v);

        axis_type (const ::std::string& v);

        axis_type (const ::xml_schema::string& v);

        axis_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        axis_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        axis_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        axis_type (const axis_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual axis_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        axis_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_axis_type_convert ();
        }

        protected:
        value
        _xsd_axis_type_convert () const;

        public:
        static const char* const _xsd_axis_type_literals_[3];
        static const value _xsd_axis_type_indexes_[3];
      };

      class ionic_models_available_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          DifrancescoNoble,
          Fox2002,
          Fox2002BackwardEuler,
          FaberRudy2000,
          FaberRudy2000Optimised,
          HodgkinHuxley,
          LuoRudyI,
          LuoRudyIBackwardEuler,
          MahajanShiferaw,
          MahajanShiferawBackwardEuler,
          Maleckar,
          tenTusscher2006,
          tenTusscher2006BackwardEuler
        };

        ionic_models_available_type (value v);

        ionic_models_available_type (const char* v);

        ionic_models_available_type (const ::std::string& v);

        ionic_models_available_type (const ::xml_schema::string& v);

        ionic_models_available_type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        ionic_models_available_type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        ionic_models_available_type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        ionic_models_available_type (const ionic_models_available_type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        virtual ionic_models_available_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ionic_models_available_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_ionic_models_available_type_convert ();
        }

        protected:
        value
        _xsd_ionic_models_available_type_convert () const;

        public:
        static const char* const _xsd_ionic_models_available_type_literals_[13];
        static const value _xsd_ionic_models_available_type_indexes_[13];
      };

      class ionic_model_selection_type: public ::xml_schema::type
      {
        public:
        // Hardcoded
        //
        typedef ::chaste::parameters::v2017_1::ionic_models_available_type Hardcoded_type;
        typedef ::xsd::cxx::tree::optional< Hardcoded_type > Hardcoded_optional;
        typedef ::xsd::cxx::tree::traits< Hardcoded_type, char > Hardcoded_traits;

        const Hardcoded_optional&
        Hardcoded () const;

        Hardcoded_optional&
        Hardcoded ();

        void
        Hardcoded (const Hardcoded_type& x);

        void
        Hardcoded (const Hardcoded_optional& x);

        void
        Hardcoded (::std::unique_ptr< Hardcoded_type > p);

        // Dynamic
        //
        typedef ::chaste::parameters::v2017_1::dynamically_loaded_ionic_model_type Dynamic_type;
        typedef ::xsd::cxx::tree::optional< Dynamic_type > Dynamic_optional;
        typedef ::xsd::cxx::tree::traits< Dynamic_type, char > Dynamic_traits;

        const Dynamic_optional&
        Dynamic () const;

        Dynamic_optional&
        Dynamic ();

        void
        Dynamic (const Dynamic_type& x);

        void
        Dynamic (const Dynamic_optional& x);

        void
        Dynamic (::std::unique_ptr< Dynamic_type > p);

        // Constructors.
        //
        ionic_model_selection_type ();

        ionic_model_selection_type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        ionic_model_selection_type (const ionic_model_selection_type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        virtual ionic_model_selection_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ionic_model_selection_type&
        operator= (const ionic_model_selection_type& x);

        virtual 
        ~ionic_model_selection_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        Hardcoded_optional Hardcoded_;
        Dynamic_optional Dynamic_;
      };

      class dynamically_loaded_ionic_model_type: public ::xml_schema::type
      {
        public:
        // Path
        //
        typedef ::chaste::parameters::v2017_1::path_type Path_type;
        typedef ::xsd::cxx::tree::traits< Path_type, char > Path_traits;

        const Path_type&
        Path () const;

        Path_type&
        Path ();

        void
        Path (const Path_type& x);

        void
        Path (::std::unique_ptr< Path_type > p);

        // Constructors.
        //
        dynamically_loaded_ionic_model_type (const Path_type&);

        dynamically_loaded_ionic_model_type (::std::unique_ptr< Path_type >);

        dynamically_loaded_ionic_model_type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

        dynamically_loaded_ionic_model_type (const dynamically_loaded_ionic_model_type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

        virtual dynamically_loaded_ionic_model_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        dynamically_loaded_ionic_model_type&
        operator= (const dynamically_loaded_ionic_model_type& x);

        virtual 
        ~dynamically_loaded_ionic_model_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Path_type > Path_;
      };

      class path_type: public ::xml_schema::string
      {
        public:
        // relative_to
        //
        typedef ::chaste::parameters::v2017_1::relative_to_type relative_to_type;
        typedef ::xsd::cxx::tree::traits< relative_to_type, char > relative_to_traits;

        const relative_to_type&
        relative_to () const;

        relative_to_type&
        relative_to ();

        void
        relative_to (const relative_to_type& x);

        void
        relative_to (::std::unique_ptr< relative_to_type > p);

        static const relative_to_type&
        relative_to_default_value ();

        // Constructors.
        //
        path_type ();

        path_type (const char*);

        path_type (const ::std::string&);

        path_type (const ::xml_schema::string&);

        path_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        path_type (const path_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual path_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        path_type&
        operator= (const path_type& x);

        virtual 
        ~path_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< relative_to_type > relative_to_;
        static const relative_to_type relative_to_default_value_;
      };

      class relative_to_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          cwd,
          chaste_test_output,
          chaste_source_root,
          chaste_build_root,
          absolute,
          this_file
        };

        relative_to_type (value v);

        relative_to_type (const char* v);

        relative_to_type (const ::std::string& v);

        relative_to_type (const ::xml_schema::string& v);

        relative_to_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        relative_to_type (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        relative_to_type (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        relative_to_type (const relative_to_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        virtual relative_to_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        relative_to_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_relative_to_type_convert ();
        }

        protected:
        value
        _xsd_relative_to_type_convert () const;

        public:
        static const char* const _xsd_relative_to_type_literals_[6];
        static const value _xsd_relative_to_type_indexes_[6];
      };

      class ionic_model_region_type: public ::xml_schema::type
      {
        public:
        // IonicModel
        //
        typedef ::chaste::parameters::v2017_1::ionic_model_selection_type IonicModel_type;
        typedef ::xsd::cxx::tree::traits< IonicModel_type, char > IonicModel_traits;

        const IonicModel_type&
        IonicModel () const;

        IonicModel_type&
        IonicModel ();

        void
        IonicModel (const IonicModel_type& x);

        void
        IonicModel (::std::unique_ptr< IonicModel_type > p);

        // Location
        //
        typedef ::chaste::parameters::v2017_1::location_type Location_type;
        typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

        const Location_type&
        Location () const;

        Location_type&
        Location ();

        void
        Location (const Location_type& x);

        void
        Location (::std::unique_ptr< Location_type > p);

        // Constructors.
        //
        ionic_model_region_type (const IonicModel_type&,
                                 const Location_type&);

        ionic_model_region_type (::std::unique_ptr< IonicModel_type >,
                                 ::std::unique_ptr< Location_type >);

        ionic_model_region_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        ionic_model_region_type (const ionic_model_region_type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        virtual ionic_model_region_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ionic_model_region_type&
        operator= (const ionic_model_region_type& x);

        virtual 
        ~ionic_model_region_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< IonicModel_type > IonicModel_;
        ::xsd::cxx::tree::one< Location_type > Location_;
      };

      class ionic_models_type: public ::xml_schema::type
      {
        public:
        // Default
        //
        typedef ::chaste::parameters::v2017_1::ionic_model_selection_type Default_type;
        typedef ::xsd::cxx::tree::traits< Default_type, char > Default_traits;

        const Default_type&
        Default () const;

        Default_type&
        Default ();

        void
        Default (const Default_type& x);

        void
        Default (::std::unique_ptr< Default_type > p);

        // Region
        //
        typedef ::chaste::parameters::v2017_1::ionic_model_region_type Region_type;
        typedef ::xsd::cxx::tree::sequence< Region_type > Region_sequence;
        typedef Region_sequence::iterator Region_iterator;
        typedef Region_sequence::const_iterator Region_const_iterator;
        typedef ::xsd::cxx::tree::traits< Region_type, char > Region_traits;

        const Region_sequence&
        Region () const;

        Region_sequence&
        Region ();

        void
        Region (const Region_sequence& s);

        // Constructors.
        //
        ionic_models_type (const Default_type&);

        ionic_models_type (::std::unique_ptr< Default_type >);

        ionic_models_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        ionic_models_type (const ionic_models_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        virtual ionic_models_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ionic_models_type&
        operator= (const ionic_models_type& x);

        virtual 
        ~ionic_models_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Default_type > Default_;
        Region_sequence Region_;
      };

      class apd_map_type: public ::xml_schema::type
      {
        public:
        // repolarisation_percentage
        //
        typedef ::xml_schema::double_ repolarisation_percentage_type;
        typedef ::xsd::cxx::tree::traits< repolarisation_percentage_type, char, ::xsd::cxx::tree::schema_type::double_ > repolarisation_percentage_traits;

        const repolarisation_percentage_type&
        repolarisation_percentage () const;

        repolarisation_percentage_type&
        repolarisation_percentage ();

        void
        repolarisation_percentage (const repolarisation_percentage_type& x);

        // threshold
        //
        typedef ::xml_schema::double_ threshold_type;
        typedef ::xsd::cxx::tree::traits< threshold_type, char, ::xsd::cxx::tree::schema_type::double_ > threshold_traits;

        const threshold_type&
        threshold () const;

        threshold_type&
        threshold ();

        void
        threshold (const threshold_type& x);

        // threshold_unit
        //
        typedef ::xml_schema::string threshold_unit_type;
        typedef ::xsd::cxx::tree::traits< threshold_unit_type, char > threshold_unit_traits;

        const threshold_unit_type&
        threshold_unit () const;

        static const threshold_unit_type&
        threshold_unit_default_value ();

        // Constructors.
        //
        apd_map_type (const repolarisation_percentage_type&,
                      const threshold_type&);

        apd_map_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        apd_map_type (const apd_map_type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual apd_map_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        apd_map_type&
        operator= (const apd_map_type& x);

        virtual 
        ~apd_map_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< repolarisation_percentage_type > repolarisation_percentage_;
        ::xsd::cxx::tree::one< threshold_type > threshold_;
        ::xsd::cxx::tree::one< threshold_unit_type > threshold_unit_;
        static const threshold_unit_type threshold_unit_default_value_;
      };

      class upstrokes_map_type: public ::xml_schema::type
      {
        public:
        // threshold
        //
        typedef ::xml_schema::double_ threshold_type;
        typedef ::xsd::cxx::tree::traits< threshold_type, char, ::xsd::cxx::tree::schema_type::double_ > threshold_traits;

        const threshold_type&
        threshold () const;

        threshold_type&
        threshold ();

        void
        threshold (const threshold_type& x);

        // threshold_unit
        //
        typedef ::xml_schema::string threshold_unit_type;
        typedef ::xsd::cxx::tree::traits< threshold_unit_type, char > threshold_unit_traits;

        const threshold_unit_type&
        threshold_unit () const;

        static const threshold_unit_type&
        threshold_unit_default_value ();

        // Constructors.
        //
        upstrokes_map_type (const threshold_type&);

        upstrokes_map_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        upstrokes_map_type (const upstrokes_map_type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        virtual upstrokes_map_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        upstrokes_map_type&
        operator= (const upstrokes_map_type& x);

        virtual 
        ~upstrokes_map_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< threshold_type > threshold_;
        ::xsd::cxx::tree::one< threshold_unit_type > threshold_unit_;
        static const threshold_unit_type threshold_unit_default_value_;
      };

      class max_upstrokes_velocity_map_type: public ::xml_schema::type
      {
        public:
        // threshold
        //
        typedef ::xml_schema::double_ threshold_type;
        typedef ::xsd::cxx::tree::traits< threshold_type, char, ::xsd::cxx::tree::schema_type::double_ > threshold_traits;

        const threshold_type&
        threshold () const;

        threshold_type&
        threshold ();

        void
        threshold (const threshold_type& x);

        // threshold_unit
        //
        typedef ::xml_schema::string threshold_unit_type;
        typedef ::xsd::cxx::tree::traits< threshold_unit_type, char > threshold_unit_traits;

        const threshold_unit_type&
        threshold_unit () const;

        static const threshold_unit_type&
        threshold_unit_default_value ();

        // Constructors.
        //
        max_upstrokes_velocity_map_type (const threshold_type&);

        max_upstrokes_velocity_map_type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

        max_upstrokes_velocity_map_type (const max_upstrokes_velocity_map_type& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

        virtual max_upstrokes_velocity_map_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        max_upstrokes_velocity_map_type&
        operator= (const max_upstrokes_velocity_map_type& x);

        virtual 
        ~max_upstrokes_velocity_map_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< threshold_type > threshold_;
        ::xsd::cxx::tree::one< threshold_unit_type > threshold_unit_;
        static const threshold_unit_type threshold_unit_default_value_;
      };

      class conduction_velocity_map_type: public ::xml_schema::type
      {
        public:
        // origin_node
        //
        typedef ::xml_schema::non_negative_integer origin_node_type;
        typedef ::xsd::cxx::tree::traits< origin_node_type, char > origin_node_traits;

        const origin_node_type&
        origin_node () const;

        origin_node_type&
        origin_node ();

        void
        origin_node (const origin_node_type& x);

        // Constructors.
        //
        conduction_velocity_map_type (const origin_node_type&);

        conduction_velocity_map_type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

        conduction_velocity_map_type (const conduction_velocity_map_type& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

        virtual conduction_velocity_map_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        conduction_velocity_map_type&
        operator= (const conduction_velocity_map_type& x);

        virtual 
        ~conduction_velocity_map_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< origin_node_type > origin_node_;
      };

      class node_number_type: public ::xml_schema::type
      {
        public:
        // node_number
        //
        typedef ::xml_schema::non_negative_integer node_number_type1;
        typedef ::xsd::cxx::tree::traits< node_number_type1, char > node_number_traits;

        const node_number_type1&
        node_number () const;

        node_number_type1&
        node_number ();

        void
        node_number (const node_number_type1& x);

        // Constructors.
        //
        node_number_type (const node_number_type1&);

        node_number_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        node_number_type (const node_number_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        virtual node_number_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        node_number_type&
        operator= (const node_number_type& x);

        virtual 
        ~node_number_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< node_number_type1 > node_number_;
      };

      class media_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          Orthotropic,
          Axisymmetric,
          NoFibreOrientation
        };

        media_type (value v);

        media_type (const char* v);

        media_type (const ::std::string& v);

        media_type (const ::xml_schema::string& v);

        media_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        media_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        media_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        media_type (const media_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual media_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        media_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_media_type_convert ();
        }

        protected:
        value
        _xsd_media_type_convert () const;

        public:
        static const char* const _xsd_media_type_literals_[3];
        static const value _xsd_media_type_indexes_[3];
      };

      class point_type: public ::xml_schema::type
      {
        public:
        // x
        //
        typedef ::xml_schema::double_ x_type;
        typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

        const x_type&
        x () const;

        x_type&
        x ();

        void
        x (const x_type& x);

        // y
        //
        typedef ::xml_schema::double_ y_type;
        typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

        const y_type&
        y () const;

        y_type&
        y ();

        void
        y (const y_type& x);

        // z
        //
        typedef ::xml_schema::double_ z_type;
        typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

        const z_type&
        z () const;

        z_type&
        z ();

        void
        z (const z_type& x);

        // Constructors.
        //
        point_type (const x_type&,
                    const y_type&,
                    const z_type&);

        point_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        point_type (const point_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual point_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        point_type&
        operator= (const point_type& x);

        virtual 
        ~point_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< x_type > x_;
        ::xsd::cxx::tree::one< y_type > y_;
        ::xsd::cxx::tree::one< z_type > z_;
      };

      class box_type: public ::xml_schema::type
      {
        public:
        // LowerCoordinates
        //
        typedef ::chaste::parameters::v2017_1::point_type LowerCoordinates_type;
        typedef ::xsd::cxx::tree::traits< LowerCoordinates_type, char > LowerCoordinates_traits;

        const LowerCoordinates_type&
        LowerCoordinates () const;

        LowerCoordinates_type&
        LowerCoordinates ();

        void
        LowerCoordinates (const LowerCoordinates_type& x);

        void
        LowerCoordinates (::std::unique_ptr< LowerCoordinates_type > p);

        // UpperCoordinates
        //
        typedef ::chaste::parameters::v2017_1::point_type UpperCoordinates_type;
        typedef ::xsd::cxx::tree::traits< UpperCoordinates_type, char > UpperCoordinates_traits;

        const UpperCoordinates_type&
        UpperCoordinates () const;

        UpperCoordinates_type&
        UpperCoordinates ();

        void
        UpperCoordinates (const UpperCoordinates_type& x);

        void
        UpperCoordinates (::std::unique_ptr< UpperCoordinates_type > p);

        // Constructors.
        //
        box_type (const LowerCoordinates_type&,
                  const UpperCoordinates_type&);

        box_type (::std::unique_ptr< LowerCoordinates_type >,
                  ::std::unique_ptr< UpperCoordinates_type >);

        box_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        box_type (const box_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        virtual box_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        box_type&
        operator= (const box_type& x);

        virtual 
        ~box_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< LowerCoordinates_type > LowerCoordinates_;
        ::xsd::cxx::tree::one< UpperCoordinates_type > UpperCoordinates_;
      };

      class ellipsoid_type: public ::xml_schema::type
      {
        public:
        // Centre
        //
        typedef ::chaste::parameters::v2017_1::point_type Centre_type;
        typedef ::xsd::cxx::tree::traits< Centre_type, char > Centre_traits;

        const Centre_type&
        Centre () const;

        Centre_type&
        Centre ();

        void
        Centre (const Centre_type& x);

        void
        Centre (::std::unique_ptr< Centre_type > p);

        // Radii
        //
        typedef ::chaste::parameters::v2017_1::point_type Radii_type;
        typedef ::xsd::cxx::tree::traits< Radii_type, char > Radii_traits;

        const Radii_type&
        Radii () const;

        Radii_type&
        Radii ();

        void
        Radii (const Radii_type& x);

        void
        Radii (::std::unique_ptr< Radii_type > p);

        // Constructors.
        //
        ellipsoid_type (const Centre_type&,
                        const Radii_type&);

        ellipsoid_type (::std::unique_ptr< Centre_type >,
                        ::std::unique_ptr< Radii_type >);

        ellipsoid_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        ellipsoid_type (const ellipsoid_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual ellipsoid_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ellipsoid_type&
        operator= (const ellipsoid_type& x);

        virtual 
        ~ellipsoid_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Centre_type > Centre_;
        ::xsd::cxx::tree::one< Radii_type > Radii_;
      };

      class stimulus_type: public ::xml_schema::type
      {
        public:
        // Strength
        //
        typedef ::chaste::parameters::v2017_1::stimulus_strength_type Strength_type;
        typedef ::xsd::cxx::tree::traits< Strength_type, char > Strength_traits;

        const Strength_type&
        Strength () const;

        Strength_type&
        Strength ();

        void
        Strength (const Strength_type& x);

        void
        Strength (::std::unique_ptr< Strength_type > p);

        // Duration
        //
        typedef ::chaste::parameters::v2017_1::time_type Duration_type;
        typedef ::xsd::cxx::tree::traits< Duration_type, char > Duration_traits;

        const Duration_type&
        Duration () const;

        Duration_type&
        Duration ();

        void
        Duration (const Duration_type& x);

        void
        Duration (::std::unique_ptr< Duration_type > p);

        // Delay
        //
        typedef ::chaste::parameters::v2017_1::time_type Delay_type;
        typedef ::xsd::cxx::tree::traits< Delay_type, char > Delay_traits;

        const Delay_type&
        Delay () const;

        Delay_type&
        Delay ();

        void
        Delay (const Delay_type& x);

        void
        Delay (::std::unique_ptr< Delay_type > p);

        // Period
        //
        typedef ::chaste::parameters::v2017_1::time_type Period_type;
        typedef ::xsd::cxx::tree::optional< Period_type > Period_optional;
        typedef ::xsd::cxx::tree::traits< Period_type, char > Period_traits;

        const Period_optional&
        Period () const;

        Period_optional&
        Period ();

        void
        Period (const Period_type& x);

        void
        Period (const Period_optional& x);

        void
        Period (::std::unique_ptr< Period_type > p);

        // StopTime
        //
        typedef ::chaste::parameters::v2017_1::time_type StopTime_type;
        typedef ::xsd::cxx::tree::optional< StopTime_type > StopTime_optional;
        typedef ::xsd::cxx::tree::traits< StopTime_type, char > StopTime_traits;

        const StopTime_optional&
        StopTime () const;

        StopTime_optional&
        StopTime ();

        void
        StopTime (const StopTime_type& x);

        void
        StopTime (const StopTime_optional& x);

        void
        StopTime (::std::unique_ptr< StopTime_type > p);

        // Location
        //
        typedef ::chaste::parameters::v2017_1::location_type Location_type;
        typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

        const Location_type&
        Location () const;

        Location_type&
        Location ();

        void
        Location (const Location_type& x);

        void
        Location (::std::unique_ptr< Location_type > p);

        // Constructors.
        //
        stimulus_type (const Strength_type&,
                       const Duration_type&,
                       const Delay_type&,
                       const Location_type&);

        stimulus_type (::std::unique_ptr< Strength_type >,
                       ::std::unique_ptr< Duration_type >,
                       ::std::unique_ptr< Delay_type >,
                       ::std::unique_ptr< Location_type >);

        stimulus_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        stimulus_type (const stimulus_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual stimulus_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        stimulus_type&
        operator= (const stimulus_type& x);

        virtual 
        ~stimulus_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Strength_type > Strength_;
        ::xsd::cxx::tree::one< Duration_type > Duration_;
        ::xsd::cxx::tree::one< Delay_type > Delay_;
        Period_optional Period_;
        StopTime_optional StopTime_;
        ::xsd::cxx::tree::one< Location_type > Location_;
      };

      class set_parameter_type: public ::xml_schema::type
      {
        public:
        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_type&
        name () const;

        name_type&
        name ();

        void
        name (const name_type& x);

        void
        name (::std::unique_ptr< name_type > p);

        // value
        //
        typedef ::xml_schema::double_ value_type;
        typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

        const value_type&
        value () const;

        value_type&
        value ();

        void
        value (const value_type& x);

        // Constructors.
        //
        set_parameter_type (const name_type&,
                            const value_type&);

        set_parameter_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        set_parameter_type (const set_parameter_type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        virtual set_parameter_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        set_parameter_type&
        operator= (const set_parameter_type& x);

        virtual 
        ~set_parameter_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< name_type > name_;
        ::xsd::cxx::tree::one< value_type > value_;
      };

      class electrodes_type: public ::xml_schema::type
      {
        public:
        // GroundSecondElectrode
        //
        typedef ::chaste::parameters::v2017_1::yesno_type GroundSecondElectrode_type;
        typedef ::xsd::cxx::tree::traits< GroundSecondElectrode_type, char > GroundSecondElectrode_traits;

        const GroundSecondElectrode_type&
        GroundSecondElectrode () const;

        GroundSecondElectrode_type&
        GroundSecondElectrode ();

        void
        GroundSecondElectrode (const GroundSecondElectrode_type& x);

        void
        GroundSecondElectrode (::std::unique_ptr< GroundSecondElectrode_type > p);

        // PerpendicularToAxis
        //
        typedef ::chaste::parameters::v2017_1::axis_type PerpendicularToAxis_type;
        typedef ::xsd::cxx::tree::traits< PerpendicularToAxis_type, char > PerpendicularToAxis_traits;

        const PerpendicularToAxis_type&
        PerpendicularToAxis () const;

        PerpendicularToAxis_type&
        PerpendicularToAxis ();

        void
        PerpendicularToAxis (const PerpendicularToAxis_type& x);

        void
        PerpendicularToAxis (::std::unique_ptr< PerpendicularToAxis_type > p);

        // Strength
        //
        typedef ::chaste::parameters::v2017_1::surface_stimulus_strength_type Strength_type;
        typedef ::xsd::cxx::tree::traits< Strength_type, char > Strength_traits;

        const Strength_type&
        Strength () const;

        Strength_type&
        Strength ();

        void
        Strength (const Strength_type& x);

        void
        Strength (::std::unique_ptr< Strength_type > p);

        // StartTime
        //
        typedef ::chaste::parameters::v2017_1::time_type StartTime_type;
        typedef ::xsd::cxx::tree::traits< StartTime_type, char > StartTime_traits;

        const StartTime_type&
        StartTime () const;

        StartTime_type&
        StartTime ();

        void
        StartTime (const StartTime_type& x);

        void
        StartTime (::std::unique_ptr< StartTime_type > p);

        // Duration
        //
        typedef ::chaste::parameters::v2017_1::time_type Duration_type;
        typedef ::xsd::cxx::tree::traits< Duration_type, char > Duration_traits;

        const Duration_type&
        Duration () const;

        Duration_type&
        Duration ();

        void
        Duration (const Duration_type& x);

        void
        Duration (::std::unique_ptr< Duration_type > p);

        // Constructors.
        //
        electrodes_type (const GroundSecondElectrode_type&,
                         const PerpendicularToAxis_type&,
                         const Strength_type&,
                         const StartTime_type&,
                         const Duration_type&);

        electrodes_type (const GroundSecondElectrode_type&,
                         const PerpendicularToAxis_type&,
                         ::std::unique_ptr< Strength_type >,
                         ::std::unique_ptr< StartTime_type >,
                         ::std::unique_ptr< Duration_type >);

        electrodes_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        electrodes_type (const electrodes_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual electrodes_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        electrodes_type&
        operator= (const electrodes_type& x);

        virtual 
        ~electrodes_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< GroundSecondElectrode_type > GroundSecondElectrode_;
        ::xsd::cxx::tree::one< PerpendicularToAxis_type > PerpendicularToAxis_;
        ::xsd::cxx::tree::one< Strength_type > Strength_;
        ::xsd::cxx::tree::one< StartTime_type > StartTime_;
        ::xsd::cxx::tree::one< Duration_type > Duration_;
      };

      class cell_heterogeneity_type: public ::xml_schema::type
      {
        public:
        // ScaleFactorGks
        //
        typedef ::chaste::parameters::v2017_1::dimensionless_type ScaleFactorGks_type;
        typedef ::xsd::cxx::tree::optional< ScaleFactorGks_type > ScaleFactorGks_optional;
        typedef ::xsd::cxx::tree::traits< ScaleFactorGks_type, char > ScaleFactorGks_traits;

        const ScaleFactorGks_optional&
        ScaleFactorGks () const;

        ScaleFactorGks_optional&
        ScaleFactorGks ();

        void
        ScaleFactorGks (const ScaleFactorGks_type& x);

        void
        ScaleFactorGks (const ScaleFactorGks_optional& x);

        void
        ScaleFactorGks (::std::unique_ptr< ScaleFactorGks_type > p);

        // ScaleFactorIto
        //
        typedef ::chaste::parameters::v2017_1::dimensionless_type ScaleFactorIto_type;
        typedef ::xsd::cxx::tree::optional< ScaleFactorIto_type > ScaleFactorIto_optional;
        typedef ::xsd::cxx::tree::traits< ScaleFactorIto_type, char > ScaleFactorIto_traits;

        const ScaleFactorIto_optional&
        ScaleFactorIto () const;

        ScaleFactorIto_optional&
        ScaleFactorIto ();

        void
        ScaleFactorIto (const ScaleFactorIto_type& x);

        void
        ScaleFactorIto (const ScaleFactorIto_optional& x);

        void
        ScaleFactorIto (::std::unique_ptr< ScaleFactorIto_type > p);

        // ScaleFactorGkr
        //
        typedef ::chaste::parameters::v2017_1::dimensionless_type ScaleFactorGkr_type;
        typedef ::xsd::cxx::tree::optional< ScaleFactorGkr_type > ScaleFactorGkr_optional;
        typedef ::xsd::cxx::tree::traits< ScaleFactorGkr_type, char > ScaleFactorGkr_traits;

        const ScaleFactorGkr_optional&
        ScaleFactorGkr () const;

        ScaleFactorGkr_optional&
        ScaleFactorGkr ();

        void
        ScaleFactorGkr (const ScaleFactorGkr_type& x);

        void
        ScaleFactorGkr (const ScaleFactorGkr_optional& x);

        void
        ScaleFactorGkr (::std::unique_ptr< ScaleFactorGkr_type > p);

        // Location
        //
        typedef ::chaste::parameters::v2017_1::location_type Location_type;
        typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

        const Location_type&
        Location () const;

        Location_type&
        Location ();

        void
        Location (const Location_type& x);

        void
        Location (::std::unique_ptr< Location_type > p);

        // SetParameter
        //
        typedef ::chaste::parameters::v2017_1::set_parameter_type SetParameter_type;
        typedef ::xsd::cxx::tree::sequence< SetParameter_type > SetParameter_sequence;
        typedef SetParameter_sequence::iterator SetParameter_iterator;
        typedef SetParameter_sequence::const_iterator SetParameter_const_iterator;
        typedef ::xsd::cxx::tree::traits< SetParameter_type, char > SetParameter_traits;

        const SetParameter_sequence&
        SetParameter () const;

        SetParameter_sequence&
        SetParameter ();

        void
        SetParameter (const SetParameter_sequence& s);

        // Constructors.
        //
        cell_heterogeneity_type (const Location_type&);

        cell_heterogeneity_type (::std::unique_ptr< Location_type >);

        cell_heterogeneity_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        cell_heterogeneity_type (const cell_heterogeneity_type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        virtual cell_heterogeneity_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        cell_heterogeneity_type&
        operator= (const cell_heterogeneity_type& x);

        virtual 
        ~cell_heterogeneity_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ScaleFactorGks_optional ScaleFactorGks_;
        ScaleFactorIto_optional ScaleFactorIto_;
        ScaleFactorGkr_optional ScaleFactorGkr_;
        ::xsd::cxx::tree::one< Location_type > Location_;
        SetParameter_sequence SetParameter_;
      };

      class conductivity_heterogeneity_type: public ::xml_schema::type
      {
        public:
        // IntracellularConductivities
        //
        typedef ::chaste::parameters::v2017_1::conductivities_type IntracellularConductivities_type;
        typedef ::xsd::cxx::tree::optional< IntracellularConductivities_type > IntracellularConductivities_optional;
        typedef ::xsd::cxx::tree::traits< IntracellularConductivities_type, char > IntracellularConductivities_traits;

        const IntracellularConductivities_optional&
        IntracellularConductivities () const;

        IntracellularConductivities_optional&
        IntracellularConductivities ();

        void
        IntracellularConductivities (const IntracellularConductivities_type& x);

        void
        IntracellularConductivities (const IntracellularConductivities_optional& x);

        void
        IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > p);

        // ExtracellularConductivities
        //
        typedef ::chaste::parameters::v2017_1::conductivities_type ExtracellularConductivities_type;
        typedef ::xsd::cxx::tree::optional< ExtracellularConductivities_type > ExtracellularConductivities_optional;
        typedef ::xsd::cxx::tree::traits< ExtracellularConductivities_type, char > ExtracellularConductivities_traits;

        const ExtracellularConductivities_optional&
        ExtracellularConductivities () const;

        ExtracellularConductivities_optional&
        ExtracellularConductivities ();

        void
        ExtracellularConductivities (const ExtracellularConductivities_type& x);

        void
        ExtracellularConductivities (const ExtracellularConductivities_optional& x);

        void
        ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > p);

        // Location
        //
        typedef ::chaste::parameters::v2017_1::location_type Location_type;
        typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

        const Location_type&
        Location () const;

        Location_type&
        Location ();

        void
        Location (const Location_type& x);

        void
        Location (::std::unique_ptr< Location_type > p);

        // Constructors.
        //
        conductivity_heterogeneity_type (const Location_type&);

        conductivity_heterogeneity_type (::std::unique_ptr< Location_type >);

        conductivity_heterogeneity_type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

        conductivity_heterogeneity_type (const conductivity_heterogeneity_type& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

        virtual conductivity_heterogeneity_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        conductivity_heterogeneity_type&
        operator= (const conductivity_heterogeneity_type& x);

        virtual 
        ~conductivity_heterogeneity_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        IntracellularConductivities_optional IntracellularConductivities_;
        ExtracellularConductivities_optional ExtracellularConductivities_;
        ::xsd::cxx::tree::one< Location_type > Location_;
      };

      class slab_type: public ::xml_schema::type
      {
        public:
        // x
        //
        typedef ::xml_schema::double_ x_type;
        typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

        const x_type&
        x () const;

        x_type&
        x ();

        void
        x (const x_type& x);

        // y
        //
        typedef ::xml_schema::double_ y_type;
        typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

        const y_type&
        y () const;

        y_type&
        y ();

        void
        y (const y_type& x);

        // z
        //
        typedef ::xml_schema::double_ z_type;
        typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

        const z_type&
        z () const;

        z_type&
        z ();

        void
        z (const z_type& x);

        // inter_node_space
        //
        typedef ::xml_schema::double_ inter_node_space_type;
        typedef ::xsd::cxx::tree::traits< inter_node_space_type, char, ::xsd::cxx::tree::schema_type::double_ > inter_node_space_traits;

        const inter_node_space_type&
        inter_node_space () const;

        inter_node_space_type&
        inter_node_space ();

        void
        inter_node_space (const inter_node_space_type& x);

        // Constructors.
        //
        slab_type (const x_type&,
                   const y_type&,
                   const z_type&,
                   const inter_node_space_type&);

        slab_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        slab_type (const slab_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual slab_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        slab_type&
        operator= (const slab_type& x);

        virtual 
        ~slab_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< x_type > x_;
        ::xsd::cxx::tree::one< y_type > y_;
        ::xsd::cxx::tree::one< z_type > z_;
        ::xsd::cxx::tree::one< inter_node_space_type > inter_node_space_;
      };

      class sheet_type: public ::xml_schema::type
      {
        public:
        // x
        //
        typedef ::xml_schema::double_ x_type;
        typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

        const x_type&
        x () const;

        x_type&
        x ();

        void
        x (const x_type& x);

        // y
        //
        typedef ::xml_schema::double_ y_type;
        typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

        const y_type&
        y () const;

        y_type&
        y ();

        void
        y (const y_type& x);

        // inter_node_space
        //
        typedef ::xml_schema::double_ inter_node_space_type;
        typedef ::xsd::cxx::tree::traits< inter_node_space_type, char, ::xsd::cxx::tree::schema_type::double_ > inter_node_space_traits;

        const inter_node_space_type&
        inter_node_space () const;

        inter_node_space_type&
        inter_node_space ();

        void
        inter_node_space (const inter_node_space_type& x);

        // Constructors.
        //
        sheet_type (const x_type&,
                    const y_type&,
                    const inter_node_space_type&);

        sheet_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        sheet_type (const sheet_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual sheet_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        sheet_type&
        operator= (const sheet_type& x);

        virtual 
        ~sheet_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< x_type > x_;
        ::xsd::cxx::tree::one< y_type > y_;
        ::xsd::cxx::tree::one< inter_node_space_type > inter_node_space_;
      };

      class fibre_type: public ::xml_schema::type
      {
        public:
        // x
        //
        typedef ::xml_schema::double_ x_type;
        typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

        const x_type&
        x () const;

        x_type&
        x ();

        void
        x (const x_type& x);

        // inter_node_space
        //
        typedef ::xml_schema::double_ inter_node_space_type;
        typedef ::xsd::cxx::tree::traits< inter_node_space_type, char, ::xsd::cxx::tree::schema_type::double_ > inter_node_space_traits;

        const inter_node_space_type&
        inter_node_space () const;

        inter_node_space_type&
        inter_node_space ();

        void
        inter_node_space (const inter_node_space_type& x);

        // Constructors.
        //
        fibre_type (const x_type&,
                    const inter_node_space_type&);

        fibre_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        fibre_type (const fibre_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual fibre_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        fibre_type&
        operator= (const fibre_type& x);

        virtual 
        ~fibre_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< x_type > x_;
        ::xsd::cxx::tree::one< inter_node_space_type > inter_node_space_;
      };

      class load_mesh_type: public ::xml_schema::type
      {
        public:
        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_type&
        name () const;

        name_type&
        name ();

        void
        name (const name_type& x);

        void
        name (::std::unique_ptr< name_type > p);

        // conductivity_media
        //
        typedef ::chaste::parameters::v2017_1::media_type conductivity_media_type;
        typedef ::xsd::cxx::tree::traits< conductivity_media_type, char > conductivity_media_traits;

        const conductivity_media_type&
        conductivity_media () const;

        conductivity_media_type&
        conductivity_media ();

        void
        conductivity_media (const conductivity_media_type& x);

        void
        conductivity_media (::std::unique_ptr< conductivity_media_type > p);

        // Constructors.
        //
        load_mesh_type (const name_type&,
                        const conductivity_media_type&);

        load_mesh_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        load_mesh_type (const load_mesh_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual load_mesh_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        load_mesh_type&
        operator= (const load_mesh_type& x);

        virtual 
        ~load_mesh_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< name_type > name_;
        ::xsd::cxx::tree::one< conductivity_media_type > conductivity_media_;
      };

      class mesh_type: public ::xml_schema::type
      {
        public:
        // Slab
        //
        typedef ::chaste::parameters::v2017_1::slab_type Slab_type;
        typedef ::xsd::cxx::tree::optional< Slab_type > Slab_optional;
        typedef ::xsd::cxx::tree::traits< Slab_type, char > Slab_traits;

        const Slab_optional&
        Slab () const;

        Slab_optional&
        Slab ();

        void
        Slab (const Slab_type& x);

        void
        Slab (const Slab_optional& x);

        void
        Slab (::std::unique_ptr< Slab_type > p);

        // Sheet
        //
        typedef ::chaste::parameters::v2017_1::sheet_type Sheet_type;
        typedef ::xsd::cxx::tree::optional< Sheet_type > Sheet_optional;
        typedef ::xsd::cxx::tree::traits< Sheet_type, char > Sheet_traits;

        const Sheet_optional&
        Sheet () const;

        Sheet_optional&
        Sheet ();

        void
        Sheet (const Sheet_type& x);

        void
        Sheet (const Sheet_optional& x);

        void
        Sheet (::std::unique_ptr< Sheet_type > p);

        // Fibre
        //
        typedef ::chaste::parameters::v2017_1::fibre_type Fibre_type;
        typedef ::xsd::cxx::tree::optional< Fibre_type > Fibre_optional;
        typedef ::xsd::cxx::tree::traits< Fibre_type, char > Fibre_traits;

        const Fibre_optional&
        Fibre () const;

        Fibre_optional&
        Fibre ();

        void
        Fibre (const Fibre_type& x);

        void
        Fibre (const Fibre_optional& x);

        void
        Fibre (::std::unique_ptr< Fibre_type > p);

        // LoadMesh
        //
        typedef ::chaste::parameters::v2017_1::load_mesh_type LoadMesh_type;
        typedef ::xsd::cxx::tree::optional< LoadMesh_type > LoadMesh_optional;
        typedef ::xsd::cxx::tree::traits< LoadMesh_type, char > LoadMesh_traits;

        const LoadMesh_optional&
        LoadMesh () const;

        LoadMesh_optional&
        LoadMesh ();

        void
        LoadMesh (const LoadMesh_type& x);

        void
        LoadMesh (const LoadMesh_optional& x);

        void
        LoadMesh (::std::unique_ptr< LoadMesh_type > p);

        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        mesh_type ();

        mesh_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        mesh_type (const mesh_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual mesh_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        mesh_type&
        operator= (const mesh_type& x);

        virtual 
        ~mesh_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        Slab_optional Slab_;
        Sheet_optional Sheet_;
        Fibre_optional Fibre_;
        LoadMesh_optional LoadMesh_;
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class conductivities_type: public ::xml_schema::type
      {
        public:
        // longi
        //
        typedef ::xml_schema::double_ longi_type;
        typedef ::xsd::cxx::tree::traits< longi_type, char, ::xsd::cxx::tree::schema_type::double_ > longi_traits;

        const longi_type&
        longi () const;

        longi_type&
        longi ();

        void
        longi (const longi_type& x);

        // trans
        //
        typedef ::xml_schema::double_ trans_type;
        typedef ::xsd::cxx::tree::traits< trans_type, char, ::xsd::cxx::tree::schema_type::double_ > trans_traits;

        const trans_type&
        trans () const;

        trans_type&
        trans ();

        void
        trans (const trans_type& x);

        // normal
        //
        typedef ::xml_schema::double_ normal_type;
        typedef ::xsd::cxx::tree::traits< normal_type, char, ::xsd::cxx::tree::schema_type::double_ > normal_traits;

        const normal_type&
        normal () const;

        normal_type&
        normal ();

        void
        normal (const normal_type& x);

        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        conductivities_type (const longi_type&,
                             const trans_type&,
                             const normal_type&);

        conductivities_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        conductivities_type (const conductivities_type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        virtual conductivities_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        conductivities_type&
        operator= (const conductivities_type& x);

        virtual 
        ~conductivities_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< longi_type > longi_;
        ::xsd::cxx::tree::one< trans_type > trans_;
        ::xsd::cxx::tree::one< normal_type > normal_;
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class var_type: public ::xml_schema::type
      {
        public:
        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_type&
        name () const;

        name_type&
        name ();

        void
        name (const name_type& x);

        void
        name (::std::unique_ptr< name_type > p);

        // Constructors.
        //
        var_type (const name_type&);

        var_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        var_type (const var_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        virtual var_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        var_type&
        operator= (const var_type& x);

        virtual 
        ~var_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< name_type > name_;
      };

      class output_variables_type: public ::xml_schema::type
      {
        public:
        // Var
        //
        typedef ::chaste::parameters::v2017_1::var_type Var_type;
        typedef ::xsd::cxx::tree::sequence< Var_type > Var_sequence;
        typedef Var_sequence::iterator Var_iterator;
        typedef Var_sequence::const_iterator Var_const_iterator;
        typedef ::xsd::cxx::tree::traits< Var_type, char > Var_traits;

        const Var_sequence&
        Var () const;

        Var_sequence&
        Var ();

        void
        Var (const Var_sequence& s);

        // Constructors.
        //
        output_variables_type ();

        output_variables_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        output_variables_type (const output_variables_type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        virtual output_variables_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        output_variables_type&
        operator= (const output_variables_type& x);

        virtual 
        ~output_variables_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        Var_sequence Var_;
      };

      class yesno_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          yes,
          no
        };

        yesno_type (value v);

        yesno_type (const char* v);

        yesno_type (const ::std::string& v);

        yesno_type (const ::xml_schema::string& v);

        yesno_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        yesno_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        yesno_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        yesno_type (const yesno_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual yesno_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        yesno_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_yesno_type_convert ();
        }

        protected:
        value
        _xsd_yesno_type_convert () const;

        public:
        static const char* const _xsd_yesno_type_literals_[2];
        static const value _xsd_yesno_type_indexes_[2];
      };

      class output_visualizer_type: public ::xml_schema::type
      {
        public:
        // meshalyzer
        //
        typedef ::chaste::parameters::v2017_1::yesno_type meshalyzer_type;
        typedef ::xsd::cxx::tree::traits< meshalyzer_type, char > meshalyzer_traits;

        const meshalyzer_type&
        meshalyzer () const;

        meshalyzer_type&
        meshalyzer ();

        void
        meshalyzer (const meshalyzer_type& x);

        void
        meshalyzer (::std::unique_ptr< meshalyzer_type > p);

        static const meshalyzer_type&
        meshalyzer_default_value ();

        // cmgui
        //
        typedef ::chaste::parameters::v2017_1::yesno_type cmgui_type;
        typedef ::xsd::cxx::tree::traits< cmgui_type, char > cmgui_traits;

        const cmgui_type&
        cmgui () const;

        cmgui_type&
        cmgui ();

        void
        cmgui (const cmgui_type& x);

        void
        cmgui (::std::unique_ptr< cmgui_type > p);

        static const cmgui_type&
        cmgui_default_value ();

        // vtk
        //
        typedef ::chaste::parameters::v2017_1::yesno_type vtk_type;
        typedef ::xsd::cxx::tree::traits< vtk_type, char > vtk_traits;

        const vtk_type&
        vtk () const;

        vtk_type&
        vtk ();

        void
        vtk (const vtk_type& x);

        void
        vtk (::std::unique_ptr< vtk_type > p);

        static const vtk_type&
        vtk_default_value ();

        // parallel_vtk
        //
        typedef ::chaste::parameters::v2017_1::yesno_type parallel_vtk_type;
        typedef ::xsd::cxx::tree::traits< parallel_vtk_type, char > parallel_vtk_traits;

        const parallel_vtk_type&
        parallel_vtk () const;

        parallel_vtk_type&
        parallel_vtk ();

        void
        parallel_vtk (const parallel_vtk_type& x);

        void
        parallel_vtk (::std::unique_ptr< parallel_vtk_type > p);

        static const parallel_vtk_type&
        parallel_vtk_default_value ();

        // precision
        //
        typedef ::xml_schema::non_negative_integer precision_type;
        typedef ::xsd::cxx::tree::traits< precision_type, char > precision_traits;

        const precision_type&
        precision () const;

        precision_type&
        precision ();

        void
        precision (const precision_type& x);

        static precision_type
        precision_default_value ();

        // Constructors.
        //
        output_visualizer_type ();

        output_visualizer_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        output_visualizer_type (const output_visualizer_type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        virtual output_visualizer_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        output_visualizer_type&
        operator= (const output_visualizer_type& x);

        virtual 
        ~output_visualizer_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< meshalyzer_type > meshalyzer_;
        static const meshalyzer_type meshalyzer_default_value_;
        ::xsd::cxx::tree::one< cmgui_type > cmgui_;
        static const cmgui_type cmgui_default_value_;
        ::xsd::cxx::tree::one< vtk_type > vtk_;
        static const vtk_type vtk_default_value_;
        ::xsd::cxx::tree::one< parallel_vtk_type > parallel_vtk_;
        static const parallel_vtk_type parallel_vtk_default_value_;
        ::xsd::cxx::tree::one< precision_type > precision_;
      };

      class time_steps_type: public ::xml_schema::type
      {
        public:
        // ode
        //
        typedef ::xml_schema::double_ ode_type;
        typedef ::xsd::cxx::tree::traits< ode_type, char, ::xsd::cxx::tree::schema_type::double_ > ode_traits;

        const ode_type&
        ode () const;

        ode_type&
        ode ();

        void
        ode (const ode_type& x);

        // pde
        //
        typedef ::xml_schema::double_ pde_type;
        typedef ::xsd::cxx::tree::traits< pde_type, char, ::xsd::cxx::tree::schema_type::double_ > pde_traits;

        const pde_type&
        pde () const;

        pde_type&
        pde ();

        void
        pde (const pde_type& x);

        // printing
        //
        typedef ::xml_schema::double_ printing_type;
        typedef ::xsd::cxx::tree::traits< printing_type, char, ::xsd::cxx::tree::schema_type::double_ > printing_traits;

        const printing_type&
        printing () const;

        printing_type&
        printing ();

        void
        printing (const printing_type& x);

        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        time_steps_type (const ode_type&,
                         const pde_type&,
                         const printing_type&);

        time_steps_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        time_steps_type (const time_steps_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual time_steps_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        time_steps_type&
        operator= (const time_steps_type& x);

        virtual 
        ~time_steps_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< ode_type > ode_;
        ::xsd::cxx::tree::one< pde_type > pde_;
        ::xsd::cxx::tree::one< printing_type > printing_;
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class ksp_tolerances_type: public ::xml_schema::type
      {
        public:
        // KSPRelative
        //
        typedef ::xml_schema::double_ KSPRelative_type;
        typedef ::xsd::cxx::tree::optional< KSPRelative_type > KSPRelative_optional;
        typedef ::xsd::cxx::tree::traits< KSPRelative_type, char, ::xsd::cxx::tree::schema_type::double_ > KSPRelative_traits;

        const KSPRelative_optional&
        KSPRelative () const;

        KSPRelative_optional&
        KSPRelative ();

        void
        KSPRelative (const KSPRelative_type& x);

        void
        KSPRelative (const KSPRelative_optional& x);

        // KSPAbsolute
        //
        typedef ::xml_schema::double_ KSPAbsolute_type;
        typedef ::xsd::cxx::tree::optional< KSPAbsolute_type > KSPAbsolute_optional;
        typedef ::xsd::cxx::tree::traits< KSPAbsolute_type, char, ::xsd::cxx::tree::schema_type::double_ > KSPAbsolute_traits;

        const KSPAbsolute_optional&
        KSPAbsolute () const;

        KSPAbsolute_optional&
        KSPAbsolute ();

        void
        KSPAbsolute (const KSPAbsolute_type& x);

        void
        KSPAbsolute (const KSPAbsolute_optional& x);

        // Constructors.
        //
        ksp_tolerances_type ();

        ksp_tolerances_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        ksp_tolerances_type (const ksp_tolerances_type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        virtual ksp_tolerances_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ksp_tolerances_type&
        operator= (const ksp_tolerances_type& x);

        virtual 
        ~ksp_tolerances_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        KSPRelative_optional KSPRelative_;
        KSPAbsolute_optional KSPAbsolute_;
      };

      class ksp_solver_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          cg,
          symmlq,
          gmres,
          chebychev
        };

        ksp_solver_type (value v);

        ksp_solver_type (const char* v);

        ksp_solver_type (const ::std::string& v);

        ksp_solver_type (const ::xml_schema::string& v);

        ksp_solver_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        ksp_solver_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        ksp_solver_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        ksp_solver_type (const ksp_solver_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual ksp_solver_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ksp_solver_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_ksp_solver_type_convert ();
        }

        protected:
        value
        _xsd_ksp_solver_type_convert () const;

        public:
        static const char* const _xsd_ksp_solver_type_literals_[4];
        static const value _xsd_ksp_solver_type_indexes_[4];
      };

      class ksp_preconditioner_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          jacobi,
          bjacobi,
          hypre,
          ml,
          spai,
          blockdiagonal,
          ldufactorisation,
          twolevelsblockdiagonal,
          none
        };

        ksp_preconditioner_type (value v);

        ksp_preconditioner_type (const char* v);

        ksp_preconditioner_type (const ::std::string& v);

        ksp_preconditioner_type (const ::xml_schema::string& v);

        ksp_preconditioner_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        ksp_preconditioner_type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        ksp_preconditioner_type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        ksp_preconditioner_type (const ksp_preconditioner_type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        virtual ksp_preconditioner_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ksp_preconditioner_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_ksp_preconditioner_type_convert ();
        }

        protected:
        value
        _xsd_ksp_preconditioner_type_convert () const;

        public:
        static const char* const _xsd_ksp_preconditioner_type_literals_[9];
        static const value _xsd_ksp_preconditioner_type_indexes_[9];
      };

      class mesh_partitioning_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          dumb,
          parmetis,
          metis,
          petsc
        };

        mesh_partitioning_type (value v);

        mesh_partitioning_type (const char* v);

        mesh_partitioning_type (const ::std::string& v);

        mesh_partitioning_type (const ::xml_schema::string& v);

        mesh_partitioning_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        mesh_partitioning_type (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        mesh_partitioning_type (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        mesh_partitioning_type (const mesh_partitioning_type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        virtual mesh_partitioning_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        mesh_partitioning_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_mesh_partitioning_type_convert ();
        }

        protected:
        value
        _xsd_mesh_partitioning_type_convert () const;

        public:
        static const char* const _xsd_mesh_partitioning_type_literals_[4];
        static const value _xsd_mesh_partitioning_type_indexes_[4];
      };

      class checkpoint_type: public ::xml_schema::type
      {
        public:
        // timestep
        //
        typedef ::xml_schema::double_ timestep_type;
        typedef ::xsd::cxx::tree::traits< timestep_type, char, ::xsd::cxx::tree::schema_type::double_ > timestep_traits;

        const timestep_type&
        timestep () const;

        timestep_type&
        timestep ();

        void
        timestep (const timestep_type& x);

        // max_checkpoints_on_disk
        //
        typedef ::xml_schema::unsigned_int max_checkpoints_on_disk_type;
        typedef ::xsd::cxx::tree::traits< max_checkpoints_on_disk_type, char > max_checkpoints_on_disk_traits;

        const max_checkpoints_on_disk_type&
        max_checkpoints_on_disk () const;

        max_checkpoints_on_disk_type&
        max_checkpoints_on_disk ();

        void
        max_checkpoints_on_disk (const max_checkpoints_on_disk_type& x);

        // unit
        //
        typedef ::xml_schema::string unit_type;
        typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

        const unit_type&
        unit () const;

        static const unit_type&
        unit_default_value ();

        // Constructors.
        //
        checkpoint_type (const timestep_type&,
                         const max_checkpoints_on_disk_type&);

        checkpoint_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        checkpoint_type (const checkpoint_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual checkpoint_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        checkpoint_type&
        operator= (const checkpoint_type& x);

        virtual 
        ~checkpoint_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< timestep_type > timestep_;
        ::xsd::cxx::tree::one< max_checkpoints_on_disk_type > max_checkpoints_on_disk_;
        ::xsd::cxx::tree::one< unit_type > unit_;
        static const unit_type unit_default_value_;
      };

      class adaptivity_parameters_type: public ::xml_schema::type
      {
        public:
        // target_error
        //
        typedef ::xml_schema::double_ target_error_type;
        typedef ::xsd::cxx::tree::traits< target_error_type, char, ::xsd::cxx::tree::schema_type::double_ > target_error_traits;

        const target_error_type&
        target_error () const;

        target_error_type&
        target_error ();

        void
        target_error (const target_error_type& x);

        // sigma
        //
        typedef ::xml_schema::double_ sigma_type;
        typedef ::xsd::cxx::tree::traits< sigma_type, char, ::xsd::cxx::tree::schema_type::double_ > sigma_traits;

        const sigma_type&
        sigma () const;

        sigma_type&
        sigma ();

        void
        sigma (const sigma_type& x);

        // max_edge_length
        //
        typedef ::xml_schema::double_ max_edge_length_type;
        typedef ::xsd::cxx::tree::traits< max_edge_length_type, char, ::xsd::cxx::tree::schema_type::double_ > max_edge_length_traits;

        const max_edge_length_type&
        max_edge_length () const;

        max_edge_length_type&
        max_edge_length ();

        void
        max_edge_length (const max_edge_length_type& x);

        // min_edge_length
        //
        typedef ::xml_schema::double_ min_edge_length_type;
        typedef ::xsd::cxx::tree::traits< min_edge_length_type, char, ::xsd::cxx::tree::schema_type::double_ > min_edge_length_traits;

        const min_edge_length_type&
        min_edge_length () const;

        min_edge_length_type&
        min_edge_length ();

        void
        min_edge_length (const min_edge_length_type& x);

        // gradation
        //
        typedef ::xml_schema::double_ gradation_type;
        typedef ::xsd::cxx::tree::traits< gradation_type, char, ::xsd::cxx::tree::schema_type::double_ > gradation_traits;

        const gradation_type&
        gradation () const;

        gradation_type&
        gradation ();

        void
        gradation (const gradation_type& x);

        // max_nodes
        //
        typedef ::xml_schema::integer max_nodes_type;
        typedef ::xsd::cxx::tree::traits< max_nodes_type, char > max_nodes_traits;

        const max_nodes_type&
        max_nodes () const;

        max_nodes_type&
        max_nodes ();

        void
        max_nodes (const max_nodes_type& x);

        // num_sweeps
        //
        typedef ::xml_schema::integer num_sweeps_type;
        typedef ::xsd::cxx::tree::traits< num_sweeps_type, char > num_sweeps_traits;

        const num_sweeps_type&
        num_sweeps () const;

        num_sweeps_type&
        num_sweeps ();

        void
        num_sweeps (const num_sweeps_type& x);

        // Constructors.
        //
        adaptivity_parameters_type (const target_error_type&,
                                    const sigma_type&,
                                    const max_edge_length_type&,
                                    const min_edge_length_type&,
                                    const gradation_type&,
                                    const max_nodes_type&,
                                    const num_sweeps_type&);

        adaptivity_parameters_type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        adaptivity_parameters_type (const adaptivity_parameters_type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        virtual adaptivity_parameters_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        adaptivity_parameters_type&
        operator= (const adaptivity_parameters_type& x);

        virtual 
        ~adaptivity_parameters_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< target_error_type > target_error_;
        ::xsd::cxx::tree::one< sigma_type > sigma_;
        ::xsd::cxx::tree::one< max_edge_length_type > max_edge_length_;
        ::xsd::cxx::tree::one< min_edge_length_type > min_edge_length_;
        ::xsd::cxx::tree::one< gradation_type > gradation_;
        ::xsd::cxx::tree::one< max_nodes_type > max_nodes_;
        ::xsd::cxx::tree::one< num_sweeps_type > num_sweeps_;
      };

      class cell_heterogeneities_type: public ::xml_schema::type
      {
        public:
        // CellHeterogeneity
        //
        typedef ::chaste::parameters::v2017_1::cell_heterogeneity_type CellHeterogeneity_type;
        typedef ::xsd::cxx::tree::sequence< CellHeterogeneity_type > CellHeterogeneity_sequence;
        typedef CellHeterogeneity_sequence::iterator CellHeterogeneity_iterator;
        typedef CellHeterogeneity_sequence::const_iterator CellHeterogeneity_const_iterator;
        typedef ::xsd::cxx::tree::traits< CellHeterogeneity_type, char > CellHeterogeneity_traits;

        const CellHeterogeneity_sequence&
        CellHeterogeneity () const;

        CellHeterogeneity_sequence&
        CellHeterogeneity ();

        void
        CellHeterogeneity (const CellHeterogeneity_sequence& s);

        // Constructors.
        //
        cell_heterogeneities_type ();

        cell_heterogeneities_type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

        cell_heterogeneities_type (const cell_heterogeneities_type& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

        virtual cell_heterogeneities_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        cell_heterogeneities_type&
        operator= (const cell_heterogeneities_type& x);

        virtual 
        ~cell_heterogeneities_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        CellHeterogeneity_sequence CellHeterogeneity_;
      };

      class stimuli_type: public ::xml_schema::type
      {
        public:
        // Stimulus
        //
        typedef ::chaste::parameters::v2017_1::stimulus_type Stimulus_type;
        typedef ::xsd::cxx::tree::sequence< Stimulus_type > Stimulus_sequence;
        typedef Stimulus_sequence::iterator Stimulus_iterator;
        typedef Stimulus_sequence::const_iterator Stimulus_const_iterator;
        typedef ::xsd::cxx::tree::traits< Stimulus_type, char > Stimulus_traits;

        const Stimulus_sequence&
        Stimulus () const;

        Stimulus_sequence&
        Stimulus ();

        void
        Stimulus (const Stimulus_sequence& s);

        // Constructors.
        //
        stimuli_type ();

        stimuli_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        stimuli_type (const stimuli_type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual stimuli_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        stimuli_type&
        operator= (const stimuli_type& x);

        virtual 
        ~stimuli_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        Stimulus_sequence Stimulus_;
      };

      class simulation_type: public ::xml_schema::type
      {
        public:
        // SpaceDimension
        //
        typedef ::xml_schema::integer SpaceDimension_type;
        typedef ::xsd::cxx::tree::optional< SpaceDimension_type > SpaceDimension_optional;
        typedef ::xsd::cxx::tree::traits< SpaceDimension_type, char > SpaceDimension_traits;

        const SpaceDimension_optional&
        SpaceDimension () const;

        SpaceDimension_optional&
        SpaceDimension ();

        void
        SpaceDimension (const SpaceDimension_type& x);

        void
        SpaceDimension (const SpaceDimension_optional& x);

        // SimulationDuration
        //
        typedef ::chaste::parameters::v2017_1::time_type SimulationDuration_type;
        typedef ::xsd::cxx::tree::optional< SimulationDuration_type > SimulationDuration_optional;
        typedef ::xsd::cxx::tree::traits< SimulationDuration_type, char > SimulationDuration_traits;

        const SimulationDuration_optional&
        SimulationDuration () const;

        SimulationDuration_optional&
        SimulationDuration ();

        void
        SimulationDuration (const SimulationDuration_type& x);

        void
        SimulationDuration (const SimulationDuration_optional& x);

        void
        SimulationDuration (::std::unique_ptr< SimulationDuration_type > p);

        // Domain
        //
        typedef ::chaste::parameters::v2017_1::domain_type Domain_type;
        typedef ::xsd::cxx::tree::optional< Domain_type > Domain_optional;
        typedef ::xsd::cxx::tree::traits< Domain_type, char > Domain_traits;

        const Domain_optional&
        Domain () const;

        Domain_optional&
        Domain ();

        void
        Domain (const Domain_type& x);

        void
        Domain (const Domain_optional& x);

        void
        Domain (::std::unique_ptr< Domain_type > p);

        // Purkinje
        //
        typedef ::chaste::parameters::v2017_1::purkinje_simulation_type Purkinje_type;
        typedef ::xsd::cxx::tree::optional< Purkinje_type > Purkinje_optional;
        typedef ::xsd::cxx::tree::traits< Purkinje_type, char > Purkinje_traits;

        const Purkinje_optional&
        Purkinje () const;

        Purkinje_optional&
        Purkinje ();

        void
        Purkinje (const Purkinje_type& x);

        void
        Purkinje (const Purkinje_optional& x);

        void
        Purkinje (::std::unique_ptr< Purkinje_type > p);

        // Mesh
        //
        typedef ::chaste::parameters::v2017_1::mesh_type Mesh_type;
        typedef ::xsd::cxx::tree::optional< Mesh_type > Mesh_optional;
        typedef ::xsd::cxx::tree::traits< Mesh_type, char > Mesh_traits;

        const Mesh_optional&
        Mesh () const;

        Mesh_optional&
        Mesh ();

        void
        Mesh (const Mesh_type& x);

        void
        Mesh (const Mesh_optional& x);

        void
        Mesh (::std::unique_ptr< Mesh_type > p);

        // IonicModels
        //
        typedef ::chaste::parameters::v2017_1::ionic_models_type IonicModels_type;
        typedef ::xsd::cxx::tree::optional< IonicModels_type > IonicModels_optional;
        typedef ::xsd::cxx::tree::traits< IonicModels_type, char > IonicModels_traits;

        const IonicModels_optional&
        IonicModels () const;

        IonicModels_optional&
        IonicModels ();

        void
        IonicModels (const IonicModels_type& x);

        void
        IonicModels (const IonicModels_optional& x);

        void
        IonicModels (::std::unique_ptr< IonicModels_type > p);

        // Stimuli
        //
        typedef ::chaste::parameters::v2017_1::stimuli_type Stimuli_type;
        typedef ::xsd::cxx::tree::optional< Stimuli_type > Stimuli_optional;
        typedef ::xsd::cxx::tree::traits< Stimuli_type, char > Stimuli_traits;

        const Stimuli_optional&
        Stimuli () const;

        Stimuli_optional&
        Stimuli ();

        void
        Stimuli (const Stimuli_type& x);

        void
        Stimuli (const Stimuli_optional& x);

        void
        Stimuli (::std::unique_ptr< Stimuli_type > p);

        // Electrodes
        //
        typedef ::chaste::parameters::v2017_1::electrodes_type Electrodes_type;
        typedef ::xsd::cxx::tree::optional< Electrodes_type > Electrodes_optional;
        typedef ::xsd::cxx::tree::traits< Electrodes_type, char > Electrodes_traits;

        const Electrodes_optional&
        Electrodes () const;

        Electrodes_optional&
        Electrodes ();

        void
        Electrodes (const Electrodes_type& x);

        void
        Electrodes (const Electrodes_optional& x);

        void
        Electrodes (::std::unique_ptr< Electrodes_type > p);

        // CellHeterogeneities
        //
        typedef ::chaste::parameters::v2017_1::cell_heterogeneities_type CellHeterogeneities_type;
        typedef ::xsd::cxx::tree::optional< CellHeterogeneities_type > CellHeterogeneities_optional;
        typedef ::xsd::cxx::tree::traits< CellHeterogeneities_type, char > CellHeterogeneities_traits;

        const CellHeterogeneities_optional&
        CellHeterogeneities () const;

        CellHeterogeneities_optional&
        CellHeterogeneities ();

        void
        CellHeterogeneities (const CellHeterogeneities_type& x);

        void
        CellHeterogeneities (const CellHeterogeneities_optional& x);

        void
        CellHeterogeneities (::std::unique_ptr< CellHeterogeneities_type > p);

        // OutputDirectory
        //
        typedef ::xml_schema::string OutputDirectory_type;
        typedef ::xsd::cxx::tree::optional< OutputDirectory_type > OutputDirectory_optional;
        typedef ::xsd::cxx::tree::traits< OutputDirectory_type, char > OutputDirectory_traits;

        const OutputDirectory_optional&
        OutputDirectory () const;

        OutputDirectory_optional&
        OutputDirectory ();

        void
        OutputDirectory (const OutputDirectory_type& x);

        void
        OutputDirectory (const OutputDirectory_optional& x);

        void
        OutputDirectory (::std::unique_ptr< OutputDirectory_type > p);

        // OutputFilenamePrefix
        //
        typedef ::xml_schema::string OutputFilenamePrefix_type;
        typedef ::xsd::cxx::tree::optional< OutputFilenamePrefix_type > OutputFilenamePrefix_optional;
        typedef ::xsd::cxx::tree::traits< OutputFilenamePrefix_type, char > OutputFilenamePrefix_traits;

        const OutputFilenamePrefix_optional&
        OutputFilenamePrefix () const;

        OutputFilenamePrefix_optional&
        OutputFilenamePrefix ();

        void
        OutputFilenamePrefix (const OutputFilenamePrefix_type& x);

        void
        OutputFilenamePrefix (const OutputFilenamePrefix_optional& x);

        void
        OutputFilenamePrefix (::std::unique_ptr< OutputFilenamePrefix_type > p);

        // OutputVariables
        //
        typedef ::chaste::parameters::v2017_1::output_variables_type OutputVariables_type;
        typedef ::xsd::cxx::tree::optional< OutputVariables_type > OutputVariables_optional;
        typedef ::xsd::cxx::tree::traits< OutputVariables_type, char > OutputVariables_traits;

        const OutputVariables_optional&
        OutputVariables () const;

        OutputVariables_optional&
        OutputVariables ();

        void
        OutputVariables (const OutputVariables_type& x);

        void
        OutputVariables (const OutputVariables_optional& x);

        void
        OutputVariables (::std::unique_ptr< OutputVariables_type > p);

        // OutputVisualizer
        //
        typedef ::chaste::parameters::v2017_1::output_visualizer_type OutputVisualizer_type;
        typedef ::xsd::cxx::tree::optional< OutputVisualizer_type > OutputVisualizer_optional;
        typedef ::xsd::cxx::tree::traits< OutputVisualizer_type, char > OutputVisualizer_traits;

        const OutputVisualizer_optional&
        OutputVisualizer () const;

        OutputVisualizer_optional&
        OutputVisualizer ();

        void
        OutputVisualizer (const OutputVisualizer_type& x);

        void
        OutputVisualizer (const OutputVisualizer_optional& x);

        void
        OutputVisualizer (::std::unique_ptr< OutputVisualizer_type > p);

        // OutputUsingOriginalNodeOrdering
        //
        typedef ::chaste::parameters::v2017_1::yesno_type OutputUsingOriginalNodeOrdering_type;
        typedef ::xsd::cxx::tree::optional< OutputUsingOriginalNodeOrdering_type > OutputUsingOriginalNodeOrdering_optional;
        typedef ::xsd::cxx::tree::traits< OutputUsingOriginalNodeOrdering_type, char > OutputUsingOriginalNodeOrdering_traits;

        const OutputUsingOriginalNodeOrdering_optional&
        OutputUsingOriginalNodeOrdering () const;

        OutputUsingOriginalNodeOrdering_optional&
        OutputUsingOriginalNodeOrdering ();

        void
        OutputUsingOriginalNodeOrdering (const OutputUsingOriginalNodeOrdering_type& x);

        void
        OutputUsingOriginalNodeOrdering (const OutputUsingOriginalNodeOrdering_optional& x);

        void
        OutputUsingOriginalNodeOrdering (::std::unique_ptr< OutputUsingOriginalNodeOrdering_type > p);

        static const OutputUsingOriginalNodeOrdering_type&
        OutputUsingOriginalNodeOrdering_default_value ();

        // CheckpointSimulation
        //
        typedef ::chaste::parameters::v2017_1::checkpoint_type CheckpointSimulation_type;
        typedef ::xsd::cxx::tree::optional< CheckpointSimulation_type > CheckpointSimulation_optional;
        typedef ::xsd::cxx::tree::traits< CheckpointSimulation_type, char > CheckpointSimulation_traits;

        const CheckpointSimulation_optional&
        CheckpointSimulation () const;

        CheckpointSimulation_optional&
        CheckpointSimulation ();

        void
        CheckpointSimulation (const CheckpointSimulation_type& x);

        void
        CheckpointSimulation (const CheckpointSimulation_optional& x);

        void
        CheckpointSimulation (::std::unique_ptr< CheckpointSimulation_type > p);

        // Constructors.
        //
        simulation_type ();

        simulation_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        simulation_type (const simulation_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual simulation_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        simulation_type&
        operator= (const simulation_type& x);

        virtual 
        ~simulation_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        SpaceDimension_optional SpaceDimension_;
        SimulationDuration_optional SimulationDuration_;
        Domain_optional Domain_;
        Purkinje_optional Purkinje_;
        Mesh_optional Mesh_;
        IonicModels_optional IonicModels_;
        Stimuli_optional Stimuli_;
        Electrodes_optional Electrodes_;
        CellHeterogeneities_optional CellHeterogeneities_;
        OutputDirectory_optional OutputDirectory_;
        OutputFilenamePrefix_optional OutputFilenamePrefix_;
        OutputVariables_optional OutputVariables_;
        OutputVisualizer_optional OutputVisualizer_;
        OutputUsingOriginalNodeOrdering_optional OutputUsingOriginalNodeOrdering_;
        static const OutputUsingOriginalNodeOrdering_type OutputUsingOriginalNodeOrdering_default_value_;
        CheckpointSimulation_optional CheckpointSimulation_;
      };

      class resume_simulation_type: public ::xml_schema::type
      {
        public:
        // ArchiveDirectory
        //
        typedef ::chaste::parameters::v2017_1::path_type ArchiveDirectory_type;
        typedef ::xsd::cxx::tree::traits< ArchiveDirectory_type, char > ArchiveDirectory_traits;

        const ArchiveDirectory_type&
        ArchiveDirectory () const;

        ArchiveDirectory_type&
        ArchiveDirectory ();

        void
        ArchiveDirectory (const ArchiveDirectory_type& x);

        void
        ArchiveDirectory (::std::unique_ptr< ArchiveDirectory_type > p);

        // SpaceDimension
        //
        typedef ::xml_schema::integer SpaceDimension_type;
        typedef ::xsd::cxx::tree::traits< SpaceDimension_type, char > SpaceDimension_traits;

        const SpaceDimension_type&
        SpaceDimension () const;

        SpaceDimension_type&
        SpaceDimension ();

        void
        SpaceDimension (const SpaceDimension_type& x);

        // Domain
        //
        typedef ::chaste::parameters::v2017_1::domain_type Domain_type;
        typedef ::xsd::cxx::tree::traits< Domain_type, char > Domain_traits;

        const Domain_type&
        Domain () const;

        Domain_type&
        Domain ();

        void
        Domain (const Domain_type& x);

        void
        Domain (::std::unique_ptr< Domain_type > p);

        // SimulationDuration
        //
        typedef ::chaste::parameters::v2017_1::time_type SimulationDuration_type;
        typedef ::xsd::cxx::tree::traits< SimulationDuration_type, char > SimulationDuration_traits;

        const SimulationDuration_type&
        SimulationDuration () const;

        SimulationDuration_type&
        SimulationDuration ();

        void
        SimulationDuration (const SimulationDuration_type& x);

        void
        SimulationDuration (::std::unique_ptr< SimulationDuration_type > p);

        // Stimuli
        //
        typedef ::chaste::parameters::v2017_1::stimuli_type Stimuli_type;
        typedef ::xsd::cxx::tree::optional< Stimuli_type > Stimuli_optional;
        typedef ::xsd::cxx::tree::traits< Stimuli_type, char > Stimuli_traits;

        const Stimuli_optional&
        Stimuli () const;

        Stimuli_optional&
        Stimuli ();

        void
        Stimuli (const Stimuli_type& x);

        void
        Stimuli (const Stimuli_optional& x);

        void
        Stimuli (::std::unique_ptr< Stimuli_type > p);

        // CellHeterogeneities
        //
        typedef ::chaste::parameters::v2017_1::cell_heterogeneities_type CellHeterogeneities_type;
        typedef ::xsd::cxx::tree::optional< CellHeterogeneities_type > CellHeterogeneities_optional;
        typedef ::xsd::cxx::tree::traits< CellHeterogeneities_type, char > CellHeterogeneities_traits;

        const CellHeterogeneities_optional&
        CellHeterogeneities () const;

        CellHeterogeneities_optional&
        CellHeterogeneities ();

        void
        CellHeterogeneities (const CellHeterogeneities_type& x);

        void
        CellHeterogeneities (const CellHeterogeneities_optional& x);

        void
        CellHeterogeneities (::std::unique_ptr< CellHeterogeneities_type > p);

        // CheckpointSimulation
        //
        typedef ::chaste::parameters::v2017_1::checkpoint_type CheckpointSimulation_type;
        typedef ::xsd::cxx::tree::optional< CheckpointSimulation_type > CheckpointSimulation_optional;
        typedef ::xsd::cxx::tree::traits< CheckpointSimulation_type, char > CheckpointSimulation_traits;

        const CheckpointSimulation_optional&
        CheckpointSimulation () const;

        CheckpointSimulation_optional&
        CheckpointSimulation ();

        void
        CheckpointSimulation (const CheckpointSimulation_type& x);

        void
        CheckpointSimulation (const CheckpointSimulation_optional& x);

        void
        CheckpointSimulation (::std::unique_ptr< CheckpointSimulation_type > p);

        // OutputVisualizer
        //
        typedef ::chaste::parameters::v2017_1::output_visualizer_type OutputVisualizer_type;
        typedef ::xsd::cxx::tree::optional< OutputVisualizer_type > OutputVisualizer_optional;
        typedef ::xsd::cxx::tree::traits< OutputVisualizer_type, char > OutputVisualizer_traits;

        const OutputVisualizer_optional&
        OutputVisualizer () const;

        OutputVisualizer_optional&
        OutputVisualizer ();

        void
        OutputVisualizer (const OutputVisualizer_type& x);

        void
        OutputVisualizer (const OutputVisualizer_optional& x);

        void
        OutputVisualizer (::std::unique_ptr< OutputVisualizer_type > p);

        // Constructors.
        //
        resume_simulation_type (const ArchiveDirectory_type&,
                                const SpaceDimension_type&,
                                const Domain_type&,
                                const SimulationDuration_type&);

        resume_simulation_type (::std::unique_ptr< ArchiveDirectory_type >,
                                const SpaceDimension_type&,
                                const Domain_type&,
                                ::std::unique_ptr< SimulationDuration_type >);

        resume_simulation_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        resume_simulation_type (const resume_simulation_type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        virtual resume_simulation_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        resume_simulation_type&
        operator= (const resume_simulation_type& x);

        virtual 
        ~resume_simulation_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< ArchiveDirectory_type > ArchiveDirectory_;
        ::xsd::cxx::tree::one< SpaceDimension_type > SpaceDimension_;
        ::xsd::cxx::tree::one< Domain_type > Domain_;
        ::xsd::cxx::tree::one< SimulationDuration_type > SimulationDuration_;
        Stimuli_optional Stimuli_;
        CellHeterogeneities_optional CellHeterogeneities_;
        CheckpointSimulation_optional CheckpointSimulation_;
        OutputVisualizer_optional OutputVisualizer_;
      };

      class physiological_type: public ::xml_schema::type
      {
        public:
        // IntracellularConductivities
        //
        typedef ::chaste::parameters::v2017_1::conductivities_type IntracellularConductivities_type;
        typedef ::xsd::cxx::tree::optional< IntracellularConductivities_type > IntracellularConductivities_optional;
        typedef ::xsd::cxx::tree::traits< IntracellularConductivities_type, char > IntracellularConductivities_traits;

        const IntracellularConductivities_optional&
        IntracellularConductivities () const;

        IntracellularConductivities_optional&
        IntracellularConductivities ();

        void
        IntracellularConductivities (const IntracellularConductivities_type& x);

        void
        IntracellularConductivities (const IntracellularConductivities_optional& x);

        void
        IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > p);

        // ExtracellularConductivities
        //
        typedef ::chaste::parameters::v2017_1::conductivities_type ExtracellularConductivities_type;
        typedef ::xsd::cxx::tree::optional< ExtracellularConductivities_type > ExtracellularConductivities_optional;
        typedef ::xsd::cxx::tree::traits< ExtracellularConductivities_type, char > ExtracellularConductivities_traits;

        const ExtracellularConductivities_optional&
        ExtracellularConductivities () const;

        ExtracellularConductivities_optional&
        ExtracellularConductivities ();

        void
        ExtracellularConductivities (const ExtracellularConductivities_type& x);

        void
        ExtracellularConductivities (const ExtracellularConductivities_optional& x);

        void
        ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > p);

        // BathConductivity
        //
        typedef ::chaste::parameters::v2017_1::conductivity_type BathConductivity_type;
        typedef ::xsd::cxx::tree::optional< BathConductivity_type > BathConductivity_optional;
        typedef ::xsd::cxx::tree::traits< BathConductivity_type, char > BathConductivity_traits;

        const BathConductivity_optional&
        BathConductivity () const;

        BathConductivity_optional&
        BathConductivity ();

        void
        BathConductivity (const BathConductivity_type& x);

        void
        BathConductivity (const BathConductivity_optional& x);

        void
        BathConductivity (::std::unique_ptr< BathConductivity_type > p);

        // ConductivityHeterogeneities
        //
        typedef ::chaste::parameters::v2017_1::ConductivityHeterogeneities ConductivityHeterogeneities_type;
        typedef ::xsd::cxx::tree::optional< ConductivityHeterogeneities_type > ConductivityHeterogeneities_optional;
        typedef ::xsd::cxx::tree::traits< ConductivityHeterogeneities_type, char > ConductivityHeterogeneities_traits;

        const ConductivityHeterogeneities_optional&
        ConductivityHeterogeneities () const;

        ConductivityHeterogeneities_optional&
        ConductivityHeterogeneities ();

        void
        ConductivityHeterogeneities (const ConductivityHeterogeneities_type& x);

        void
        ConductivityHeterogeneities (const ConductivityHeterogeneities_optional& x);

        void
        ConductivityHeterogeneities (::std::unique_ptr< ConductivityHeterogeneities_type > p);

        // SurfaceAreaToVolumeRatio
        //
        typedef ::chaste::parameters::v2017_1::inverse_length_type SurfaceAreaToVolumeRatio_type;
        typedef ::xsd::cxx::tree::optional< SurfaceAreaToVolumeRatio_type > SurfaceAreaToVolumeRatio_optional;
        typedef ::xsd::cxx::tree::traits< SurfaceAreaToVolumeRatio_type, char > SurfaceAreaToVolumeRatio_traits;

        const SurfaceAreaToVolumeRatio_optional&
        SurfaceAreaToVolumeRatio () const;

        SurfaceAreaToVolumeRatio_optional&
        SurfaceAreaToVolumeRatio ();

        void
        SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_type& x);

        void
        SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_optional& x);

        void
        SurfaceAreaToVolumeRatio (::std::unique_ptr< SurfaceAreaToVolumeRatio_type > p);

        // Capacitance
        //
        typedef ::chaste::parameters::v2017_1::capacitance_type Capacitance_type;
        typedef ::xsd::cxx::tree::optional< Capacitance_type > Capacitance_optional;
        typedef ::xsd::cxx::tree::traits< Capacitance_type, char > Capacitance_traits;

        const Capacitance_optional&
        Capacitance () const;

        Capacitance_optional&
        Capacitance ();

        void
        Capacitance (const Capacitance_type& x);

        void
        Capacitance (const Capacitance_optional& x);

        void
        Capacitance (::std::unique_ptr< Capacitance_type > p);

        // ApplyDrug
        //
        typedef ::chaste::parameters::v2017_1::apply_drug_type ApplyDrug_type;
        typedef ::xsd::cxx::tree::optional< ApplyDrug_type > ApplyDrug_optional;
        typedef ::xsd::cxx::tree::traits< ApplyDrug_type, char > ApplyDrug_traits;

        const ApplyDrug_optional&
        ApplyDrug () const;

        ApplyDrug_optional&
        ApplyDrug ();

        void
        ApplyDrug (const ApplyDrug_type& x);

        void
        ApplyDrug (const ApplyDrug_optional& x);

        void
        ApplyDrug (::std::unique_ptr< ApplyDrug_type > p);

        // Purkinje
        //
        typedef ::chaste::parameters::v2017_1::purkinje_physiological_type Purkinje_type;
        typedef ::xsd::cxx::tree::optional< Purkinje_type > Purkinje_optional;
        typedef ::xsd::cxx::tree::traits< Purkinje_type, char > Purkinje_traits;

        const Purkinje_optional&
        Purkinje () const;

        Purkinje_optional&
        Purkinje ();

        void
        Purkinje (const Purkinje_type& x);

        void
        Purkinje (const Purkinje_optional& x);

        void
        Purkinje (::std::unique_ptr< Purkinje_type > p);

        // Constructors.
        //
        physiological_type ();

        physiological_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        physiological_type (const physiological_type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        virtual physiological_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        physiological_type&
        operator= (const physiological_type& x);

        virtual 
        ~physiological_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        IntracellularConductivities_optional IntracellularConductivities_;
        ExtracellularConductivities_optional ExtracellularConductivities_;
        BathConductivity_optional BathConductivity_;
        ConductivityHeterogeneities_optional ConductivityHeterogeneities_;
        SurfaceAreaToVolumeRatio_optional SurfaceAreaToVolumeRatio_;
        Capacitance_optional Capacitance_;
        ApplyDrug_optional ApplyDrug_;
        Purkinje_optional Purkinje_;
      };

      class numerical_type: public ::xml_schema::type
      {
        public:
        // TimeSteps
        //
        typedef ::chaste::parameters::v2017_1::time_steps_type TimeSteps_type;
        typedef ::xsd::cxx::tree::optional< TimeSteps_type > TimeSteps_optional;
        typedef ::xsd::cxx::tree::traits< TimeSteps_type, char > TimeSteps_traits;

        const TimeSteps_optional&
        TimeSteps () const;

        TimeSteps_optional&
        TimeSteps ();

        void
        TimeSteps (const TimeSteps_type& x);

        void
        TimeSteps (const TimeSteps_optional& x);

        void
        TimeSteps (::std::unique_ptr< TimeSteps_type > p);

        // KSPTolerances
        //
        typedef ::chaste::parameters::v2017_1::ksp_tolerances_type KSPTolerances_type;
        typedef ::xsd::cxx::tree::optional< KSPTolerances_type > KSPTolerances_optional;
        typedef ::xsd::cxx::tree::traits< KSPTolerances_type, char > KSPTolerances_traits;

        const KSPTolerances_optional&
        KSPTolerances () const;

        KSPTolerances_optional&
        KSPTolerances ();

        void
        KSPTolerances (const KSPTolerances_type& x);

        void
        KSPTolerances (const KSPTolerances_optional& x);

        void
        KSPTolerances (::std::unique_ptr< KSPTolerances_type > p);

        // KSPSolver
        //
        typedef ::chaste::parameters::v2017_1::ksp_solver_type KSPSolver_type;
        typedef ::xsd::cxx::tree::optional< KSPSolver_type > KSPSolver_optional;
        typedef ::xsd::cxx::tree::traits< KSPSolver_type, char > KSPSolver_traits;

        const KSPSolver_optional&
        KSPSolver () const;

        KSPSolver_optional&
        KSPSolver ();

        void
        KSPSolver (const KSPSolver_type& x);

        void
        KSPSolver (const KSPSolver_optional& x);

        void
        KSPSolver (::std::unique_ptr< KSPSolver_type > p);

        // KSPPreconditioner
        //
        typedef ::chaste::parameters::v2017_1::ksp_preconditioner_type KSPPreconditioner_type;
        typedef ::xsd::cxx::tree::optional< KSPPreconditioner_type > KSPPreconditioner_optional;
        typedef ::xsd::cxx::tree::traits< KSPPreconditioner_type, char > KSPPreconditioner_traits;

        const KSPPreconditioner_optional&
        KSPPreconditioner () const;

        KSPPreconditioner_optional&
        KSPPreconditioner ();

        void
        KSPPreconditioner (const KSPPreconditioner_type& x);

        void
        KSPPreconditioner (const KSPPreconditioner_optional& x);

        void
        KSPPreconditioner (::std::unique_ptr< KSPPreconditioner_type > p);

        // MeshPartitioning
        //
        typedef ::chaste::parameters::v2017_1::mesh_partitioning_type MeshPartitioning_type;
        typedef ::xsd::cxx::tree::optional< MeshPartitioning_type > MeshPartitioning_optional;
        typedef ::xsd::cxx::tree::traits< MeshPartitioning_type, char > MeshPartitioning_traits;

        const MeshPartitioning_optional&
        MeshPartitioning () const;

        MeshPartitioning_optional&
        MeshPartitioning ();

        void
        MeshPartitioning (const MeshPartitioning_type& x);

        void
        MeshPartitioning (const MeshPartitioning_optional& x);

        void
        MeshPartitioning (::std::unique_ptr< MeshPartitioning_type > p);

        // UseStateVariableInterpolation
        //
        typedef ::chaste::parameters::v2017_1::yesno_type UseStateVariableInterpolation_type;
        typedef ::xsd::cxx::tree::optional< UseStateVariableInterpolation_type > UseStateVariableInterpolation_optional;
        typedef ::xsd::cxx::tree::traits< UseStateVariableInterpolation_type, char > UseStateVariableInterpolation_traits;

        const UseStateVariableInterpolation_optional&
        UseStateVariableInterpolation () const;

        UseStateVariableInterpolation_optional&
        UseStateVariableInterpolation ();

        void
        UseStateVariableInterpolation (const UseStateVariableInterpolation_type& x);

        void
        UseStateVariableInterpolation (const UseStateVariableInterpolation_optional& x);

        void
        UseStateVariableInterpolation (::std::unique_ptr< UseStateVariableInterpolation_type > p);

        // AdaptivityParameters
        //
        typedef ::chaste::parameters::v2017_1::adaptivity_parameters_type AdaptivityParameters_type;
        typedef ::xsd::cxx::tree::optional< AdaptivityParameters_type > AdaptivityParameters_optional;
        typedef ::xsd::cxx::tree::traits< AdaptivityParameters_type, char > AdaptivityParameters_traits;

        const AdaptivityParameters_optional&
        AdaptivityParameters () const;

        AdaptivityParameters_optional&
        AdaptivityParameters ();

        void
        AdaptivityParameters (const AdaptivityParameters_type& x);

        void
        AdaptivityParameters (const AdaptivityParameters_optional& x);

        void
        AdaptivityParameters (::std::unique_ptr< AdaptivityParameters_type > p);

        // Constructors.
        //
        numerical_type ();

        numerical_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        numerical_type (const numerical_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual numerical_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        numerical_type&
        operator= (const numerical_type& x);

        virtual 
        ~numerical_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        TimeSteps_optional TimeSteps_;
        KSPTolerances_optional KSPTolerances_;
        KSPSolver_optional KSPSolver_;
        KSPPreconditioner_optional KSPPreconditioner_;
        MeshPartitioning_optional MeshPartitioning_;
        UseStateVariableInterpolation_optional UseStateVariableInterpolation_;
        AdaptivityParameters_optional AdaptivityParameters_;
      };

      class postprocessing_type: public ::xml_schema::type
      {
        public:
        // ActionPotentialDurationMap
        //
        typedef ::chaste::parameters::v2017_1::apd_map_type ActionPotentialDurationMap_type;
        typedef ::xsd::cxx::tree::sequence< ActionPotentialDurationMap_type > ActionPotentialDurationMap_sequence;
        typedef ActionPotentialDurationMap_sequence::iterator ActionPotentialDurationMap_iterator;
        typedef ActionPotentialDurationMap_sequence::const_iterator ActionPotentialDurationMap_const_iterator;
        typedef ::xsd::cxx::tree::traits< ActionPotentialDurationMap_type, char > ActionPotentialDurationMap_traits;

        const ActionPotentialDurationMap_sequence&
        ActionPotentialDurationMap () const;

        ActionPotentialDurationMap_sequence&
        ActionPotentialDurationMap ();

        void
        ActionPotentialDurationMap (const ActionPotentialDurationMap_sequence& s);

        // UpstrokeTimeMap
        //
        typedef ::chaste::parameters::v2017_1::upstrokes_map_type UpstrokeTimeMap_type;
        typedef ::xsd::cxx::tree::sequence< UpstrokeTimeMap_type > UpstrokeTimeMap_sequence;
        typedef UpstrokeTimeMap_sequence::iterator UpstrokeTimeMap_iterator;
        typedef UpstrokeTimeMap_sequence::const_iterator UpstrokeTimeMap_const_iterator;
        typedef ::xsd::cxx::tree::traits< UpstrokeTimeMap_type, char > UpstrokeTimeMap_traits;

        const UpstrokeTimeMap_sequence&
        UpstrokeTimeMap () const;

        UpstrokeTimeMap_sequence&
        UpstrokeTimeMap ();

        void
        UpstrokeTimeMap (const UpstrokeTimeMap_sequence& s);

        // MaxUpstrokeVelocityMap
        //
        typedef ::chaste::parameters::v2017_1::max_upstrokes_velocity_map_type MaxUpstrokeVelocityMap_type;
        typedef ::xsd::cxx::tree::sequence< MaxUpstrokeVelocityMap_type > MaxUpstrokeVelocityMap_sequence;
        typedef MaxUpstrokeVelocityMap_sequence::iterator MaxUpstrokeVelocityMap_iterator;
        typedef MaxUpstrokeVelocityMap_sequence::const_iterator MaxUpstrokeVelocityMap_const_iterator;
        typedef ::xsd::cxx::tree::traits< MaxUpstrokeVelocityMap_type, char > MaxUpstrokeVelocityMap_traits;

        const MaxUpstrokeVelocityMap_sequence&
        MaxUpstrokeVelocityMap () const;

        MaxUpstrokeVelocityMap_sequence&
        MaxUpstrokeVelocityMap ();

        void
        MaxUpstrokeVelocityMap (const MaxUpstrokeVelocityMap_sequence& s);

        // ConductionVelocityMap
        //
        typedef ::chaste::parameters::v2017_1::conduction_velocity_map_type ConductionVelocityMap_type;
        typedef ::xsd::cxx::tree::sequence< ConductionVelocityMap_type > ConductionVelocityMap_sequence;
        typedef ConductionVelocityMap_sequence::iterator ConductionVelocityMap_iterator;
        typedef ConductionVelocityMap_sequence::const_iterator ConductionVelocityMap_const_iterator;
        typedef ::xsd::cxx::tree::traits< ConductionVelocityMap_type, char > ConductionVelocityMap_traits;

        const ConductionVelocityMap_sequence&
        ConductionVelocityMap () const;

        ConductionVelocityMap_sequence&
        ConductionVelocityMap ();

        void
        ConductionVelocityMap (const ConductionVelocityMap_sequence& s);

        // TimeTraceAtNode
        //
        typedef ::chaste::parameters::v2017_1::node_number_type TimeTraceAtNode_type;
        typedef ::xsd::cxx::tree::sequence< TimeTraceAtNode_type > TimeTraceAtNode_sequence;
        typedef TimeTraceAtNode_sequence::iterator TimeTraceAtNode_iterator;
        typedef TimeTraceAtNode_sequence::const_iterator TimeTraceAtNode_const_iterator;
        typedef ::xsd::cxx::tree::traits< TimeTraceAtNode_type, char > TimeTraceAtNode_traits;

        const TimeTraceAtNode_sequence&
        TimeTraceAtNode () const;

        TimeTraceAtNode_sequence&
        TimeTraceAtNode ();

        void
        TimeTraceAtNode (const TimeTraceAtNode_sequence& s);

        // PseudoEcgElectrodePosition
        //
        typedef ::chaste::parameters::v2017_1::point_type PseudoEcgElectrodePosition_type;
        typedef ::xsd::cxx::tree::sequence< PseudoEcgElectrodePosition_type > PseudoEcgElectrodePosition_sequence;
        typedef PseudoEcgElectrodePosition_sequence::iterator PseudoEcgElectrodePosition_iterator;
        typedef PseudoEcgElectrodePosition_sequence::const_iterator PseudoEcgElectrodePosition_const_iterator;
        typedef ::xsd::cxx::tree::traits< PseudoEcgElectrodePosition_type, char > PseudoEcgElectrodePosition_traits;

        const PseudoEcgElectrodePosition_sequence&
        PseudoEcgElectrodePosition () const;

        PseudoEcgElectrodePosition_sequence&
        PseudoEcgElectrodePosition ();

        void
        PseudoEcgElectrodePosition (const PseudoEcgElectrodePosition_sequence& s);

        // Constructors.
        //
        postprocessing_type ();

        postprocessing_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        postprocessing_type (const postprocessing_type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        virtual postprocessing_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        postprocessing_type&
        operator= (const postprocessing_type& x);

        virtual 
        ~postprocessing_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ActionPotentialDurationMap_sequence ActionPotentialDurationMap_;
        UpstrokeTimeMap_sequence UpstrokeTimeMap_;
        MaxUpstrokeVelocityMap_sequence MaxUpstrokeVelocityMap_;
        ConductionVelocityMap_sequence ConductionVelocityMap_;
        TimeTraceAtNode_sequence TimeTraceAtNode_;
        PseudoEcgElectrodePosition_sequence PseudoEcgElectrodePosition_;
      };

      class chaste_parameters_type: public ::xml_schema::type
      {
        public:
        // Simulation
        //
        typedef ::chaste::parameters::v2017_1::simulation_type Simulation_type;
        typedef ::xsd::cxx::tree::optional< Simulation_type > Simulation_optional;
        typedef ::xsd::cxx::tree::traits< Simulation_type, char > Simulation_traits;

        const Simulation_optional&
        Simulation () const;

        Simulation_optional&
        Simulation ();

        void
        Simulation (const Simulation_type& x);

        void
        Simulation (const Simulation_optional& x);

        void
        Simulation (::std::unique_ptr< Simulation_type > p);

        // ResumeSimulation
        //
        typedef ::chaste::parameters::v2017_1::resume_simulation_type ResumeSimulation_type;
        typedef ::xsd::cxx::tree::optional< ResumeSimulation_type > ResumeSimulation_optional;
        typedef ::xsd::cxx::tree::traits< ResumeSimulation_type, char > ResumeSimulation_traits;

        const ResumeSimulation_optional&
        ResumeSimulation () const;

        ResumeSimulation_optional&
        ResumeSimulation ();

        void
        ResumeSimulation (const ResumeSimulation_type& x);

        void
        ResumeSimulation (const ResumeSimulation_optional& x);

        void
        ResumeSimulation (::std::unique_ptr< ResumeSimulation_type > p);

        // Physiological
        //
        typedef ::chaste::parameters::v2017_1::physiological_type Physiological_type;
        typedef ::xsd::cxx::tree::traits< Physiological_type, char > Physiological_traits;

        const Physiological_type&
        Physiological () const;

        Physiological_type&
        Physiological ();

        void
        Physiological (const Physiological_type& x);

        void
        Physiological (::std::unique_ptr< Physiological_type > p);

        // Numerical
        //
        typedef ::chaste::parameters::v2017_1::numerical_type Numerical_type;
        typedef ::xsd::cxx::tree::traits< Numerical_type, char > Numerical_traits;

        const Numerical_type&
        Numerical () const;

        Numerical_type&
        Numerical ();

        void
        Numerical (const Numerical_type& x);

        void
        Numerical (::std::unique_ptr< Numerical_type > p);

        // PostProcessing
        //
        typedef ::chaste::parameters::v2017_1::postprocessing_type PostProcessing_type;
        typedef ::xsd::cxx::tree::optional< PostProcessing_type > PostProcessing_optional;
        typedef ::xsd::cxx::tree::traits< PostProcessing_type, char > PostProcessing_traits;

        const PostProcessing_optional&
        PostProcessing () const;

        PostProcessing_optional&
        PostProcessing ();

        void
        PostProcessing (const PostProcessing_type& x);

        void
        PostProcessing (const PostProcessing_optional& x);

        void
        PostProcessing (::std::unique_ptr< PostProcessing_type > p);

        // Constructors.
        //
        chaste_parameters_type (const Physiological_type&,
                                const Numerical_type&);

        chaste_parameters_type (::std::unique_ptr< Physiological_type >,
                                ::std::unique_ptr< Numerical_type >);

        chaste_parameters_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        chaste_parameters_type (const chaste_parameters_type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        virtual chaste_parameters_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        chaste_parameters_type&
        operator= (const chaste_parameters_type& x);

        virtual 
        ~chaste_parameters_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        Simulation_optional Simulation_;
        ResumeSimulation_optional ResumeSimulation_;
        ::xsd::cxx::tree::one< Physiological_type > Physiological_;
        ::xsd::cxx::tree::one< Numerical_type > Numerical_;
        PostProcessing_optional PostProcessing_;
      };

      class purkinje_physiological_type: public ::xml_schema::type
      {
        public:
        // SurfaceAreaToVolumeRatio
        //
        typedef ::chaste::parameters::v2017_1::inverse_length_type SurfaceAreaToVolumeRatio_type;
        typedef ::xsd::cxx::tree::optional< SurfaceAreaToVolumeRatio_type > SurfaceAreaToVolumeRatio_optional;
        typedef ::xsd::cxx::tree::traits< SurfaceAreaToVolumeRatio_type, char > SurfaceAreaToVolumeRatio_traits;

        const SurfaceAreaToVolumeRatio_optional&
        SurfaceAreaToVolumeRatio () const;

        SurfaceAreaToVolumeRatio_optional&
        SurfaceAreaToVolumeRatio ();

        void
        SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_type& x);

        void
        SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_optional& x);

        void
        SurfaceAreaToVolumeRatio (::std::unique_ptr< SurfaceAreaToVolumeRatio_type > p);

        // Capacitance
        //
        typedef ::chaste::parameters::v2017_1::capacitance_type Capacitance_type;
        typedef ::xsd::cxx::tree::optional< Capacitance_type > Capacitance_optional;
        typedef ::xsd::cxx::tree::traits< Capacitance_type, char > Capacitance_traits;

        const Capacitance_optional&
        Capacitance () const;

        Capacitance_optional&
        Capacitance ();

        void
        Capacitance (const Capacitance_type& x);

        void
        Capacitance (const Capacitance_optional& x);

        void
        Capacitance (::std::unique_ptr< Capacitance_type > p);

        // Conductivity
        //
        typedef ::chaste::parameters::v2017_1::conductivity_type Conductivity_type;
        typedef ::xsd::cxx::tree::optional< Conductivity_type > Conductivity_optional;
        typedef ::xsd::cxx::tree::traits< Conductivity_type, char > Conductivity_traits;

        const Conductivity_optional&
        Conductivity () const;

        Conductivity_optional&
        Conductivity ();

        void
        Conductivity (const Conductivity_type& x);

        void
        Conductivity (const Conductivity_optional& x);

        void
        Conductivity (::std::unique_ptr< Conductivity_type > p);

        // Constructors.
        //
        purkinje_physiological_type ();

        purkinje_physiological_type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        purkinje_physiological_type (const purkinje_physiological_type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        virtual purkinje_physiological_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        purkinje_physiological_type&
        operator= (const purkinje_physiological_type& x);

        virtual 
        ~purkinje_physiological_type ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        SurfaceAreaToVolumeRatio_optional SurfaceAreaToVolumeRatio_;
        Capacitance_optional Capacitance_;
        Conductivity_optional Conductivity_;
      };

      class purkinje_simulation_type: public ::xml_schema::type
      {
        public:
        // Constructors.
        //
        purkinje_simulation_type ();

        purkinje_simulation_type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

        purkinje_simulation_type (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

        purkinje_simulation_type (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

        purkinje_simulation_type (const purkinje_simulation_type& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

        virtual purkinje_simulation_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        virtual 
        ~purkinje_simulation_type ();
      };

      class ConductivityHeterogeneities: public ::xml_schema::type
      {
        public:
        // ConductivityHeterogeneity
        //
        typedef ::chaste::parameters::v2017_1::conductivity_heterogeneity_type ConductivityHeterogeneity_type;
        typedef ::xsd::cxx::tree::sequence< ConductivityHeterogeneity_type > ConductivityHeterogeneity_sequence;
        typedef ConductivityHeterogeneity_sequence::iterator ConductivityHeterogeneity_iterator;
        typedef ConductivityHeterogeneity_sequence::const_iterator ConductivityHeterogeneity_const_iterator;
        typedef ::xsd::cxx::tree::traits< ConductivityHeterogeneity_type, char > ConductivityHeterogeneity_traits;

        const ConductivityHeterogeneity_sequence&
        ConductivityHeterogeneity () const;

        ConductivityHeterogeneity_sequence&
        ConductivityHeterogeneity ();

        void
        ConductivityHeterogeneity (const ConductivityHeterogeneity_sequence& s);

        // Constructors.
        //
        ConductivityHeterogeneities ();

        ConductivityHeterogeneities (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        ConductivityHeterogeneities (const ConductivityHeterogeneities& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

        virtual ConductivityHeterogeneities*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        ConductivityHeterogeneities&
        operator= (const ConductivityHeterogeneities& x);

        virtual 
        ~ConductivityHeterogeneities ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ConductivityHeterogeneity_sequence ConductivityHeterogeneity_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      // Parse a URI or a local file.
      //

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::std::string& uri,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::std::string& uri,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::std::string& uri,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      // Parse std::istream.
      //

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        const ::std::string& id,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      // Parse xercesc::InputSource.
      //

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xercesc::InputSource& is,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xercesc::InputSource& is,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xercesc::InputSource& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      // Parse xercesc::DOMDocument.
      //

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      void
      operator<< (::xercesc::DOMElement&, const time_type&);

      void
      operator<< (::xercesc::DOMElement&, const dimensionless_type&);

      void
      operator<< (::xercesc::DOMElement&, const conductivity_type&);

      void
      operator<< (::xercesc::DOMElement&, const stimulus_strength_type&);

      void
      operator<< (::xercesc::DOMElement&, const surface_stimulus_strength_type&);

      void
      operator<< (::xercesc::DOMElement&, const inverse_length_type&);

      void
      operator<< (::xercesc::DOMElement&, const capacitance_type&);

      void
      operator<< (::xercesc::DOMElement&, const apply_drug_type&);

      void
      operator<< (::xercesc::DOMElement&, const ic50_type&);

      void
      operator<< (::xercesc::DOMElement&, const location_type&);

      void
      operator<< (::xercesc::DOMElement&, const domain_type&);

      void
      operator<< (::xercesc::DOMAttr&, const domain_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const domain_type&);

      void
      operator<< (::xercesc::DOMElement&, const axis_type&);

      void
      operator<< (::xercesc::DOMAttr&, const axis_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const axis_type&);

      void
      operator<< (::xercesc::DOMElement&, const ionic_models_available_type&);

      void
      operator<< (::xercesc::DOMAttr&, const ionic_models_available_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const ionic_models_available_type&);

      void
      operator<< (::xercesc::DOMElement&, const ionic_model_selection_type&);

      void
      operator<< (::xercesc::DOMElement&, const dynamically_loaded_ionic_model_type&);

      void
      operator<< (::xercesc::DOMElement&, const path_type&);

      void
      operator<< (::xercesc::DOMElement&, const relative_to_type&);

      void
      operator<< (::xercesc::DOMAttr&, const relative_to_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const relative_to_type&);

      void
      operator<< (::xercesc::DOMElement&, const ionic_model_region_type&);

      void
      operator<< (::xercesc::DOMElement&, const ionic_models_type&);

      void
      operator<< (::xercesc::DOMElement&, const apd_map_type&);

      void
      operator<< (::xercesc::DOMElement&, const upstrokes_map_type&);

      void
      operator<< (::xercesc::DOMElement&, const max_upstrokes_velocity_map_type&);

      void
      operator<< (::xercesc::DOMElement&, const conduction_velocity_map_type&);

      void
      operator<< (::xercesc::DOMElement&, const node_number_type&);

      void
      operator<< (::xercesc::DOMElement&, const media_type&);

      void
      operator<< (::xercesc::DOMAttr&, const media_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const media_type&);

      void
      operator<< (::xercesc::DOMElement&, const point_type&);

      void
      operator<< (::xercesc::DOMElement&, const box_type&);

      void
      operator<< (::xercesc::DOMElement&, const ellipsoid_type&);

      void
      operator<< (::xercesc::DOMElement&, const stimulus_type&);

      void
      operator<< (::xercesc::DOMElement&, const set_parameter_type&);

      void
      operator<< (::xercesc::DOMElement&, const electrodes_type&);

      void
      operator<< (::xercesc::DOMElement&, const cell_heterogeneity_type&);

      void
      operator<< (::xercesc::DOMElement&, const conductivity_heterogeneity_type&);

      void
      operator<< (::xercesc::DOMElement&, const slab_type&);

      void
      operator<< (::xercesc::DOMElement&, const sheet_type&);

      void
      operator<< (::xercesc::DOMElement&, const fibre_type&);

      void
      operator<< (::xercesc::DOMElement&, const load_mesh_type&);

      void
      operator<< (::xercesc::DOMElement&, const mesh_type&);

      void
      operator<< (::xercesc::DOMElement&, const conductivities_type&);

      void
      operator<< (::xercesc::DOMElement&, const var_type&);

      void
      operator<< (::xercesc::DOMElement&, const output_variables_type&);

      void
      operator<< (::xercesc::DOMElement&, const yesno_type&);

      void
      operator<< (::xercesc::DOMAttr&, const yesno_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const yesno_type&);

      void
      operator<< (::xercesc::DOMElement&, const output_visualizer_type&);

      void
      operator<< (::xercesc::DOMElement&, const time_steps_type&);

      void
      operator<< (::xercesc::DOMElement&, const ksp_tolerances_type&);

      void
      operator<< (::xercesc::DOMElement&, const ksp_solver_type&);

      void
      operator<< (::xercesc::DOMAttr&, const ksp_solver_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const ksp_solver_type&);

      void
      operator<< (::xercesc::DOMElement&, const ksp_preconditioner_type&);

      void
      operator<< (::xercesc::DOMAttr&, const ksp_preconditioner_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const ksp_preconditioner_type&);

      void
      operator<< (::xercesc::DOMElement&, const mesh_partitioning_type&);

      void
      operator<< (::xercesc::DOMAttr&, const mesh_partitioning_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const mesh_partitioning_type&);

      void
      operator<< (::xercesc::DOMElement&, const checkpoint_type&);

      void
      operator<< (::xercesc::DOMElement&, const adaptivity_parameters_type&);

      void
      operator<< (::xercesc::DOMElement&, const cell_heterogeneities_type&);

      void
      operator<< (::xercesc::DOMElement&, const stimuli_type&);

      void
      operator<< (::xercesc::DOMElement&, const simulation_type&);

      void
      operator<< (::xercesc::DOMElement&, const resume_simulation_type&);

      void
      operator<< (::xercesc::DOMElement&, const physiological_type&);

      void
      operator<< (::xercesc::DOMElement&, const numerical_type&);

      void
      operator<< (::xercesc::DOMElement&, const postprocessing_type&);

      void
      operator<< (::xercesc::DOMElement&, const chaste_parameters_type&);

      // Serialize to std::ostream.
      //

      void
      ChasteParameters (::std::ostream& os,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& x, 
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

      void
      ChasteParameters (::std::ostream& os,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& x, 
                        ::xml_schema::error_handler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

      void
      ChasteParameters (::std::ostream& os,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& x, 
                        ::xercesc::DOMErrorHandler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

      // Serialize to xercesc::XMLFormatTarget.
      //

      void
      ChasteParameters (::xercesc::XMLFormatTarget& ft,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& x, 
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

      void
      ChasteParameters (::xercesc::XMLFormatTarget& ft,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& x, 
                        ::xml_schema::error_handler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

      void
      ChasteParameters (::xercesc::XMLFormatTarget& ft,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& x, 
                        ::xercesc::DOMErrorHandler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

      // Serialize to an existing xercesc::DOMDocument.
      //

      void
      ChasteParameters (::xercesc::DOMDocument& d,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& x,
                        ::xml_schema::flags f = 0);

      // Serialize to a new xercesc::DOMDocument.
      //

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      ChasteParameters (const ::chaste::parameters::v2017_1::chaste_parameters_type& x, 
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        ::xml_schema::flags f = 0);

      void
      operator<< (::xercesc::DOMElement&, const purkinje_physiological_type&);

      void
      operator<< (::xercesc::DOMElement&, const purkinje_simulation_type&);

      void
      operator<< (::xercesc::DOMAttr&, const purkinje_simulation_type&);

      void
      operator<< (::xml_schema::list_stream&,
                  const purkinje_simulation_type&);

      void
      operator<< (::xercesc::DOMElement&, const ConductivityHeterogeneities&);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
// LCOV_EXCL_STOP
//
// End epilogue.

#endif // HEART_SRC_IO_CHASTE_PARAMETERS_2017_1_HPP
