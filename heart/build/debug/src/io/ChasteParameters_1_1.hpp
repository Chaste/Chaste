// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef HEART_SRC_IO_CHASTE_PARAMETERS_1_1_HPP
#define HEART_SRC_IO_CHASTE_PARAMETERS_1_1_HPP

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
// LCOV_EXCL_START
/** @autogenerated */
#include <streambuf>
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace chaste
{
  namespace parameters
  {
    class time_type;
    class dimensionless_type;
    class conductivity_type;
    class stimulus_strength_type;
    class inverse_length_type;
    class capacitance_type;
    class location_type;
    class domain_type;
    class ionic_models_available_type;
    class ionic_model_region_type;
    class ionic_models_type;
    class apd_map_type;
    class upstrokes_map_type;
    class empty_type;
    class conduction_velocity_map_type;
    class media_type;
    class point_type;
    class box_type;
    class stimulus_type;
    class cell_heterogeneity_type;
    class conductivity_heterogeneity_type;
    class slab_type;
    class sheet_type;
    class fibre_type;
    class load_mesh_type;
    class mesh_type;
    class conductivities_type;
    class time_steps_type;
    class ksp_use_type;
    class ksp_tolerances_type;
    class ksp_solver_type;
    class ksp_preconditioner_type;
    class simulation_type;
    class physiological_type;
    class numerical_type;
    class postprocessing_type;
    class chaste_parameters_type;
    class Stimuli;
    class CellHeterogeneities;
    class ConductivityHeterogeneities;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace chaste
{
  namespace parameters
  {
    class time_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      time_type (const ::xml_schema::decimal&);

      time_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      time_type (const time_type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual time_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      time_type&
      operator= (const time_type& x);

      virtual 
      ~time_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class dimensionless_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      dimensionless_type (const ::xml_schema::decimal&);

      dimensionless_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      dimensionless_type (const dimensionless_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual dimensionless_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      dimensionless_type&
      operator= (const dimensionless_type& x);

      virtual 
      ~dimensionless_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class conductivity_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      conductivity_type (const ::xml_schema::decimal&);

      conductivity_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      conductivity_type (const conductivity_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual conductivity_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      conductivity_type&
      operator= (const conductivity_type& x);

      virtual 
      ~conductivity_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class stimulus_strength_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      stimulus_strength_type (const ::xml_schema::decimal&);

      stimulus_strength_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      stimulus_strength_type (const stimulus_strength_type& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual stimulus_strength_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      stimulus_strength_type&
      operator= (const stimulus_strength_type& x);

      virtual 
      ~stimulus_strength_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class inverse_length_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      inverse_length_type (const ::xml_schema::decimal&);

      inverse_length_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      inverse_length_type (const inverse_length_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual inverse_length_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      inverse_length_type&
      operator= (const inverse_length_type& x);

      virtual 
      ~inverse_length_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class capacitance_type: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      capacitance_type (const ::xml_schema::decimal&);

      capacitance_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      capacitance_type (const capacitance_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual capacitance_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      capacitance_type&
      operator= (const capacitance_type& x);

      virtual 
      ~capacitance_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class location_type: public ::xml_schema::type
    {
      public:
      // Cuboid
      //
      typedef ::chaste::parameters::box_type Cuboid_type;
      typedef ::xsd::cxx::tree::traits< Cuboid_type, char > Cuboid_traits;

      const Cuboid_type&
      Cuboid () const;

      Cuboid_type&
      Cuboid ();

      void
      Cuboid (const Cuboid_type& x);

      void
      Cuboid (::std::unique_ptr< Cuboid_type > p);

      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      location_type (const Cuboid_type&);

      location_type (::std::unique_ptr< Cuboid_type >);

      location_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      location_type (const location_type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual location_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      location_type&
      operator= (const location_type& x);

      virtual 
      ~location_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Cuboid_type > Cuboid_;
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class domain_type: public ::xml_schema::string
    {
      public:
      enum value
      {
        Mono,
        Bi
      };

      domain_type (value v);

      domain_type (const char* v);

      domain_type (const ::std::string& v);

      domain_type (const ::xml_schema::string& v);

      domain_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      domain_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      domain_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      domain_type (const domain_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual domain_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      domain_type&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_domain_type_convert ();
      }

      protected:
      value
      _xsd_domain_type_convert () const;

      public:
      static const char* const _xsd_domain_type_literals_[2];
      static const value _xsd_domain_type_indexes_[2];
    };

    class ionic_models_available_type: public ::xml_schema::string
    {
      public:
      enum value
      {
        Fox2002BackwardEuler,
        LuoRudyIBackwardEuler,
        LuoRudyI,
        FaberRudy2000Optimised,
        FaberRudy2000,
        DifrancescoNoble,
        MahajanShiferaw,
        HodgkinHuxley,
        tenTusscher2006
      };

      ionic_models_available_type (value v);

      ionic_models_available_type (const char* v);

      ionic_models_available_type (const ::std::string& v);

      ionic_models_available_type (const ::xml_schema::string& v);

      ionic_models_available_type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ionic_models_available_type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ionic_models_available_type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ionic_models_available_type (const ionic_models_available_type& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ionic_models_available_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ionic_models_available_type&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ionic_models_available_type_convert ();
      }

      protected:
      value
      _xsd_ionic_models_available_type_convert () const;

      public:
      static const char* const _xsd_ionic_models_available_type_literals_[9];
      static const value _xsd_ionic_models_available_type_indexes_[9];
    };

    class ionic_model_region_type: public ::xml_schema::type
    {
      public:
      // IonicModel
      //
      typedef ::chaste::parameters::ionic_models_available_type IonicModel_type;
      typedef ::xsd::cxx::tree::traits< IonicModel_type, char > IonicModel_traits;

      const IonicModel_type&
      IonicModel () const;

      IonicModel_type&
      IonicModel ();

      void
      IonicModel (const IonicModel_type& x);

      void
      IonicModel (::std::unique_ptr< IonicModel_type > p);

      // Location
      //
      typedef ::chaste::parameters::location_type Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Constructors.
      //
      ionic_model_region_type (const IonicModel_type&,
                               const Location_type&);

      ionic_model_region_type (const IonicModel_type&,
                               ::std::unique_ptr< Location_type >);

      ionic_model_region_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ionic_model_region_type (const ionic_model_region_type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ionic_model_region_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ionic_model_region_type&
      operator= (const ionic_model_region_type& x);

      virtual 
      ~ionic_model_region_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< IonicModel_type > IonicModel_;
      ::xsd::cxx::tree::one< Location_type > Location_;
    };

    class ionic_models_type: public ::xml_schema::type
    {
      public:
      // Default
      //
      typedef ::chaste::parameters::ionic_models_available_type Default_type;
      typedef ::xsd::cxx::tree::traits< Default_type, char > Default_traits;

      const Default_type&
      Default () const;

      Default_type&
      Default ();

      void
      Default (const Default_type& x);

      void
      Default (::std::unique_ptr< Default_type > p);

      // Region
      //
      typedef ::chaste::parameters::ionic_model_region_type Region_type;
      typedef ::xsd::cxx::tree::sequence< Region_type > Region_sequence;
      typedef Region_sequence::iterator Region_iterator;
      typedef Region_sequence::const_iterator Region_const_iterator;
      typedef ::xsd::cxx::tree::traits< Region_type, char > Region_traits;

      const Region_sequence&
      Region () const;

      Region_sequence&
      Region ();

      void
      Region (const Region_sequence& s);

      // Constructors.
      //
      ionic_models_type (const Default_type&);

      ionic_models_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ionic_models_type (const ionic_models_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ionic_models_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ionic_models_type&
      operator= (const ionic_models_type& x);

      virtual 
      ~ionic_models_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Default_type > Default_;
      Region_sequence Region_;
    };

    class apd_map_type: public ::xml_schema::type
    {
      public:
      // repolarisation_percentage
      //
      typedef ::xml_schema::double_ repolarisation_percentage_type;
      typedef ::xsd::cxx::tree::traits< repolarisation_percentage_type, char, ::xsd::cxx::tree::schema_type::double_ > repolarisation_percentage_traits;

      const repolarisation_percentage_type&
      repolarisation_percentage () const;

      repolarisation_percentage_type&
      repolarisation_percentage ();

      void
      repolarisation_percentage (const repolarisation_percentage_type& x);

      // threshold
      //
      typedef ::xml_schema::double_ threshold_type;
      typedef ::xsd::cxx::tree::traits< threshold_type, char, ::xsd::cxx::tree::schema_type::double_ > threshold_traits;

      const threshold_type&
      threshold () const;

      threshold_type&
      threshold ();

      void
      threshold (const threshold_type& x);

      // threshold_unit
      //
      typedef ::xml_schema::string threshold_unit_type;
      typedef ::xsd::cxx::tree::traits< threshold_unit_type, char > threshold_unit_traits;

      const threshold_unit_type&
      threshold_unit () const;

      static const threshold_unit_type&
      threshold_unit_default_value ();

      // Constructors.
      //
      apd_map_type (const repolarisation_percentage_type&,
                    const threshold_type&);

      apd_map_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      apd_map_type (const apd_map_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual apd_map_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      apd_map_type&
      operator= (const apd_map_type& x);

      virtual 
      ~apd_map_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< repolarisation_percentage_type > repolarisation_percentage_;
      ::xsd::cxx::tree::one< threshold_type > threshold_;
      ::xsd::cxx::tree::one< threshold_unit_type > threshold_unit_;
      static const threshold_unit_type threshold_unit_default_value_;
    };

    class upstrokes_map_type: public ::xml_schema::type
    {
      public:
      // threshold
      //
      typedef ::xml_schema::double_ threshold_type;
      typedef ::xsd::cxx::tree::traits< threshold_type, char, ::xsd::cxx::tree::schema_type::double_ > threshold_traits;

      const threshold_type&
      threshold () const;

      threshold_type&
      threshold ();

      void
      threshold (const threshold_type& x);

      // threshold_unit
      //
      typedef ::xml_schema::string threshold_unit_type;
      typedef ::xsd::cxx::tree::traits< threshold_unit_type, char > threshold_unit_traits;

      const threshold_unit_type&
      threshold_unit () const;

      static const threshold_unit_type&
      threshold_unit_default_value ();

      // Constructors.
      //
      upstrokes_map_type (const threshold_type&);

      upstrokes_map_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      upstrokes_map_type (const upstrokes_map_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual upstrokes_map_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      upstrokes_map_type&
      operator= (const upstrokes_map_type& x);

      virtual 
      ~upstrokes_map_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< threshold_type > threshold_;
      ::xsd::cxx::tree::one< threshold_unit_type > threshold_unit_;
      static const threshold_unit_type threshold_unit_default_value_;
    };

    class empty_type: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      empty_type ();

      empty_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      empty_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      empty_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      empty_type (const empty_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual empty_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~empty_type ();
    };

    class conduction_velocity_map_type: public ::xml_schema::type
    {
      public:
      // origin_node
      //
      typedef ::xml_schema::non_negative_integer origin_node_type;
      typedef ::xsd::cxx::tree::traits< origin_node_type, char > origin_node_traits;

      const origin_node_type&
      origin_node () const;

      origin_node_type&
      origin_node ();

      void
      origin_node (const origin_node_type& x);

      // Constructors.
      //
      conduction_velocity_map_type (const origin_node_type&);

      conduction_velocity_map_type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      conduction_velocity_map_type (const conduction_velocity_map_type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual conduction_velocity_map_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      conduction_velocity_map_type&
      operator= (const conduction_velocity_map_type& x);

      virtual 
      ~conduction_velocity_map_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< origin_node_type > origin_node_;
    };

    class media_type: public ::xml_schema::string
    {
      public:
      enum value
      {
        Orthotropic,
        Axisymmetric,
        NoFibreOrientation
      };

      media_type (value v);

      media_type (const char* v);

      media_type (const ::std::string& v);

      media_type (const ::xml_schema::string& v);

      media_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      media_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      media_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      media_type (const media_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual media_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      media_type&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_media_type_convert ();
      }

      protected:
      value
      _xsd_media_type_convert () const;

      public:
      static const char* const _xsd_media_type_literals_[3];
      static const value _xsd_media_type_indexes_[3];
    };

    class point_type: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::double_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::double_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::double_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // Constructors.
      //
      point_type (const x_type&,
                  const y_type&,
                  const z_type&);

      point_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      point_type (const point_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual point_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      point_type&
      operator= (const point_type& x);

      virtual 
      ~point_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
    };

    class box_type: public ::xml_schema::type
    {
      public:
      // LowerCoordinates
      //
      typedef ::chaste::parameters::point_type LowerCoordinates_type;
      typedef ::xsd::cxx::tree::traits< LowerCoordinates_type, char > LowerCoordinates_traits;

      const LowerCoordinates_type&
      LowerCoordinates () const;

      LowerCoordinates_type&
      LowerCoordinates ();

      void
      LowerCoordinates (const LowerCoordinates_type& x);

      void
      LowerCoordinates (::std::unique_ptr< LowerCoordinates_type > p);

      // UpperCoordinates
      //
      typedef ::chaste::parameters::point_type UpperCoordinates_type;
      typedef ::xsd::cxx::tree::traits< UpperCoordinates_type, char > UpperCoordinates_traits;

      const UpperCoordinates_type&
      UpperCoordinates () const;

      UpperCoordinates_type&
      UpperCoordinates ();

      void
      UpperCoordinates (const UpperCoordinates_type& x);

      void
      UpperCoordinates (::std::unique_ptr< UpperCoordinates_type > p);

      // Constructors.
      //
      box_type (const LowerCoordinates_type&,
                const UpperCoordinates_type&);

      box_type (::std::unique_ptr< LowerCoordinates_type >,
                ::std::unique_ptr< UpperCoordinates_type >);

      box_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      box_type (const box_type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual box_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      box_type&
      operator= (const box_type& x);

      virtual 
      ~box_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LowerCoordinates_type > LowerCoordinates_;
      ::xsd::cxx::tree::one< UpperCoordinates_type > UpperCoordinates_;
    };

    class stimulus_type: public ::xml_schema::type
    {
      public:
      // Strength
      //
      typedef ::chaste::parameters::stimulus_strength_type Strength_type;
      typedef ::xsd::cxx::tree::traits< Strength_type, char > Strength_traits;

      const Strength_type&
      Strength () const;

      Strength_type&
      Strength ();

      void
      Strength (const Strength_type& x);

      void
      Strength (::std::unique_ptr< Strength_type > p);

      // Duration
      //
      typedef ::chaste::parameters::time_type Duration_type;
      typedef ::xsd::cxx::tree::traits< Duration_type, char > Duration_traits;

      const Duration_type&
      Duration () const;

      Duration_type&
      Duration ();

      void
      Duration (const Duration_type& x);

      void
      Duration (::std::unique_ptr< Duration_type > p);

      // Delay
      //
      typedef ::chaste::parameters::time_type Delay_type;
      typedef ::xsd::cxx::tree::traits< Delay_type, char > Delay_traits;

      const Delay_type&
      Delay () const;

      Delay_type&
      Delay ();

      void
      Delay (const Delay_type& x);

      void
      Delay (::std::unique_ptr< Delay_type > p);

      // Location
      //
      typedef ::chaste::parameters::location_type Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Constructors.
      //
      stimulus_type (const Strength_type&,
                     const Duration_type&,
                     const Delay_type&,
                     const Location_type&);

      stimulus_type (::std::unique_ptr< Strength_type >,
                     ::std::unique_ptr< Duration_type >,
                     ::std::unique_ptr< Delay_type >,
                     ::std::unique_ptr< Location_type >);

      stimulus_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      stimulus_type (const stimulus_type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual stimulus_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      stimulus_type&
      operator= (const stimulus_type& x);

      virtual 
      ~stimulus_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Strength_type > Strength_;
      ::xsd::cxx::tree::one< Duration_type > Duration_;
      ::xsd::cxx::tree::one< Delay_type > Delay_;
      ::xsd::cxx::tree::one< Location_type > Location_;
    };

    class cell_heterogeneity_type: public ::xml_schema::type
    {
      public:
      // ScaleFactorGks
      //
      typedef ::chaste::parameters::dimensionless_type ScaleFactorGks_type;
      typedef ::xsd::cxx::tree::traits< ScaleFactorGks_type, char > ScaleFactorGks_traits;

      const ScaleFactorGks_type&
      ScaleFactorGks () const;

      ScaleFactorGks_type&
      ScaleFactorGks ();

      void
      ScaleFactorGks (const ScaleFactorGks_type& x);

      void
      ScaleFactorGks (::std::unique_ptr< ScaleFactorGks_type > p);

      // ScaleFactorIto
      //
      typedef ::chaste::parameters::dimensionless_type ScaleFactorIto_type;
      typedef ::xsd::cxx::tree::traits< ScaleFactorIto_type, char > ScaleFactorIto_traits;

      const ScaleFactorIto_type&
      ScaleFactorIto () const;

      ScaleFactorIto_type&
      ScaleFactorIto ();

      void
      ScaleFactorIto (const ScaleFactorIto_type& x);

      void
      ScaleFactorIto (::std::unique_ptr< ScaleFactorIto_type > p);

      // ScaleFactorGkr
      //
      typedef ::chaste::parameters::dimensionless_type ScaleFactorGkr_type;
      typedef ::xsd::cxx::tree::traits< ScaleFactorGkr_type, char > ScaleFactorGkr_traits;

      const ScaleFactorGkr_type&
      ScaleFactorGkr () const;

      ScaleFactorGkr_type&
      ScaleFactorGkr ();

      void
      ScaleFactorGkr (const ScaleFactorGkr_type& x);

      void
      ScaleFactorGkr (::std::unique_ptr< ScaleFactorGkr_type > p);

      // Location
      //
      typedef ::chaste::parameters::location_type Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Constructors.
      //
      cell_heterogeneity_type (const ScaleFactorGks_type&,
                               const ScaleFactorIto_type&,
                               const ScaleFactorGkr_type&,
                               const Location_type&);

      cell_heterogeneity_type (::std::unique_ptr< ScaleFactorGks_type >,
                               ::std::unique_ptr< ScaleFactorIto_type >,
                               ::std::unique_ptr< ScaleFactorGkr_type >,
                               ::std::unique_ptr< Location_type >);

      cell_heterogeneity_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      cell_heterogeneity_type (const cell_heterogeneity_type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual cell_heterogeneity_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      cell_heterogeneity_type&
      operator= (const cell_heterogeneity_type& x);

      virtual 
      ~cell_heterogeneity_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ScaleFactorGks_type > ScaleFactorGks_;
      ::xsd::cxx::tree::one< ScaleFactorIto_type > ScaleFactorIto_;
      ::xsd::cxx::tree::one< ScaleFactorGkr_type > ScaleFactorGkr_;
      ::xsd::cxx::tree::one< Location_type > Location_;
    };

    class conductivity_heterogeneity_type: public ::xml_schema::type
    {
      public:
      // IntracellularConductivities
      //
      typedef ::chaste::parameters::conductivities_type IntracellularConductivities_type;
      typedef ::xsd::cxx::tree::optional< IntracellularConductivities_type > IntracellularConductivities_optional;
      typedef ::xsd::cxx::tree::traits< IntracellularConductivities_type, char > IntracellularConductivities_traits;

      const IntracellularConductivities_optional&
      IntracellularConductivities () const;

      IntracellularConductivities_optional&
      IntracellularConductivities ();

      void
      IntracellularConductivities (const IntracellularConductivities_type& x);

      void
      IntracellularConductivities (const IntracellularConductivities_optional& x);

      void
      IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > p);

      // ExtracellularConductivities
      //
      typedef ::chaste::parameters::conductivities_type ExtracellularConductivities_type;
      typedef ::xsd::cxx::tree::optional< ExtracellularConductivities_type > ExtracellularConductivities_optional;
      typedef ::xsd::cxx::tree::traits< ExtracellularConductivities_type, char > ExtracellularConductivities_traits;

      const ExtracellularConductivities_optional&
      ExtracellularConductivities () const;

      ExtracellularConductivities_optional&
      ExtracellularConductivities ();

      void
      ExtracellularConductivities (const ExtracellularConductivities_type& x);

      void
      ExtracellularConductivities (const ExtracellularConductivities_optional& x);

      void
      ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > p);

      // Location
      //
      typedef ::chaste::parameters::location_type Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Constructors.
      //
      conductivity_heterogeneity_type (const Location_type&);

      conductivity_heterogeneity_type (::std::unique_ptr< Location_type >);

      conductivity_heterogeneity_type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      conductivity_heterogeneity_type (const conductivity_heterogeneity_type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual conductivity_heterogeneity_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      conductivity_heterogeneity_type&
      operator= (const conductivity_heterogeneity_type& x);

      virtual 
      ~conductivity_heterogeneity_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      IntracellularConductivities_optional IntracellularConductivities_;
      ExtracellularConductivities_optional ExtracellularConductivities_;
      ::xsd::cxx::tree::one< Location_type > Location_;
    };

    class slab_type: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::double_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::double_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::double_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // inter_node_space
      //
      typedef ::xml_schema::double_ inter_node_space_type;
      typedef ::xsd::cxx::tree::traits< inter_node_space_type, char, ::xsd::cxx::tree::schema_type::double_ > inter_node_space_traits;

      const inter_node_space_type&
      inter_node_space () const;

      inter_node_space_type&
      inter_node_space ();

      void
      inter_node_space (const inter_node_space_type& x);

      // Constructors.
      //
      slab_type (const x_type&,
                 const y_type&,
                 const z_type&,
                 const inter_node_space_type&);

      slab_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      slab_type (const slab_type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual slab_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      slab_type&
      operator= (const slab_type& x);

      virtual 
      ~slab_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
      ::xsd::cxx::tree::one< inter_node_space_type > inter_node_space_;
    };

    class sheet_type: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::double_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::double_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // inter_node_space
      //
      typedef ::xml_schema::double_ inter_node_space_type;
      typedef ::xsd::cxx::tree::traits< inter_node_space_type, char, ::xsd::cxx::tree::schema_type::double_ > inter_node_space_traits;

      const inter_node_space_type&
      inter_node_space () const;

      inter_node_space_type&
      inter_node_space ();

      void
      inter_node_space (const inter_node_space_type& x);

      // Constructors.
      //
      sheet_type (const x_type&,
                  const y_type&,
                  const inter_node_space_type&);

      sheet_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      sheet_type (const sheet_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual sheet_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      sheet_type&
      operator= (const sheet_type& x);

      virtual 
      ~sheet_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< inter_node_space_type > inter_node_space_;
    };

    class fibre_type: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::double_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // inter_node_space
      //
      typedef ::xml_schema::double_ inter_node_space_type;
      typedef ::xsd::cxx::tree::traits< inter_node_space_type, char, ::xsd::cxx::tree::schema_type::double_ > inter_node_space_traits;

      const inter_node_space_type&
      inter_node_space () const;

      inter_node_space_type&
      inter_node_space ();

      void
      inter_node_space (const inter_node_space_type& x);

      // Constructors.
      //
      fibre_type (const x_type&,
                  const inter_node_space_type&);

      fibre_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      fibre_type (const fibre_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual fibre_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      fibre_type&
      operator= (const fibre_type& x);

      virtual 
      ~fibre_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< inter_node_space_type > inter_node_space_;
    };

    class load_mesh_type: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // conductivity_media
      //
      typedef ::chaste::parameters::media_type conductivity_media_type;
      typedef ::xsd::cxx::tree::traits< conductivity_media_type, char > conductivity_media_traits;

      const conductivity_media_type&
      conductivity_media () const;

      conductivity_media_type&
      conductivity_media ();

      void
      conductivity_media (const conductivity_media_type& x);

      void
      conductivity_media (::std::unique_ptr< conductivity_media_type > p);

      // Constructors.
      //
      load_mesh_type (const name_type&,
                      const conductivity_media_type&);

      load_mesh_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      load_mesh_type (const load_mesh_type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual load_mesh_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      load_mesh_type&
      operator= (const load_mesh_type& x);

      virtual 
      ~load_mesh_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< conductivity_media_type > conductivity_media_;
    };

    class mesh_type: public ::xml_schema::type
    {
      public:
      // Slab
      //
      typedef ::chaste::parameters::slab_type Slab_type;
      typedef ::xsd::cxx::tree::optional< Slab_type > Slab_optional;
      typedef ::xsd::cxx::tree::traits< Slab_type, char > Slab_traits;

      const Slab_optional&
      Slab () const;

      Slab_optional&
      Slab ();

      void
      Slab (const Slab_type& x);

      void
      Slab (const Slab_optional& x);

      void
      Slab (::std::unique_ptr< Slab_type > p);

      // Sheet
      //
      typedef ::chaste::parameters::sheet_type Sheet_type;
      typedef ::xsd::cxx::tree::optional< Sheet_type > Sheet_optional;
      typedef ::xsd::cxx::tree::traits< Sheet_type, char > Sheet_traits;

      const Sheet_optional&
      Sheet () const;

      Sheet_optional&
      Sheet ();

      void
      Sheet (const Sheet_type& x);

      void
      Sheet (const Sheet_optional& x);

      void
      Sheet (::std::unique_ptr< Sheet_type > p);

      // Fibre
      //
      typedef ::chaste::parameters::fibre_type Fibre_type;
      typedef ::xsd::cxx::tree::optional< Fibre_type > Fibre_optional;
      typedef ::xsd::cxx::tree::traits< Fibre_type, char > Fibre_traits;

      const Fibre_optional&
      Fibre () const;

      Fibre_optional&
      Fibre ();

      void
      Fibre (const Fibre_type& x);

      void
      Fibre (const Fibre_optional& x);

      void
      Fibre (::std::unique_ptr< Fibre_type > p);

      // LoadMesh
      //
      typedef ::chaste::parameters::load_mesh_type LoadMesh_type;
      typedef ::xsd::cxx::tree::optional< LoadMesh_type > LoadMesh_optional;
      typedef ::xsd::cxx::tree::traits< LoadMesh_type, char > LoadMesh_traits;

      const LoadMesh_optional&
      LoadMesh () const;

      LoadMesh_optional&
      LoadMesh ();

      void
      LoadMesh (const LoadMesh_type& x);

      void
      LoadMesh (const LoadMesh_optional& x);

      void
      LoadMesh (::std::unique_ptr< LoadMesh_type > p);

      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      mesh_type ();

      mesh_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      mesh_type (const mesh_type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual mesh_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      mesh_type&
      operator= (const mesh_type& x);

      virtual 
      ~mesh_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Slab_optional Slab_;
      Sheet_optional Sheet_;
      Fibre_optional Fibre_;
      LoadMesh_optional LoadMesh_;
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class conductivities_type: public ::xml_schema::type
    {
      public:
      // longi
      //
      typedef ::xml_schema::double_ longi_type;
      typedef ::xsd::cxx::tree::traits< longi_type, char, ::xsd::cxx::tree::schema_type::double_ > longi_traits;

      const longi_type&
      longi () const;

      longi_type&
      longi ();

      void
      longi (const longi_type& x);

      // trans
      //
      typedef ::xml_schema::double_ trans_type;
      typedef ::xsd::cxx::tree::traits< trans_type, char, ::xsd::cxx::tree::schema_type::double_ > trans_traits;

      const trans_type&
      trans () const;

      trans_type&
      trans ();

      void
      trans (const trans_type& x);

      // normal
      //
      typedef ::xml_schema::double_ normal_type;
      typedef ::xsd::cxx::tree::traits< normal_type, char, ::xsd::cxx::tree::schema_type::double_ > normal_traits;

      const normal_type&
      normal () const;

      normal_type&
      normal ();

      void
      normal (const normal_type& x);

      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      conductivities_type (const longi_type&,
                           const trans_type&,
                           const normal_type&);

      conductivities_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      conductivities_type (const conductivities_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual conductivities_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      conductivities_type&
      operator= (const conductivities_type& x);

      virtual 
      ~conductivities_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< longi_type > longi_;
      ::xsd::cxx::tree::one< trans_type > trans_;
      ::xsd::cxx::tree::one< normal_type > normal_;
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class time_steps_type: public ::xml_schema::type
    {
      public:
      // ode
      //
      typedef ::xml_schema::double_ ode_type;
      typedef ::xsd::cxx::tree::traits< ode_type, char, ::xsd::cxx::tree::schema_type::double_ > ode_traits;

      const ode_type&
      ode () const;

      ode_type&
      ode ();

      void
      ode (const ode_type& x);

      // pde
      //
      typedef ::xml_schema::double_ pde_type;
      typedef ::xsd::cxx::tree::traits< pde_type, char, ::xsd::cxx::tree::schema_type::double_ > pde_traits;

      const pde_type&
      pde () const;

      pde_type&
      pde ();

      void
      pde (const pde_type& x);

      // printing
      //
      typedef ::xml_schema::double_ printing_type;
      typedef ::xsd::cxx::tree::traits< printing_type, char, ::xsd::cxx::tree::schema_type::double_ > printing_traits;

      const printing_type&
      printing () const;

      printing_type&
      printing ();

      void
      printing (const printing_type& x);

      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_type&
      unit () const;

      static const unit_type&
      unit_default_value ();

      // Constructors.
      //
      time_steps_type (const ode_type&,
                       const pde_type&,
                       const printing_type&);

      time_steps_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      time_steps_type (const time_steps_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual time_steps_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      time_steps_type&
      operator= (const time_steps_type& x);

      virtual 
      ~time_steps_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ode_type > ode_;
      ::xsd::cxx::tree::one< pde_type > pde_;
      ::xsd::cxx::tree::one< printing_type > printing_;
      ::xsd::cxx::tree::one< unit_type > unit_;
      static const unit_type unit_default_value_;
    };

    class ksp_use_type: public ::xml_schema::string
    {
      public:
      enum value
      {
        relative,
        absolute
      };

      ksp_use_type (value v);

      ksp_use_type (const char* v);

      ksp_use_type (const ::std::string& v);

      ksp_use_type (const ::xml_schema::string& v);

      ksp_use_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ksp_use_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ksp_use_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ksp_use_type (const ksp_use_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ksp_use_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ksp_use_type&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ksp_use_type_convert ();
      }

      protected:
      value
      _xsd_ksp_use_type_convert () const;

      public:
      static const char* const _xsd_ksp_use_type_literals_[2];
      static const value _xsd_ksp_use_type_indexes_[2];
    };

    class ksp_tolerances_type: public ::xml_schema::type
    {
      public:
      // KSPRelative
      //
      typedef ::xml_schema::double_ KSPRelative_type;
      typedef ::xsd::cxx::tree::optional< KSPRelative_type > KSPRelative_optional;
      typedef ::xsd::cxx::tree::traits< KSPRelative_type, char, ::xsd::cxx::tree::schema_type::double_ > KSPRelative_traits;

      const KSPRelative_optional&
      KSPRelative () const;

      KSPRelative_optional&
      KSPRelative ();

      void
      KSPRelative (const KSPRelative_type& x);

      void
      KSPRelative (const KSPRelative_optional& x);

      // KSPAbsolute
      //
      typedef ::xml_schema::double_ KSPAbsolute_type;
      typedef ::xsd::cxx::tree::optional< KSPAbsolute_type > KSPAbsolute_optional;
      typedef ::xsd::cxx::tree::traits< KSPAbsolute_type, char, ::xsd::cxx::tree::schema_type::double_ > KSPAbsolute_traits;

      const KSPAbsolute_optional&
      KSPAbsolute () const;

      KSPAbsolute_optional&
      KSPAbsolute ();

      void
      KSPAbsolute (const KSPAbsolute_type& x);

      void
      KSPAbsolute (const KSPAbsolute_optional& x);

      // Constructors.
      //
      ksp_tolerances_type ();

      ksp_tolerances_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ksp_tolerances_type (const ksp_tolerances_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ksp_tolerances_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ksp_tolerances_type&
      operator= (const ksp_tolerances_type& x);

      virtual 
      ~ksp_tolerances_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      KSPRelative_optional KSPRelative_;
      KSPAbsolute_optional KSPAbsolute_;
    };

    class ksp_solver_type: public ::xml_schema::string
    {
      public:
      enum value
      {
        cg,
        symmlq,
        gmres
      };

      ksp_solver_type (value v);

      ksp_solver_type (const char* v);

      ksp_solver_type (const ::std::string& v);

      ksp_solver_type (const ::xml_schema::string& v);

      ksp_solver_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ksp_solver_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ksp_solver_type (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ksp_solver_type (const ksp_solver_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ksp_solver_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ksp_solver_type&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ksp_solver_type_convert ();
      }

      protected:
      value
      _xsd_ksp_solver_type_convert () const;

      public:
      static const char* const _xsd_ksp_solver_type_literals_[3];
      static const value _xsd_ksp_solver_type_indexes_[3];
    };

    class ksp_preconditioner_type: public ::xml_schema::string
    {
      public:
      enum value
      {
        ilu,
        jacobi,
        bjacobi,
        hypre,
        blockdiagonal,
        none
      };

      ksp_preconditioner_type (value v);

      ksp_preconditioner_type (const char* v);

      ksp_preconditioner_type (const ::std::string& v);

      ksp_preconditioner_type (const ::xml_schema::string& v);

      ksp_preconditioner_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ksp_preconditioner_type (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ksp_preconditioner_type (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ksp_preconditioner_type (const ksp_preconditioner_type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ksp_preconditioner_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ksp_preconditioner_type&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ksp_preconditioner_type_convert ();
      }

      protected:
      value
      _xsd_ksp_preconditioner_type_convert () const;

      public:
      static const char* const _xsd_ksp_preconditioner_type_literals_[6];
      static const value _xsd_ksp_preconditioner_type_indexes_[6];
    };

    class simulation_type: public ::xml_schema::type
    {
      public:
      // SpaceDimension
      //
      typedef ::xml_schema::integer SpaceDimension_type;
      typedef ::xsd::cxx::tree::optional< SpaceDimension_type > SpaceDimension_optional;
      typedef ::xsd::cxx::tree::traits< SpaceDimension_type, char > SpaceDimension_traits;

      const SpaceDimension_optional&
      SpaceDimension () const;

      SpaceDimension_optional&
      SpaceDimension ();

      void
      SpaceDimension (const SpaceDimension_type& x);

      void
      SpaceDimension (const SpaceDimension_optional& x);

      // SimulationDuration
      //
      typedef ::chaste::parameters::time_type SimulationDuration_type;
      typedef ::xsd::cxx::tree::optional< SimulationDuration_type > SimulationDuration_optional;
      typedef ::xsd::cxx::tree::traits< SimulationDuration_type, char > SimulationDuration_traits;

      const SimulationDuration_optional&
      SimulationDuration () const;

      SimulationDuration_optional&
      SimulationDuration ();

      void
      SimulationDuration (const SimulationDuration_type& x);

      void
      SimulationDuration (const SimulationDuration_optional& x);

      void
      SimulationDuration (::std::unique_ptr< SimulationDuration_type > p);

      // Domain
      //
      typedef ::chaste::parameters::domain_type Domain_type;
      typedef ::xsd::cxx::tree::optional< Domain_type > Domain_optional;
      typedef ::xsd::cxx::tree::traits< Domain_type, char > Domain_traits;

      const Domain_optional&
      Domain () const;

      Domain_optional&
      Domain ();

      void
      Domain (const Domain_type& x);

      void
      Domain (const Domain_optional& x);

      void
      Domain (::std::unique_ptr< Domain_type > p);

      // Mesh
      //
      typedef ::chaste::parameters::mesh_type Mesh_type;
      typedef ::xsd::cxx::tree::optional< Mesh_type > Mesh_optional;
      typedef ::xsd::cxx::tree::traits< Mesh_type, char > Mesh_traits;

      const Mesh_optional&
      Mesh () const;

      Mesh_optional&
      Mesh ();

      void
      Mesh (const Mesh_type& x);

      void
      Mesh (const Mesh_optional& x);

      void
      Mesh (::std::unique_ptr< Mesh_type > p);

      // IonicModels
      //
      typedef ::chaste::parameters::ionic_models_type IonicModels_type;
      typedef ::xsd::cxx::tree::optional< IonicModels_type > IonicModels_optional;
      typedef ::xsd::cxx::tree::traits< IonicModels_type, char > IonicModels_traits;

      const IonicModels_optional&
      IonicModels () const;

      IonicModels_optional&
      IonicModels ();

      void
      IonicModels (const IonicModels_type& x);

      void
      IonicModels (const IonicModels_optional& x);

      void
      IonicModels (::std::unique_ptr< IonicModels_type > p);

      // Stimuli
      //
      typedef ::chaste::parameters::Stimuli Stimuli_type;
      typedef ::xsd::cxx::tree::optional< Stimuli_type > Stimuli_optional;
      typedef ::xsd::cxx::tree::traits< Stimuli_type, char > Stimuli_traits;

      const Stimuli_optional&
      Stimuli () const;

      Stimuli_optional&
      Stimuli ();

      void
      Stimuli (const Stimuli_type& x);

      void
      Stimuli (const Stimuli_optional& x);

      void
      Stimuli (::std::unique_ptr< Stimuli_type > p);

      // CellHeterogeneities
      //
      typedef ::chaste::parameters::CellHeterogeneities CellHeterogeneities_type;
      typedef ::xsd::cxx::tree::optional< CellHeterogeneities_type > CellHeterogeneities_optional;
      typedef ::xsd::cxx::tree::traits< CellHeterogeneities_type, char > CellHeterogeneities_traits;

      const CellHeterogeneities_optional&
      CellHeterogeneities () const;

      CellHeterogeneities_optional&
      CellHeterogeneities ();

      void
      CellHeterogeneities (const CellHeterogeneities_type& x);

      void
      CellHeterogeneities (const CellHeterogeneities_optional& x);

      void
      CellHeterogeneities (::std::unique_ptr< CellHeterogeneities_type > p);

      // ConductivityHeterogeneities
      //
      typedef ::chaste::parameters::ConductivityHeterogeneities ConductivityHeterogeneities_type;
      typedef ::xsd::cxx::tree::optional< ConductivityHeterogeneities_type > ConductivityHeterogeneities_optional;
      typedef ::xsd::cxx::tree::traits< ConductivityHeterogeneities_type, char > ConductivityHeterogeneities_traits;

      const ConductivityHeterogeneities_optional&
      ConductivityHeterogeneities () const;

      ConductivityHeterogeneities_optional&
      ConductivityHeterogeneities ();

      void
      ConductivityHeterogeneities (const ConductivityHeterogeneities_type& x);

      void
      ConductivityHeterogeneities (const ConductivityHeterogeneities_optional& x);

      void
      ConductivityHeterogeneities (::std::unique_ptr< ConductivityHeterogeneities_type > p);

      // OutputDirectory
      //
      typedef ::xml_schema::string OutputDirectory_type;
      typedef ::xsd::cxx::tree::optional< OutputDirectory_type > OutputDirectory_optional;
      typedef ::xsd::cxx::tree::traits< OutputDirectory_type, char > OutputDirectory_traits;

      const OutputDirectory_optional&
      OutputDirectory () const;

      OutputDirectory_optional&
      OutputDirectory ();

      void
      OutputDirectory (const OutputDirectory_type& x);

      void
      OutputDirectory (const OutputDirectory_optional& x);

      void
      OutputDirectory (::std::unique_ptr< OutputDirectory_type > p);

      // OutputFilenamePrefix
      //
      typedef ::xml_schema::string OutputFilenamePrefix_type;
      typedef ::xsd::cxx::tree::optional< OutputFilenamePrefix_type > OutputFilenamePrefix_optional;
      typedef ::xsd::cxx::tree::traits< OutputFilenamePrefix_type, char > OutputFilenamePrefix_traits;

      const OutputFilenamePrefix_optional&
      OutputFilenamePrefix () const;

      OutputFilenamePrefix_optional&
      OutputFilenamePrefix ();

      void
      OutputFilenamePrefix (const OutputFilenamePrefix_type& x);

      void
      OutputFilenamePrefix (const OutputFilenamePrefix_optional& x);

      void
      OutputFilenamePrefix (::std::unique_ptr< OutputFilenamePrefix_type > p);

      // Constructors.
      //
      simulation_type ();

      simulation_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      simulation_type (const simulation_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual simulation_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      simulation_type&
      operator= (const simulation_type& x);

      virtual 
      ~simulation_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SpaceDimension_optional SpaceDimension_;
      SimulationDuration_optional SimulationDuration_;
      Domain_optional Domain_;
      Mesh_optional Mesh_;
      IonicModels_optional IonicModels_;
      Stimuli_optional Stimuli_;
      CellHeterogeneities_optional CellHeterogeneities_;
      ConductivityHeterogeneities_optional ConductivityHeterogeneities_;
      OutputDirectory_optional OutputDirectory_;
      OutputFilenamePrefix_optional OutputFilenamePrefix_;
    };

    class physiological_type: public ::xml_schema::type
    {
      public:
      // IntracellularConductivities
      //
      typedef ::chaste::parameters::conductivities_type IntracellularConductivities_type;
      typedef ::xsd::cxx::tree::optional< IntracellularConductivities_type > IntracellularConductivities_optional;
      typedef ::xsd::cxx::tree::traits< IntracellularConductivities_type, char > IntracellularConductivities_traits;

      const IntracellularConductivities_optional&
      IntracellularConductivities () const;

      IntracellularConductivities_optional&
      IntracellularConductivities ();

      void
      IntracellularConductivities (const IntracellularConductivities_type& x);

      void
      IntracellularConductivities (const IntracellularConductivities_optional& x);

      void
      IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > p);

      // ExtracellularConductivities
      //
      typedef ::chaste::parameters::conductivities_type ExtracellularConductivities_type;
      typedef ::xsd::cxx::tree::optional< ExtracellularConductivities_type > ExtracellularConductivities_optional;
      typedef ::xsd::cxx::tree::traits< ExtracellularConductivities_type, char > ExtracellularConductivities_traits;

      const ExtracellularConductivities_optional&
      ExtracellularConductivities () const;

      ExtracellularConductivities_optional&
      ExtracellularConductivities ();

      void
      ExtracellularConductivities (const ExtracellularConductivities_type& x);

      void
      ExtracellularConductivities (const ExtracellularConductivities_optional& x);

      void
      ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > p);

      // BathConductivity
      //
      typedef ::chaste::parameters::conductivity_type BathConductivity_type;
      typedef ::xsd::cxx::tree::optional< BathConductivity_type > BathConductivity_optional;
      typedef ::xsd::cxx::tree::traits< BathConductivity_type, char > BathConductivity_traits;

      const BathConductivity_optional&
      BathConductivity () const;

      BathConductivity_optional&
      BathConductivity ();

      void
      BathConductivity (const BathConductivity_type& x);

      void
      BathConductivity (const BathConductivity_optional& x);

      void
      BathConductivity (::std::unique_ptr< BathConductivity_type > p);

      // SurfaceAreaToVolumeRatio
      //
      typedef ::chaste::parameters::inverse_length_type SurfaceAreaToVolumeRatio_type;
      typedef ::xsd::cxx::tree::optional< SurfaceAreaToVolumeRatio_type > SurfaceAreaToVolumeRatio_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceAreaToVolumeRatio_type, char > SurfaceAreaToVolumeRatio_traits;

      const SurfaceAreaToVolumeRatio_optional&
      SurfaceAreaToVolumeRatio () const;

      SurfaceAreaToVolumeRatio_optional&
      SurfaceAreaToVolumeRatio ();

      void
      SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_type& x);

      void
      SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_optional& x);

      void
      SurfaceAreaToVolumeRatio (::std::unique_ptr< SurfaceAreaToVolumeRatio_type > p);

      // Capacitance
      //
      typedef ::chaste::parameters::capacitance_type Capacitance_type;
      typedef ::xsd::cxx::tree::optional< Capacitance_type > Capacitance_optional;
      typedef ::xsd::cxx::tree::traits< Capacitance_type, char > Capacitance_traits;

      const Capacitance_optional&
      Capacitance () const;

      Capacitance_optional&
      Capacitance ();

      void
      Capacitance (const Capacitance_type& x);

      void
      Capacitance (const Capacitance_optional& x);

      void
      Capacitance (::std::unique_ptr< Capacitance_type > p);

      // Constructors.
      //
      physiological_type ();

      physiological_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      physiological_type (const physiological_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual physiological_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      physiological_type&
      operator= (const physiological_type& x);

      virtual 
      ~physiological_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      IntracellularConductivities_optional IntracellularConductivities_;
      ExtracellularConductivities_optional ExtracellularConductivities_;
      BathConductivity_optional BathConductivity_;
      SurfaceAreaToVolumeRatio_optional SurfaceAreaToVolumeRatio_;
      Capacitance_optional Capacitance_;
    };

    class numerical_type: public ::xml_schema::type
    {
      public:
      // TimeSteps
      //
      typedef ::chaste::parameters::time_steps_type TimeSteps_type;
      typedef ::xsd::cxx::tree::optional< TimeSteps_type > TimeSteps_optional;
      typedef ::xsd::cxx::tree::traits< TimeSteps_type, char > TimeSteps_traits;

      const TimeSteps_optional&
      TimeSteps () const;

      TimeSteps_optional&
      TimeSteps ();

      void
      TimeSteps (const TimeSteps_type& x);

      void
      TimeSteps (const TimeSteps_optional& x);

      void
      TimeSteps (::std::unique_ptr< TimeSteps_type > p);

      // KSPTolerances
      //
      typedef ::chaste::parameters::ksp_tolerances_type KSPTolerances_type;
      typedef ::xsd::cxx::tree::optional< KSPTolerances_type > KSPTolerances_optional;
      typedef ::xsd::cxx::tree::traits< KSPTolerances_type, char > KSPTolerances_traits;

      const KSPTolerances_optional&
      KSPTolerances () const;

      KSPTolerances_optional&
      KSPTolerances ();

      void
      KSPTolerances (const KSPTolerances_type& x);

      void
      KSPTolerances (const KSPTolerances_optional& x);

      void
      KSPTolerances (::std::unique_ptr< KSPTolerances_type > p);

      // KSPSolver
      //
      typedef ::chaste::parameters::ksp_solver_type KSPSolver_type;
      typedef ::xsd::cxx::tree::optional< KSPSolver_type > KSPSolver_optional;
      typedef ::xsd::cxx::tree::traits< KSPSolver_type, char > KSPSolver_traits;

      const KSPSolver_optional&
      KSPSolver () const;

      KSPSolver_optional&
      KSPSolver ();

      void
      KSPSolver (const KSPSolver_type& x);

      void
      KSPSolver (const KSPSolver_optional& x);

      void
      KSPSolver (::std::unique_ptr< KSPSolver_type > p);

      // KSPPreconditioner
      //
      typedef ::chaste::parameters::ksp_preconditioner_type KSPPreconditioner_type;
      typedef ::xsd::cxx::tree::optional< KSPPreconditioner_type > KSPPreconditioner_optional;
      typedef ::xsd::cxx::tree::traits< KSPPreconditioner_type, char > KSPPreconditioner_traits;

      const KSPPreconditioner_optional&
      KSPPreconditioner () const;

      KSPPreconditioner_optional&
      KSPPreconditioner ();

      void
      KSPPreconditioner (const KSPPreconditioner_type& x);

      void
      KSPPreconditioner (const KSPPreconditioner_optional& x);

      void
      KSPPreconditioner (::std::unique_ptr< KSPPreconditioner_type > p);

      // Constructors.
      //
      numerical_type ();

      numerical_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      numerical_type (const numerical_type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual numerical_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      numerical_type&
      operator= (const numerical_type& x);

      virtual 
      ~numerical_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      TimeSteps_optional TimeSteps_;
      KSPTolerances_optional KSPTolerances_;
      KSPSolver_optional KSPSolver_;
      KSPPreconditioner_optional KSPPreconditioner_;
    };

    class postprocessing_type: public ::xml_schema::type
    {
      public:
      // ActionPotentialDurationMap
      //
      typedef ::chaste::parameters::apd_map_type ActionPotentialDurationMap_type;
      typedef ::xsd::cxx::tree::sequence< ActionPotentialDurationMap_type > ActionPotentialDurationMap_sequence;
      typedef ActionPotentialDurationMap_sequence::iterator ActionPotentialDurationMap_iterator;
      typedef ActionPotentialDurationMap_sequence::const_iterator ActionPotentialDurationMap_const_iterator;
      typedef ::xsd::cxx::tree::traits< ActionPotentialDurationMap_type, char > ActionPotentialDurationMap_traits;

      const ActionPotentialDurationMap_sequence&
      ActionPotentialDurationMap () const;

      ActionPotentialDurationMap_sequence&
      ActionPotentialDurationMap ();

      void
      ActionPotentialDurationMap (const ActionPotentialDurationMap_sequence& s);

      // UpstrokeTimeMap
      //
      typedef ::chaste::parameters::upstrokes_map_type UpstrokeTimeMap_type;
      typedef ::xsd::cxx::tree::sequence< UpstrokeTimeMap_type > UpstrokeTimeMap_sequence;
      typedef UpstrokeTimeMap_sequence::iterator UpstrokeTimeMap_iterator;
      typedef UpstrokeTimeMap_sequence::const_iterator UpstrokeTimeMap_const_iterator;
      typedef ::xsd::cxx::tree::traits< UpstrokeTimeMap_type, char > UpstrokeTimeMap_traits;

      const UpstrokeTimeMap_sequence&
      UpstrokeTimeMap () const;

      UpstrokeTimeMap_sequence&
      UpstrokeTimeMap ();

      void
      UpstrokeTimeMap (const UpstrokeTimeMap_sequence& s);

      // MaxUpstrokeVelocityMap
      //
      typedef ::chaste::parameters::empty_type MaxUpstrokeVelocityMap_type;
      typedef ::xsd::cxx::tree::optional< MaxUpstrokeVelocityMap_type > MaxUpstrokeVelocityMap_optional;
      typedef ::xsd::cxx::tree::traits< MaxUpstrokeVelocityMap_type, char > MaxUpstrokeVelocityMap_traits;

      const MaxUpstrokeVelocityMap_optional&
      MaxUpstrokeVelocityMap () const;

      MaxUpstrokeVelocityMap_optional&
      MaxUpstrokeVelocityMap ();

      void
      MaxUpstrokeVelocityMap (const MaxUpstrokeVelocityMap_type& x);

      void
      MaxUpstrokeVelocityMap (const MaxUpstrokeVelocityMap_optional& x);

      void
      MaxUpstrokeVelocityMap (::std::unique_ptr< MaxUpstrokeVelocityMap_type > p);

      // ConductionVelocityMap
      //
      typedef ::chaste::parameters::conduction_velocity_map_type ConductionVelocityMap_type;
      typedef ::xsd::cxx::tree::sequence< ConductionVelocityMap_type > ConductionVelocityMap_sequence;
      typedef ConductionVelocityMap_sequence::iterator ConductionVelocityMap_iterator;
      typedef ConductionVelocityMap_sequence::const_iterator ConductionVelocityMap_const_iterator;
      typedef ::xsd::cxx::tree::traits< ConductionVelocityMap_type, char > ConductionVelocityMap_traits;

      const ConductionVelocityMap_sequence&
      ConductionVelocityMap () const;

      ConductionVelocityMap_sequence&
      ConductionVelocityMap ();

      void
      ConductionVelocityMap (const ConductionVelocityMap_sequence& s);

      // Constructors.
      //
      postprocessing_type ();

      postprocessing_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      postprocessing_type (const postprocessing_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual postprocessing_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      postprocessing_type&
      operator= (const postprocessing_type& x);

      virtual 
      ~postprocessing_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ActionPotentialDurationMap_sequence ActionPotentialDurationMap_;
      UpstrokeTimeMap_sequence UpstrokeTimeMap_;
      MaxUpstrokeVelocityMap_optional MaxUpstrokeVelocityMap_;
      ConductionVelocityMap_sequence ConductionVelocityMap_;
    };

    class chaste_parameters_type: public ::xml_schema::type
    {
      public:
      // Simulation
      //
      typedef ::chaste::parameters::simulation_type Simulation_type;
      typedef ::xsd::cxx::tree::traits< Simulation_type, char > Simulation_traits;

      const Simulation_type&
      Simulation () const;

      Simulation_type&
      Simulation ();

      void
      Simulation (const Simulation_type& x);

      void
      Simulation (::std::unique_ptr< Simulation_type > p);

      // Physiological
      //
      typedef ::chaste::parameters::physiological_type Physiological_type;
      typedef ::xsd::cxx::tree::traits< Physiological_type, char > Physiological_traits;

      const Physiological_type&
      Physiological () const;

      Physiological_type&
      Physiological ();

      void
      Physiological (const Physiological_type& x);

      void
      Physiological (::std::unique_ptr< Physiological_type > p);

      // Numerical
      //
      typedef ::chaste::parameters::numerical_type Numerical_type;
      typedef ::xsd::cxx::tree::traits< Numerical_type, char > Numerical_traits;

      const Numerical_type&
      Numerical () const;

      Numerical_type&
      Numerical ();

      void
      Numerical (const Numerical_type& x);

      void
      Numerical (::std::unique_ptr< Numerical_type > p);

      // PostProcessing
      //
      typedef ::chaste::parameters::postprocessing_type PostProcessing_type;
      typedef ::xsd::cxx::tree::optional< PostProcessing_type > PostProcessing_optional;
      typedef ::xsd::cxx::tree::traits< PostProcessing_type, char > PostProcessing_traits;

      const PostProcessing_optional&
      PostProcessing () const;

      PostProcessing_optional&
      PostProcessing ();

      void
      PostProcessing (const PostProcessing_type& x);

      void
      PostProcessing (const PostProcessing_optional& x);

      void
      PostProcessing (::std::unique_ptr< PostProcessing_type > p);

      // Constructors.
      //
      chaste_parameters_type (const Simulation_type&,
                              const Physiological_type&,
                              const Numerical_type&);

      chaste_parameters_type (::std::unique_ptr< Simulation_type >,
                              ::std::unique_ptr< Physiological_type >,
                              ::std::unique_ptr< Numerical_type >);

      chaste_parameters_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      chaste_parameters_type (const chaste_parameters_type& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual chaste_parameters_type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      chaste_parameters_type&
      operator= (const chaste_parameters_type& x);

      virtual 
      ~chaste_parameters_type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Simulation_type > Simulation_;
      ::xsd::cxx::tree::one< Physiological_type > Physiological_;
      ::xsd::cxx::tree::one< Numerical_type > Numerical_;
      PostProcessing_optional PostProcessing_;
    };

    class Stimuli: public ::xml_schema::type
    {
      public:
      // Stimulus
      //
      typedef ::chaste::parameters::stimulus_type Stimulus_type;
      typedef ::xsd::cxx::tree::sequence< Stimulus_type > Stimulus_sequence;
      typedef Stimulus_sequence::iterator Stimulus_iterator;
      typedef Stimulus_sequence::const_iterator Stimulus_const_iterator;
      typedef ::xsd::cxx::tree::traits< Stimulus_type, char > Stimulus_traits;

      const Stimulus_sequence&
      Stimulus () const;

      Stimulus_sequence&
      Stimulus ();

      void
      Stimulus (const Stimulus_sequence& s);

      // Constructors.
      //
      Stimuli ();

      Stimuli (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Stimuli (const Stimuli& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual Stimuli*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Stimuli&
      operator= (const Stimuli& x);

      virtual 
      ~Stimuli ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Stimulus_sequence Stimulus_;
    };

    class CellHeterogeneities: public ::xml_schema::type
    {
      public:
      // CellHeterogeneity
      //
      typedef ::chaste::parameters::cell_heterogeneity_type CellHeterogeneity_type;
      typedef ::xsd::cxx::tree::sequence< CellHeterogeneity_type > CellHeterogeneity_sequence;
      typedef CellHeterogeneity_sequence::iterator CellHeterogeneity_iterator;
      typedef CellHeterogeneity_sequence::const_iterator CellHeterogeneity_const_iterator;
      typedef ::xsd::cxx::tree::traits< CellHeterogeneity_type, char > CellHeterogeneity_traits;

      const CellHeterogeneity_sequence&
      CellHeterogeneity () const;

      CellHeterogeneity_sequence&
      CellHeterogeneity ();

      void
      CellHeterogeneity (const CellHeterogeneity_sequence& s);

      // Constructors.
      //
      CellHeterogeneities ();

      CellHeterogeneities (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CellHeterogeneities (const CellHeterogeneities& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CellHeterogeneities*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CellHeterogeneities&
      operator= (const CellHeterogeneities& x);

      virtual 
      ~CellHeterogeneities ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      CellHeterogeneity_sequence CellHeterogeneity_;
    };

    class ConductivityHeterogeneities: public ::xml_schema::type
    {
      public:
      // ConductivityHeterogeneity
      //
      typedef ::chaste::parameters::conductivity_heterogeneity_type ConductivityHeterogeneity_type;
      typedef ::xsd::cxx::tree::sequence< ConductivityHeterogeneity_type > ConductivityHeterogeneity_sequence;
      typedef ConductivityHeterogeneity_sequence::iterator ConductivityHeterogeneity_iterator;
      typedef ConductivityHeterogeneity_sequence::const_iterator ConductivityHeterogeneity_const_iterator;
      typedef ::xsd::cxx::tree::traits< ConductivityHeterogeneity_type, char > ConductivityHeterogeneity_traits;

      const ConductivityHeterogeneity_sequence&
      ConductivityHeterogeneity () const;

      ConductivityHeterogeneity_sequence&
      ConductivityHeterogeneity ();

      void
      ConductivityHeterogeneity (const ConductivityHeterogeneity_sequence& s);

      // Constructors.
      //
      ConductivityHeterogeneities ();

      ConductivityHeterogeneities (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ConductivityHeterogeneities (const ConductivityHeterogeneities& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ConductivityHeterogeneities*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConductivityHeterogeneities&
      operator= (const ConductivityHeterogeneities& x);

      virtual 
      ~ConductivityHeterogeneities ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ConductivityHeterogeneity_sequence ConductivityHeterogeneity_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace chaste
{
  namespace parameters
  {
    // Parse a URI or a local file.
    //

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::std::string& uri,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::std::string& uri,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::std::string& uri,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      const ::std::string& id,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      const ::std::string& id,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      const ::std::string& id,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xercesc::InputSource& is,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xercesc::InputSource& is,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xercesc::InputSource& is,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace chaste
{
  namespace parameters
  {
    void
    operator<< (::xercesc::DOMElement&, const time_type&);

    void
    operator<< (::xercesc::DOMElement&, const dimensionless_type&);

    void
    operator<< (::xercesc::DOMElement&, const conductivity_type&);

    void
    operator<< (::xercesc::DOMElement&, const stimulus_strength_type&);

    void
    operator<< (::xercesc::DOMElement&, const inverse_length_type&);

    void
    operator<< (::xercesc::DOMElement&, const capacitance_type&);

    void
    operator<< (::xercesc::DOMElement&, const location_type&);

    void
    operator<< (::xercesc::DOMElement&, const domain_type&);

    void
    operator<< (::xercesc::DOMAttr&, const domain_type&);

    void
    operator<< (::xml_schema::list_stream&,
                const domain_type&);

    void
    operator<< (::xercesc::DOMElement&, const ionic_models_available_type&);

    void
    operator<< (::xercesc::DOMAttr&, const ionic_models_available_type&);

    void
    operator<< (::xml_schema::list_stream&,
                const ionic_models_available_type&);

    void
    operator<< (::xercesc::DOMElement&, const ionic_model_region_type&);

    void
    operator<< (::xercesc::DOMElement&, const ionic_models_type&);

    void
    operator<< (::xercesc::DOMElement&, const apd_map_type&);

    void
    operator<< (::xercesc::DOMElement&, const upstrokes_map_type&);

    void
    operator<< (::xercesc::DOMElement&, const empty_type&);

    void
    operator<< (::xercesc::DOMAttr&, const empty_type&);

    void
    operator<< (::xml_schema::list_stream&,
                const empty_type&);

    void
    operator<< (::xercesc::DOMElement&, const conduction_velocity_map_type&);

    void
    operator<< (::xercesc::DOMElement&, const media_type&);

    void
    operator<< (::xercesc::DOMAttr&, const media_type&);

    void
    operator<< (::xml_schema::list_stream&,
                const media_type&);

    void
    operator<< (::xercesc::DOMElement&, const point_type&);

    void
    operator<< (::xercesc::DOMElement&, const box_type&);

    void
    operator<< (::xercesc::DOMElement&, const stimulus_type&);

    void
    operator<< (::xercesc::DOMElement&, const cell_heterogeneity_type&);

    void
    operator<< (::xercesc::DOMElement&, const conductivity_heterogeneity_type&);

    void
    operator<< (::xercesc::DOMElement&, const slab_type&);

    void
    operator<< (::xercesc::DOMElement&, const sheet_type&);

    void
    operator<< (::xercesc::DOMElement&, const fibre_type&);

    void
    operator<< (::xercesc::DOMElement&, const load_mesh_type&);

    void
    operator<< (::xercesc::DOMElement&, const mesh_type&);

    void
    operator<< (::xercesc::DOMElement&, const conductivities_type&);

    void
    operator<< (::xercesc::DOMElement&, const time_steps_type&);

    void
    operator<< (::xercesc::DOMElement&, const ksp_use_type&);

    void
    operator<< (::xercesc::DOMAttr&, const ksp_use_type&);

    void
    operator<< (::xml_schema::list_stream&,
                const ksp_use_type&);

    void
    operator<< (::xercesc::DOMElement&, const ksp_tolerances_type&);

    void
    operator<< (::xercesc::DOMElement&, const ksp_solver_type&);

    void
    operator<< (::xercesc::DOMAttr&, const ksp_solver_type&);

    void
    operator<< (::xml_schema::list_stream&,
                const ksp_solver_type&);

    void
    operator<< (::xercesc::DOMElement&, const ksp_preconditioner_type&);

    void
    operator<< (::xercesc::DOMAttr&, const ksp_preconditioner_type&);

    void
    operator<< (::xml_schema::list_stream&,
                const ksp_preconditioner_type&);

    void
    operator<< (::xercesc::DOMElement&, const simulation_type&);

    void
    operator<< (::xercesc::DOMElement&, const physiological_type&);

    void
    operator<< (::xercesc::DOMElement&, const numerical_type&);

    void
    operator<< (::xercesc::DOMElement&, const postprocessing_type&);

    void
    operator<< (::xercesc::DOMElement&, const chaste_parameters_type&);

    // Serialize to std::ostream.
    //

    void
    ChasteParameters (::std::ostream& os,
                      const ::chaste::parameters::chaste_parameters_type& x, 
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

    void
    ChasteParameters (::std::ostream& os,
                      const ::chaste::parameters::chaste_parameters_type& x, 
                      ::xml_schema::error_handler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

    void
    ChasteParameters (::std::ostream& os,
                      const ::chaste::parameters::chaste_parameters_type& x, 
                      ::xercesc::DOMErrorHandler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    ChasteParameters (::xercesc::XMLFormatTarget& ft,
                      const ::chaste::parameters::chaste_parameters_type& x, 
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

    void
    ChasteParameters (::xercesc::XMLFormatTarget& ft,
                      const ::chaste::parameters::chaste_parameters_type& x, 
                      ::xml_schema::error_handler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

    void
    ChasteParameters (::xercesc::XMLFormatTarget& ft,
                      const ::chaste::parameters::chaste_parameters_type& x, 
                      ::xercesc::DOMErrorHandler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    ChasteParameters (::xercesc::DOMDocument& d,
                      const ::chaste::parameters::chaste_parameters_type& x,
                      ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    ChasteParameters (const ::chaste::parameters::chaste_parameters_type& x, 
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const Stimuli&);

    void
    operator<< (::xercesc::DOMElement&, const CellHeterogeneities&);

    void
    operator<< (::xercesc::DOMElement&, const ConductivityHeterogeneities&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
// LCOV_EXCL_STOP
//
// End epilogue.

#endif // HEART_SRC_IO_CHASTE_PARAMETERS_1_1_HPP
