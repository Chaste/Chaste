// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
// LCOV_EXCL_START
/** @autogenerated */
#include <streambuf>
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ChasteParameters_2017_1.hpp"

namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      // time_type
      // 

      const time_type::unit_type& time_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const time_type::unit_type& time_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // dimensionless_type
      // 

      const dimensionless_type::unit_type& dimensionless_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const dimensionless_type::unit_type& dimensionless_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // conductivity_type
      // 

      const conductivity_type::unit_type& conductivity_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const conductivity_type::unit_type& conductivity_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // stimulus_strength_type
      // 

      const stimulus_strength_type::unit_type& stimulus_strength_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const stimulus_strength_type::unit_type& stimulus_strength_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // surface_stimulus_strength_type
      // 

      const surface_stimulus_strength_type::unit_type& surface_stimulus_strength_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const surface_stimulus_strength_type::unit_type& surface_stimulus_strength_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // inverse_length_type
      // 

      const inverse_length_type::unit_type& inverse_length_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const inverse_length_type::unit_type& inverse_length_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // capacitance_type
      // 

      const capacitance_type::unit_type& capacitance_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const capacitance_type::unit_type& capacitance_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // apply_drug_type
      // 

      const apply_drug_type::IC50_sequence& apply_drug_type::
      IC50 () const
      {
        return this->IC50_;
      }

      apply_drug_type::IC50_sequence& apply_drug_type::
      IC50 ()
      {
        return this->IC50_;
      }

      void apply_drug_type::
      IC50 (const IC50_sequence& s)
      {
        this->IC50_ = s;
      }

      const apply_drug_type::concentration_type& apply_drug_type::
      concentration () const
      {
        return this->concentration_.get ();
      }

      apply_drug_type::concentration_type& apply_drug_type::
      concentration ()
      {
        return this->concentration_.get ();
      }

      void apply_drug_type::
      concentration (const concentration_type& x)
      {
        this->concentration_.set (x);
      }


      // ic50_type
      // 

      const ic50_type::current_type& ic50_type::
      current () const
      {
        return this->current_.get ();
      }

      ic50_type::current_type& ic50_type::
      current ()
      {
        return this->current_.get ();
      }

      void ic50_type::
      current (const current_type& x)
      {
        this->current_.set (x);
      }

      void ic50_type::
      current (::std::unique_ptr< current_type > x)
      {
        this->current_.set (std::move (x));
      }

      const ic50_type::hill_type& ic50_type::
      hill () const
      {
        return this->hill_.get ();
      }

      ic50_type::hill_type& ic50_type::
      hill ()
      {
        return this->hill_.get ();
      }

      void ic50_type::
      hill (const hill_type& x)
      {
        this->hill_.set (x);
      }

      ic50_type::hill_type ic50_type::
      hill_default_value ()
      {
        return hill_type (1.0);
      }


      // location_type
      // 

      const location_type::Cuboid_optional& location_type::
      Cuboid () const
      {
        return this->Cuboid_;
      }

      location_type::Cuboid_optional& location_type::
      Cuboid ()
      {
        return this->Cuboid_;
      }

      void location_type::
      Cuboid (const Cuboid_type& x)
      {
        this->Cuboid_.set (x);
      }

      void location_type::
      Cuboid (const Cuboid_optional& x)
      {
        this->Cuboid_ = x;
      }

      void location_type::
      Cuboid (::std::unique_ptr< Cuboid_type > x)
      {
        this->Cuboid_.set (std::move (x));
      }

      const location_type::Ellipsoid_optional& location_type::
      Ellipsoid () const
      {
        return this->Ellipsoid_;
      }

      location_type::Ellipsoid_optional& location_type::
      Ellipsoid ()
      {
        return this->Ellipsoid_;
      }

      void location_type::
      Ellipsoid (const Ellipsoid_type& x)
      {
        this->Ellipsoid_.set (x);
      }

      void location_type::
      Ellipsoid (const Ellipsoid_optional& x)
      {
        this->Ellipsoid_ = x;
      }

      void location_type::
      Ellipsoid (::std::unique_ptr< Ellipsoid_type > x)
      {
        this->Ellipsoid_.set (std::move (x));
      }

      const location_type::NotUsed_optional& location_type::
      NotUsed () const
      {
        return this->NotUsed_;
      }

      location_type::NotUsed_optional& location_type::
      NotUsed ()
      {
        return this->NotUsed_;
      }

      void location_type::
      NotUsed (const NotUsed_type& x)
      {
        this->NotUsed_.set (x);
      }

      void location_type::
      NotUsed (const NotUsed_optional& x)
      {
        this->NotUsed_ = x;
      }

      location_type::NotUsed_type location_type::
      NotUsed_default_value ()
      {
        return NotUsed_type (true);
      }

      const location_type::EpiLayer_optional& location_type::
      EpiLayer () const
      {
        return this->EpiLayer_;
      }

      location_type::EpiLayer_optional& location_type::
      EpiLayer ()
      {
        return this->EpiLayer_;
      }

      void location_type::
      EpiLayer (const EpiLayer_type& x)
      {
        this->EpiLayer_.set (x);
      }

      void location_type::
      EpiLayer (const EpiLayer_optional& x)
      {
        this->EpiLayer_ = x;
      }

      void location_type::
      EpiLayer (::std::unique_ptr< EpiLayer_type > x)
      {
        this->EpiLayer_.set (std::move (x));
      }

      const location_type::MidLayer_optional& location_type::
      MidLayer () const
      {
        return this->MidLayer_;
      }

      location_type::MidLayer_optional& location_type::
      MidLayer ()
      {
        return this->MidLayer_;
      }

      void location_type::
      MidLayer (const MidLayer_type& x)
      {
        this->MidLayer_.set (x);
      }

      void location_type::
      MidLayer (const MidLayer_optional& x)
      {
        this->MidLayer_ = x;
      }

      void location_type::
      MidLayer (::std::unique_ptr< MidLayer_type > x)
      {
        this->MidLayer_.set (std::move (x));
      }

      const location_type::EndoLayer_optional& location_type::
      EndoLayer () const
      {
        return this->EndoLayer_;
      }

      location_type::EndoLayer_optional& location_type::
      EndoLayer ()
      {
        return this->EndoLayer_;
      }

      void location_type::
      EndoLayer (const EndoLayer_type& x)
      {
        this->EndoLayer_.set (x);
      }

      void location_type::
      EndoLayer (const EndoLayer_optional& x)
      {
        this->EndoLayer_ = x;
      }

      void location_type::
      EndoLayer (::std::unique_ptr< EndoLayer_type > x)
      {
        this->EndoLayer_.set (std::move (x));
      }

      const location_type::unit_type& location_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const location_type::unit_type& location_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // domain_type
      // 

      domain_type::
      domain_type (value v)
      : ::xml_schema::string (_xsd_domain_type_literals_[v])
      {
      }

      domain_type::
      domain_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      domain_type::
      domain_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      domain_type::
      domain_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      domain_type::
      domain_type (const domain_type& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      domain_type& domain_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_domain_type_literals_[v]);

        return *this;
      }


      // axis_type
      // 

      axis_type::
      axis_type (value v)
      : ::xml_schema::string (_xsd_axis_type_literals_[v])
      {
      }

      axis_type::
      axis_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      axis_type::
      axis_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      axis_type::
      axis_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      axis_type::
      axis_type (const axis_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      axis_type& axis_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_axis_type_literals_[v]);

        return *this;
      }


      // ionic_models_available_type
      // 

      ionic_models_available_type::
      ionic_models_available_type (value v)
      : ::xml_schema::string (_xsd_ionic_models_available_type_literals_[v])
      {
      }

      ionic_models_available_type::
      ionic_models_available_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      ionic_models_available_type::
      ionic_models_available_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      ionic_models_available_type::
      ionic_models_available_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      ionic_models_available_type::
      ionic_models_available_type (const ionic_models_available_type& v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      ionic_models_available_type& ionic_models_available_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_ionic_models_available_type_literals_[v]);

        return *this;
      }


      // ionic_model_selection_type
      // 

      const ionic_model_selection_type::Hardcoded_optional& ionic_model_selection_type::
      Hardcoded () const
      {
        return this->Hardcoded_;
      }

      ionic_model_selection_type::Hardcoded_optional& ionic_model_selection_type::
      Hardcoded ()
      {
        return this->Hardcoded_;
      }

      void ionic_model_selection_type::
      Hardcoded (const Hardcoded_type& x)
      {
        this->Hardcoded_.set (x);
      }

      void ionic_model_selection_type::
      Hardcoded (const Hardcoded_optional& x)
      {
        this->Hardcoded_ = x;
      }

      void ionic_model_selection_type::
      Hardcoded (::std::unique_ptr< Hardcoded_type > x)
      {
        this->Hardcoded_.set (std::move (x));
      }

      const ionic_model_selection_type::Dynamic_optional& ionic_model_selection_type::
      Dynamic () const
      {
        return this->Dynamic_;
      }

      ionic_model_selection_type::Dynamic_optional& ionic_model_selection_type::
      Dynamic ()
      {
        return this->Dynamic_;
      }

      void ionic_model_selection_type::
      Dynamic (const Dynamic_type& x)
      {
        this->Dynamic_.set (x);
      }

      void ionic_model_selection_type::
      Dynamic (const Dynamic_optional& x)
      {
        this->Dynamic_ = x;
      }

      void ionic_model_selection_type::
      Dynamic (::std::unique_ptr< Dynamic_type > x)
      {
        this->Dynamic_.set (std::move (x));
      }


      // dynamically_loaded_ionic_model_type
      // 

      const dynamically_loaded_ionic_model_type::Path_type& dynamically_loaded_ionic_model_type::
      Path () const
      {
        return this->Path_.get ();
      }

      dynamically_loaded_ionic_model_type::Path_type& dynamically_loaded_ionic_model_type::
      Path ()
      {
        return this->Path_.get ();
      }

      void dynamically_loaded_ionic_model_type::
      Path (const Path_type& x)
      {
        this->Path_.set (x);
      }

      void dynamically_loaded_ionic_model_type::
      Path (::std::unique_ptr< Path_type > x)
      {
        this->Path_.set (std::move (x));
      }


      // path_type
      // 

      const path_type::relative_to_type& path_type::
      relative_to () const
      {
        return this->relative_to_.get ();
      }

      path_type::relative_to_type& path_type::
      relative_to ()
      {
        return this->relative_to_.get ();
      }

      void path_type::
      relative_to (const relative_to_type& x)
      {
        this->relative_to_.set (x);
      }

      void path_type::
      relative_to (::std::unique_ptr< relative_to_type > x)
      {
        this->relative_to_.set (std::move (x));
      }

      const path_type::relative_to_type& path_type::
      relative_to_default_value ()
      {
        return relative_to_default_value_;
      }


      // relative_to_type
      // 

      relative_to_type::
      relative_to_type (value v)
      : ::xml_schema::string (_xsd_relative_to_type_literals_[v])
      {
      }

      relative_to_type::
      relative_to_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      relative_to_type::
      relative_to_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      relative_to_type::
      relative_to_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      relative_to_type::
      relative_to_type (const relative_to_type& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      relative_to_type& relative_to_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_relative_to_type_literals_[v]);

        return *this;
      }


      // ionic_model_region_type
      // 

      const ionic_model_region_type::IonicModel_type& ionic_model_region_type::
      IonicModel () const
      {
        return this->IonicModel_.get ();
      }

      ionic_model_region_type::IonicModel_type& ionic_model_region_type::
      IonicModel ()
      {
        return this->IonicModel_.get ();
      }

      void ionic_model_region_type::
      IonicModel (const IonicModel_type& x)
      {
        this->IonicModel_.set (x);
      }

      void ionic_model_region_type::
      IonicModel (::std::unique_ptr< IonicModel_type > x)
      {
        this->IonicModel_.set (std::move (x));
      }

      const ionic_model_region_type::Location_type& ionic_model_region_type::
      Location () const
      {
        return this->Location_.get ();
      }

      ionic_model_region_type::Location_type& ionic_model_region_type::
      Location ()
      {
        return this->Location_.get ();
      }

      void ionic_model_region_type::
      Location (const Location_type& x)
      {
        this->Location_.set (x);
      }

      void ionic_model_region_type::
      Location (::std::unique_ptr< Location_type > x)
      {
        this->Location_.set (std::move (x));
      }


      // ionic_models_type
      // 

      const ionic_models_type::Default_type& ionic_models_type::
      Default () const
      {
        return this->Default_.get ();
      }

      ionic_models_type::Default_type& ionic_models_type::
      Default ()
      {
        return this->Default_.get ();
      }

      void ionic_models_type::
      Default (const Default_type& x)
      {
        this->Default_.set (x);
      }

      void ionic_models_type::
      Default (::std::unique_ptr< Default_type > x)
      {
        this->Default_.set (std::move (x));
      }

      const ionic_models_type::Region_sequence& ionic_models_type::
      Region () const
      {
        return this->Region_;
      }

      ionic_models_type::Region_sequence& ionic_models_type::
      Region ()
      {
        return this->Region_;
      }

      void ionic_models_type::
      Region (const Region_sequence& s)
      {
        this->Region_ = s;
      }


      // apd_map_type
      // 

      const apd_map_type::repolarisation_percentage_type& apd_map_type::
      repolarisation_percentage () const
      {
        return this->repolarisation_percentage_.get ();
      }

      apd_map_type::repolarisation_percentage_type& apd_map_type::
      repolarisation_percentage ()
      {
        return this->repolarisation_percentage_.get ();
      }

      void apd_map_type::
      repolarisation_percentage (const repolarisation_percentage_type& x)
      {
        this->repolarisation_percentage_.set (x);
      }

      const apd_map_type::threshold_type& apd_map_type::
      threshold () const
      {
        return this->threshold_.get ();
      }

      apd_map_type::threshold_type& apd_map_type::
      threshold ()
      {
        return this->threshold_.get ();
      }

      void apd_map_type::
      threshold (const threshold_type& x)
      {
        this->threshold_.set (x);
      }

      const apd_map_type::threshold_unit_type& apd_map_type::
      threshold_unit () const
      {
        return this->threshold_unit_.get ();
      }

      const apd_map_type::threshold_unit_type& apd_map_type::
      threshold_unit_default_value ()
      {
        return threshold_unit_default_value_;
      }


      // upstrokes_map_type
      // 

      const upstrokes_map_type::threshold_type& upstrokes_map_type::
      threshold () const
      {
        return this->threshold_.get ();
      }

      upstrokes_map_type::threshold_type& upstrokes_map_type::
      threshold ()
      {
        return this->threshold_.get ();
      }

      void upstrokes_map_type::
      threshold (const threshold_type& x)
      {
        this->threshold_.set (x);
      }

      const upstrokes_map_type::threshold_unit_type& upstrokes_map_type::
      threshold_unit () const
      {
        return this->threshold_unit_.get ();
      }

      const upstrokes_map_type::threshold_unit_type& upstrokes_map_type::
      threshold_unit_default_value ()
      {
        return threshold_unit_default_value_;
      }


      // max_upstrokes_velocity_map_type
      // 

      const max_upstrokes_velocity_map_type::threshold_type& max_upstrokes_velocity_map_type::
      threshold () const
      {
        return this->threshold_.get ();
      }

      max_upstrokes_velocity_map_type::threshold_type& max_upstrokes_velocity_map_type::
      threshold ()
      {
        return this->threshold_.get ();
      }

      void max_upstrokes_velocity_map_type::
      threshold (const threshold_type& x)
      {
        this->threshold_.set (x);
      }

      const max_upstrokes_velocity_map_type::threshold_unit_type& max_upstrokes_velocity_map_type::
      threshold_unit () const
      {
        return this->threshold_unit_.get ();
      }

      const max_upstrokes_velocity_map_type::threshold_unit_type& max_upstrokes_velocity_map_type::
      threshold_unit_default_value ()
      {
        return threshold_unit_default_value_;
      }


      // conduction_velocity_map_type
      // 

      const conduction_velocity_map_type::origin_node_type& conduction_velocity_map_type::
      origin_node () const
      {
        return this->origin_node_.get ();
      }

      conduction_velocity_map_type::origin_node_type& conduction_velocity_map_type::
      origin_node ()
      {
        return this->origin_node_.get ();
      }

      void conduction_velocity_map_type::
      origin_node (const origin_node_type& x)
      {
        this->origin_node_.set (x);
      }


      // node_number_type
      // 

      const node_number_type::node_number_type1& node_number_type::
      node_number () const
      {
        return this->node_number_.get ();
      }

      node_number_type::node_number_type1& node_number_type::
      node_number ()
      {
        return this->node_number_.get ();
      }

      void node_number_type::
      node_number (const node_number_type1& x)
      {
        this->node_number_.set (x);
      }


      // media_type
      // 

      media_type::
      media_type (value v)
      : ::xml_schema::string (_xsd_media_type_literals_[v])
      {
      }

      media_type::
      media_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      media_type::
      media_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      media_type::
      media_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      media_type::
      media_type (const media_type& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      media_type& media_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_media_type_literals_[v]);

        return *this;
      }


      // point_type
      // 

      const point_type::x_type& point_type::
      x () const
      {
        return this->x_.get ();
      }

      point_type::x_type& point_type::
      x ()
      {
        return this->x_.get ();
      }

      void point_type::
      x (const x_type& x)
      {
        this->x_.set (x);
      }

      const point_type::y_type& point_type::
      y () const
      {
        return this->y_.get ();
      }

      point_type::y_type& point_type::
      y ()
      {
        return this->y_.get ();
      }

      void point_type::
      y (const y_type& x)
      {
        this->y_.set (x);
      }

      const point_type::z_type& point_type::
      z () const
      {
        return this->z_.get ();
      }

      point_type::z_type& point_type::
      z ()
      {
        return this->z_.get ();
      }

      void point_type::
      z (const z_type& x)
      {
        this->z_.set (x);
      }


      // box_type
      // 

      const box_type::LowerCoordinates_type& box_type::
      LowerCoordinates () const
      {
        return this->LowerCoordinates_.get ();
      }

      box_type::LowerCoordinates_type& box_type::
      LowerCoordinates ()
      {
        return this->LowerCoordinates_.get ();
      }

      void box_type::
      LowerCoordinates (const LowerCoordinates_type& x)
      {
        this->LowerCoordinates_.set (x);
      }

      void box_type::
      LowerCoordinates (::std::unique_ptr< LowerCoordinates_type > x)
      {
        this->LowerCoordinates_.set (std::move (x));
      }

      const box_type::UpperCoordinates_type& box_type::
      UpperCoordinates () const
      {
        return this->UpperCoordinates_.get ();
      }

      box_type::UpperCoordinates_type& box_type::
      UpperCoordinates ()
      {
        return this->UpperCoordinates_.get ();
      }

      void box_type::
      UpperCoordinates (const UpperCoordinates_type& x)
      {
        this->UpperCoordinates_.set (x);
      }

      void box_type::
      UpperCoordinates (::std::unique_ptr< UpperCoordinates_type > x)
      {
        this->UpperCoordinates_.set (std::move (x));
      }


      // ellipsoid_type
      // 

      const ellipsoid_type::Centre_type& ellipsoid_type::
      Centre () const
      {
        return this->Centre_.get ();
      }

      ellipsoid_type::Centre_type& ellipsoid_type::
      Centre ()
      {
        return this->Centre_.get ();
      }

      void ellipsoid_type::
      Centre (const Centre_type& x)
      {
        this->Centre_.set (x);
      }

      void ellipsoid_type::
      Centre (::std::unique_ptr< Centre_type > x)
      {
        this->Centre_.set (std::move (x));
      }

      const ellipsoid_type::Radii_type& ellipsoid_type::
      Radii () const
      {
        return this->Radii_.get ();
      }

      ellipsoid_type::Radii_type& ellipsoid_type::
      Radii ()
      {
        return this->Radii_.get ();
      }

      void ellipsoid_type::
      Radii (const Radii_type& x)
      {
        this->Radii_.set (x);
      }

      void ellipsoid_type::
      Radii (::std::unique_ptr< Radii_type > x)
      {
        this->Radii_.set (std::move (x));
      }


      // stimulus_type
      // 

      const stimulus_type::Strength_type& stimulus_type::
      Strength () const
      {
        return this->Strength_.get ();
      }

      stimulus_type::Strength_type& stimulus_type::
      Strength ()
      {
        return this->Strength_.get ();
      }

      void stimulus_type::
      Strength (const Strength_type& x)
      {
        this->Strength_.set (x);
      }

      void stimulus_type::
      Strength (::std::unique_ptr< Strength_type > x)
      {
        this->Strength_.set (std::move (x));
      }

      const stimulus_type::Duration_type& stimulus_type::
      Duration () const
      {
        return this->Duration_.get ();
      }

      stimulus_type::Duration_type& stimulus_type::
      Duration ()
      {
        return this->Duration_.get ();
      }

      void stimulus_type::
      Duration (const Duration_type& x)
      {
        this->Duration_.set (x);
      }

      void stimulus_type::
      Duration (::std::unique_ptr< Duration_type > x)
      {
        this->Duration_.set (std::move (x));
      }

      const stimulus_type::Delay_type& stimulus_type::
      Delay () const
      {
        return this->Delay_.get ();
      }

      stimulus_type::Delay_type& stimulus_type::
      Delay ()
      {
        return this->Delay_.get ();
      }

      void stimulus_type::
      Delay (const Delay_type& x)
      {
        this->Delay_.set (x);
      }

      void stimulus_type::
      Delay (::std::unique_ptr< Delay_type > x)
      {
        this->Delay_.set (std::move (x));
      }

      const stimulus_type::Period_optional& stimulus_type::
      Period () const
      {
        return this->Period_;
      }

      stimulus_type::Period_optional& stimulus_type::
      Period ()
      {
        return this->Period_;
      }

      void stimulus_type::
      Period (const Period_type& x)
      {
        this->Period_.set (x);
      }

      void stimulus_type::
      Period (const Period_optional& x)
      {
        this->Period_ = x;
      }

      void stimulus_type::
      Period (::std::unique_ptr< Period_type > x)
      {
        this->Period_.set (std::move (x));
      }

      const stimulus_type::StopTime_optional& stimulus_type::
      StopTime () const
      {
        return this->StopTime_;
      }

      stimulus_type::StopTime_optional& stimulus_type::
      StopTime ()
      {
        return this->StopTime_;
      }

      void stimulus_type::
      StopTime (const StopTime_type& x)
      {
        this->StopTime_.set (x);
      }

      void stimulus_type::
      StopTime (const StopTime_optional& x)
      {
        this->StopTime_ = x;
      }

      void stimulus_type::
      StopTime (::std::unique_ptr< StopTime_type > x)
      {
        this->StopTime_.set (std::move (x));
      }

      const stimulus_type::Location_type& stimulus_type::
      Location () const
      {
        return this->Location_.get ();
      }

      stimulus_type::Location_type& stimulus_type::
      Location ()
      {
        return this->Location_.get ();
      }

      void stimulus_type::
      Location (const Location_type& x)
      {
        this->Location_.set (x);
      }

      void stimulus_type::
      Location (::std::unique_ptr< Location_type > x)
      {
        this->Location_.set (std::move (x));
      }


      // set_parameter_type
      // 

      const set_parameter_type::name_type& set_parameter_type::
      name () const
      {
        return this->name_.get ();
      }

      set_parameter_type::name_type& set_parameter_type::
      name ()
      {
        return this->name_.get ();
      }

      void set_parameter_type::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void set_parameter_type::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const set_parameter_type::value_type& set_parameter_type::
      value () const
      {
        return this->value_.get ();
      }

      set_parameter_type::value_type& set_parameter_type::
      value ()
      {
        return this->value_.get ();
      }

      void set_parameter_type::
      value (const value_type& x)
      {
        this->value_.set (x);
      }


      // electrodes_type
      // 

      const electrodes_type::GroundSecondElectrode_type& electrodes_type::
      GroundSecondElectrode () const
      {
        return this->GroundSecondElectrode_.get ();
      }

      electrodes_type::GroundSecondElectrode_type& electrodes_type::
      GroundSecondElectrode ()
      {
        return this->GroundSecondElectrode_.get ();
      }

      void electrodes_type::
      GroundSecondElectrode (const GroundSecondElectrode_type& x)
      {
        this->GroundSecondElectrode_.set (x);
      }

      void electrodes_type::
      GroundSecondElectrode (::std::unique_ptr< GroundSecondElectrode_type > x)
      {
        this->GroundSecondElectrode_.set (std::move (x));
      }

      const electrodes_type::PerpendicularToAxis_type& electrodes_type::
      PerpendicularToAxis () const
      {
        return this->PerpendicularToAxis_.get ();
      }

      electrodes_type::PerpendicularToAxis_type& electrodes_type::
      PerpendicularToAxis ()
      {
        return this->PerpendicularToAxis_.get ();
      }

      void electrodes_type::
      PerpendicularToAxis (const PerpendicularToAxis_type& x)
      {
        this->PerpendicularToAxis_.set (x);
      }

      void electrodes_type::
      PerpendicularToAxis (::std::unique_ptr< PerpendicularToAxis_type > x)
      {
        this->PerpendicularToAxis_.set (std::move (x));
      }

      const electrodes_type::Strength_type& electrodes_type::
      Strength () const
      {
        return this->Strength_.get ();
      }

      electrodes_type::Strength_type& electrodes_type::
      Strength ()
      {
        return this->Strength_.get ();
      }

      void electrodes_type::
      Strength (const Strength_type& x)
      {
        this->Strength_.set (x);
      }

      void electrodes_type::
      Strength (::std::unique_ptr< Strength_type > x)
      {
        this->Strength_.set (std::move (x));
      }

      const electrodes_type::StartTime_type& electrodes_type::
      StartTime () const
      {
        return this->StartTime_.get ();
      }

      electrodes_type::StartTime_type& electrodes_type::
      StartTime ()
      {
        return this->StartTime_.get ();
      }

      void electrodes_type::
      StartTime (const StartTime_type& x)
      {
        this->StartTime_.set (x);
      }

      void electrodes_type::
      StartTime (::std::unique_ptr< StartTime_type > x)
      {
        this->StartTime_.set (std::move (x));
      }

      const electrodes_type::Duration_type& electrodes_type::
      Duration () const
      {
        return this->Duration_.get ();
      }

      electrodes_type::Duration_type& electrodes_type::
      Duration ()
      {
        return this->Duration_.get ();
      }

      void electrodes_type::
      Duration (const Duration_type& x)
      {
        this->Duration_.set (x);
      }

      void electrodes_type::
      Duration (::std::unique_ptr< Duration_type > x)
      {
        this->Duration_.set (std::move (x));
      }


      // cell_heterogeneity_type
      // 

      const cell_heterogeneity_type::ScaleFactorGks_optional& cell_heterogeneity_type::
      ScaleFactorGks () const
      {
        return this->ScaleFactorGks_;
      }

      cell_heterogeneity_type::ScaleFactorGks_optional& cell_heterogeneity_type::
      ScaleFactorGks ()
      {
        return this->ScaleFactorGks_;
      }

      void cell_heterogeneity_type::
      ScaleFactorGks (const ScaleFactorGks_type& x)
      {
        this->ScaleFactorGks_.set (x);
      }

      void cell_heterogeneity_type::
      ScaleFactorGks (const ScaleFactorGks_optional& x)
      {
        this->ScaleFactorGks_ = x;
      }

      void cell_heterogeneity_type::
      ScaleFactorGks (::std::unique_ptr< ScaleFactorGks_type > x)
      {
        this->ScaleFactorGks_.set (std::move (x));
      }

      const cell_heterogeneity_type::ScaleFactorIto_optional& cell_heterogeneity_type::
      ScaleFactorIto () const
      {
        return this->ScaleFactorIto_;
      }

      cell_heterogeneity_type::ScaleFactorIto_optional& cell_heterogeneity_type::
      ScaleFactorIto ()
      {
        return this->ScaleFactorIto_;
      }

      void cell_heterogeneity_type::
      ScaleFactorIto (const ScaleFactorIto_type& x)
      {
        this->ScaleFactorIto_.set (x);
      }

      void cell_heterogeneity_type::
      ScaleFactorIto (const ScaleFactorIto_optional& x)
      {
        this->ScaleFactorIto_ = x;
      }

      void cell_heterogeneity_type::
      ScaleFactorIto (::std::unique_ptr< ScaleFactorIto_type > x)
      {
        this->ScaleFactorIto_.set (std::move (x));
      }

      const cell_heterogeneity_type::ScaleFactorGkr_optional& cell_heterogeneity_type::
      ScaleFactorGkr () const
      {
        return this->ScaleFactorGkr_;
      }

      cell_heterogeneity_type::ScaleFactorGkr_optional& cell_heterogeneity_type::
      ScaleFactorGkr ()
      {
        return this->ScaleFactorGkr_;
      }

      void cell_heterogeneity_type::
      ScaleFactorGkr (const ScaleFactorGkr_type& x)
      {
        this->ScaleFactorGkr_.set (x);
      }

      void cell_heterogeneity_type::
      ScaleFactorGkr (const ScaleFactorGkr_optional& x)
      {
        this->ScaleFactorGkr_ = x;
      }

      void cell_heterogeneity_type::
      ScaleFactorGkr (::std::unique_ptr< ScaleFactorGkr_type > x)
      {
        this->ScaleFactorGkr_.set (std::move (x));
      }

      const cell_heterogeneity_type::Location_type& cell_heterogeneity_type::
      Location () const
      {
        return this->Location_.get ();
      }

      cell_heterogeneity_type::Location_type& cell_heterogeneity_type::
      Location ()
      {
        return this->Location_.get ();
      }

      void cell_heterogeneity_type::
      Location (const Location_type& x)
      {
        this->Location_.set (x);
      }

      void cell_heterogeneity_type::
      Location (::std::unique_ptr< Location_type > x)
      {
        this->Location_.set (std::move (x));
      }

      const cell_heterogeneity_type::SetParameter_sequence& cell_heterogeneity_type::
      SetParameter () const
      {
        return this->SetParameter_;
      }

      cell_heterogeneity_type::SetParameter_sequence& cell_heterogeneity_type::
      SetParameter ()
      {
        return this->SetParameter_;
      }

      void cell_heterogeneity_type::
      SetParameter (const SetParameter_sequence& s)
      {
        this->SetParameter_ = s;
      }


      // conductivity_heterogeneity_type
      // 

      const conductivity_heterogeneity_type::IntracellularConductivities_optional& conductivity_heterogeneity_type::
      IntracellularConductivities () const
      {
        return this->IntracellularConductivities_;
      }

      conductivity_heterogeneity_type::IntracellularConductivities_optional& conductivity_heterogeneity_type::
      IntracellularConductivities ()
      {
        return this->IntracellularConductivities_;
      }

      void conductivity_heterogeneity_type::
      IntracellularConductivities (const IntracellularConductivities_type& x)
      {
        this->IntracellularConductivities_.set (x);
      }

      void conductivity_heterogeneity_type::
      IntracellularConductivities (const IntracellularConductivities_optional& x)
      {
        this->IntracellularConductivities_ = x;
      }

      void conductivity_heterogeneity_type::
      IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > x)
      {
        this->IntracellularConductivities_.set (std::move (x));
      }

      const conductivity_heterogeneity_type::ExtracellularConductivities_optional& conductivity_heterogeneity_type::
      ExtracellularConductivities () const
      {
        return this->ExtracellularConductivities_;
      }

      conductivity_heterogeneity_type::ExtracellularConductivities_optional& conductivity_heterogeneity_type::
      ExtracellularConductivities ()
      {
        return this->ExtracellularConductivities_;
      }

      void conductivity_heterogeneity_type::
      ExtracellularConductivities (const ExtracellularConductivities_type& x)
      {
        this->ExtracellularConductivities_.set (x);
      }

      void conductivity_heterogeneity_type::
      ExtracellularConductivities (const ExtracellularConductivities_optional& x)
      {
        this->ExtracellularConductivities_ = x;
      }

      void conductivity_heterogeneity_type::
      ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > x)
      {
        this->ExtracellularConductivities_.set (std::move (x));
      }

      const conductivity_heterogeneity_type::Location_type& conductivity_heterogeneity_type::
      Location () const
      {
        return this->Location_.get ();
      }

      conductivity_heterogeneity_type::Location_type& conductivity_heterogeneity_type::
      Location ()
      {
        return this->Location_.get ();
      }

      void conductivity_heterogeneity_type::
      Location (const Location_type& x)
      {
        this->Location_.set (x);
      }

      void conductivity_heterogeneity_type::
      Location (::std::unique_ptr< Location_type > x)
      {
        this->Location_.set (std::move (x));
      }


      // slab_type
      // 

      const slab_type::x_type& slab_type::
      x () const
      {
        return this->x_.get ();
      }

      slab_type::x_type& slab_type::
      x ()
      {
        return this->x_.get ();
      }

      void slab_type::
      x (const x_type& x)
      {
        this->x_.set (x);
      }

      const slab_type::y_type& slab_type::
      y () const
      {
        return this->y_.get ();
      }

      slab_type::y_type& slab_type::
      y ()
      {
        return this->y_.get ();
      }

      void slab_type::
      y (const y_type& x)
      {
        this->y_.set (x);
      }

      const slab_type::z_type& slab_type::
      z () const
      {
        return this->z_.get ();
      }

      slab_type::z_type& slab_type::
      z ()
      {
        return this->z_.get ();
      }

      void slab_type::
      z (const z_type& x)
      {
        this->z_.set (x);
      }

      const slab_type::inter_node_space_type& slab_type::
      inter_node_space () const
      {
        return this->inter_node_space_.get ();
      }

      slab_type::inter_node_space_type& slab_type::
      inter_node_space ()
      {
        return this->inter_node_space_.get ();
      }

      void slab_type::
      inter_node_space (const inter_node_space_type& x)
      {
        this->inter_node_space_.set (x);
      }


      // sheet_type
      // 

      const sheet_type::x_type& sheet_type::
      x () const
      {
        return this->x_.get ();
      }

      sheet_type::x_type& sheet_type::
      x ()
      {
        return this->x_.get ();
      }

      void sheet_type::
      x (const x_type& x)
      {
        this->x_.set (x);
      }

      const sheet_type::y_type& sheet_type::
      y () const
      {
        return this->y_.get ();
      }

      sheet_type::y_type& sheet_type::
      y ()
      {
        return this->y_.get ();
      }

      void sheet_type::
      y (const y_type& x)
      {
        this->y_.set (x);
      }

      const sheet_type::inter_node_space_type& sheet_type::
      inter_node_space () const
      {
        return this->inter_node_space_.get ();
      }

      sheet_type::inter_node_space_type& sheet_type::
      inter_node_space ()
      {
        return this->inter_node_space_.get ();
      }

      void sheet_type::
      inter_node_space (const inter_node_space_type& x)
      {
        this->inter_node_space_.set (x);
      }


      // fibre_type
      // 

      const fibre_type::x_type& fibre_type::
      x () const
      {
        return this->x_.get ();
      }

      fibre_type::x_type& fibre_type::
      x ()
      {
        return this->x_.get ();
      }

      void fibre_type::
      x (const x_type& x)
      {
        this->x_.set (x);
      }

      const fibre_type::inter_node_space_type& fibre_type::
      inter_node_space () const
      {
        return this->inter_node_space_.get ();
      }

      fibre_type::inter_node_space_type& fibre_type::
      inter_node_space ()
      {
        return this->inter_node_space_.get ();
      }

      void fibre_type::
      inter_node_space (const inter_node_space_type& x)
      {
        this->inter_node_space_.set (x);
      }


      // load_mesh_type
      // 

      const load_mesh_type::name_type& load_mesh_type::
      name () const
      {
        return this->name_.get ();
      }

      load_mesh_type::name_type& load_mesh_type::
      name ()
      {
        return this->name_.get ();
      }

      void load_mesh_type::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void load_mesh_type::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const load_mesh_type::conductivity_media_type& load_mesh_type::
      conductivity_media () const
      {
        return this->conductivity_media_.get ();
      }

      load_mesh_type::conductivity_media_type& load_mesh_type::
      conductivity_media ()
      {
        return this->conductivity_media_.get ();
      }

      void load_mesh_type::
      conductivity_media (const conductivity_media_type& x)
      {
        this->conductivity_media_.set (x);
      }

      void load_mesh_type::
      conductivity_media (::std::unique_ptr< conductivity_media_type > x)
      {
        this->conductivity_media_.set (std::move (x));
      }


      // mesh_type
      // 

      const mesh_type::Slab_optional& mesh_type::
      Slab () const
      {
        return this->Slab_;
      }

      mesh_type::Slab_optional& mesh_type::
      Slab ()
      {
        return this->Slab_;
      }

      void mesh_type::
      Slab (const Slab_type& x)
      {
        this->Slab_.set (x);
      }

      void mesh_type::
      Slab (const Slab_optional& x)
      {
        this->Slab_ = x;
      }

      void mesh_type::
      Slab (::std::unique_ptr< Slab_type > x)
      {
        this->Slab_.set (std::move (x));
      }

      const mesh_type::Sheet_optional& mesh_type::
      Sheet () const
      {
        return this->Sheet_;
      }

      mesh_type::Sheet_optional& mesh_type::
      Sheet ()
      {
        return this->Sheet_;
      }

      void mesh_type::
      Sheet (const Sheet_type& x)
      {
        this->Sheet_.set (x);
      }

      void mesh_type::
      Sheet (const Sheet_optional& x)
      {
        this->Sheet_ = x;
      }

      void mesh_type::
      Sheet (::std::unique_ptr< Sheet_type > x)
      {
        this->Sheet_.set (std::move (x));
      }

      const mesh_type::Fibre_optional& mesh_type::
      Fibre () const
      {
        return this->Fibre_;
      }

      mesh_type::Fibre_optional& mesh_type::
      Fibre ()
      {
        return this->Fibre_;
      }

      void mesh_type::
      Fibre (const Fibre_type& x)
      {
        this->Fibre_.set (x);
      }

      void mesh_type::
      Fibre (const Fibre_optional& x)
      {
        this->Fibre_ = x;
      }

      void mesh_type::
      Fibre (::std::unique_ptr< Fibre_type > x)
      {
        this->Fibre_.set (std::move (x));
      }

      const mesh_type::LoadMesh_optional& mesh_type::
      LoadMesh () const
      {
        return this->LoadMesh_;
      }

      mesh_type::LoadMesh_optional& mesh_type::
      LoadMesh ()
      {
        return this->LoadMesh_;
      }

      void mesh_type::
      LoadMesh (const LoadMesh_type& x)
      {
        this->LoadMesh_.set (x);
      }

      void mesh_type::
      LoadMesh (const LoadMesh_optional& x)
      {
        this->LoadMesh_ = x;
      }

      void mesh_type::
      LoadMesh (::std::unique_ptr< LoadMesh_type > x)
      {
        this->LoadMesh_.set (std::move (x));
      }

      const mesh_type::unit_type& mesh_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const mesh_type::unit_type& mesh_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // conductivities_type
      // 

      const conductivities_type::longi_type& conductivities_type::
      longi () const
      {
        return this->longi_.get ();
      }

      conductivities_type::longi_type& conductivities_type::
      longi ()
      {
        return this->longi_.get ();
      }

      void conductivities_type::
      longi (const longi_type& x)
      {
        this->longi_.set (x);
      }

      const conductivities_type::trans_type& conductivities_type::
      trans () const
      {
        return this->trans_.get ();
      }

      conductivities_type::trans_type& conductivities_type::
      trans ()
      {
        return this->trans_.get ();
      }

      void conductivities_type::
      trans (const trans_type& x)
      {
        this->trans_.set (x);
      }

      const conductivities_type::normal_type& conductivities_type::
      normal () const
      {
        return this->normal_.get ();
      }

      conductivities_type::normal_type& conductivities_type::
      normal ()
      {
        return this->normal_.get ();
      }

      void conductivities_type::
      normal (const normal_type& x)
      {
        this->normal_.set (x);
      }

      const conductivities_type::unit_type& conductivities_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const conductivities_type::unit_type& conductivities_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // var_type
      // 

      const var_type::name_type& var_type::
      name () const
      {
        return this->name_.get ();
      }

      var_type::name_type& var_type::
      name ()
      {
        return this->name_.get ();
      }

      void var_type::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void var_type::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }


      // output_variables_type
      // 

      const output_variables_type::Var_sequence& output_variables_type::
      Var () const
      {
        return this->Var_;
      }

      output_variables_type::Var_sequence& output_variables_type::
      Var ()
      {
        return this->Var_;
      }

      void output_variables_type::
      Var (const Var_sequence& s)
      {
        this->Var_ = s;
      }


      // yesno_type
      // 

      yesno_type::
      yesno_type (value v)
      : ::xml_schema::string (_xsd_yesno_type_literals_[v])
      {
      }

      yesno_type::
      yesno_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      yesno_type::
      yesno_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      yesno_type::
      yesno_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      yesno_type::
      yesno_type (const yesno_type& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      yesno_type& yesno_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_yesno_type_literals_[v]);

        return *this;
      }


      // output_visualizer_type
      // 

      const output_visualizer_type::meshalyzer_type& output_visualizer_type::
      meshalyzer () const
      {
        return this->meshalyzer_.get ();
      }

      output_visualizer_type::meshalyzer_type& output_visualizer_type::
      meshalyzer ()
      {
        return this->meshalyzer_.get ();
      }

      void output_visualizer_type::
      meshalyzer (const meshalyzer_type& x)
      {
        this->meshalyzer_.set (x);
      }

      void output_visualizer_type::
      meshalyzer (::std::unique_ptr< meshalyzer_type > x)
      {
        this->meshalyzer_.set (std::move (x));
      }

      const output_visualizer_type::meshalyzer_type& output_visualizer_type::
      meshalyzer_default_value ()
      {
        return meshalyzer_default_value_;
      }

      const output_visualizer_type::cmgui_type& output_visualizer_type::
      cmgui () const
      {
        return this->cmgui_.get ();
      }

      output_visualizer_type::cmgui_type& output_visualizer_type::
      cmgui ()
      {
        return this->cmgui_.get ();
      }

      void output_visualizer_type::
      cmgui (const cmgui_type& x)
      {
        this->cmgui_.set (x);
      }

      void output_visualizer_type::
      cmgui (::std::unique_ptr< cmgui_type > x)
      {
        this->cmgui_.set (std::move (x));
      }

      const output_visualizer_type::cmgui_type& output_visualizer_type::
      cmgui_default_value ()
      {
        return cmgui_default_value_;
      }

      const output_visualizer_type::vtk_type& output_visualizer_type::
      vtk () const
      {
        return this->vtk_.get ();
      }

      output_visualizer_type::vtk_type& output_visualizer_type::
      vtk ()
      {
        return this->vtk_.get ();
      }

      void output_visualizer_type::
      vtk (const vtk_type& x)
      {
        this->vtk_.set (x);
      }

      void output_visualizer_type::
      vtk (::std::unique_ptr< vtk_type > x)
      {
        this->vtk_.set (std::move (x));
      }

      const output_visualizer_type::vtk_type& output_visualizer_type::
      vtk_default_value ()
      {
        return vtk_default_value_;
      }

      const output_visualizer_type::parallel_vtk_type& output_visualizer_type::
      parallel_vtk () const
      {
        return this->parallel_vtk_.get ();
      }

      output_visualizer_type::parallel_vtk_type& output_visualizer_type::
      parallel_vtk ()
      {
        return this->parallel_vtk_.get ();
      }

      void output_visualizer_type::
      parallel_vtk (const parallel_vtk_type& x)
      {
        this->parallel_vtk_.set (x);
      }

      void output_visualizer_type::
      parallel_vtk (::std::unique_ptr< parallel_vtk_type > x)
      {
        this->parallel_vtk_.set (std::move (x));
      }

      const output_visualizer_type::parallel_vtk_type& output_visualizer_type::
      parallel_vtk_default_value ()
      {
        return parallel_vtk_default_value_;
      }

      const output_visualizer_type::precision_type& output_visualizer_type::
      precision () const
      {
        return this->precision_.get ();
      }

      output_visualizer_type::precision_type& output_visualizer_type::
      precision ()
      {
        return this->precision_.get ();
      }

      void output_visualizer_type::
      precision (const precision_type& x)
      {
        this->precision_.set (x);
      }

      output_visualizer_type::precision_type output_visualizer_type::
      precision_default_value ()
      {
        return precision_type (0ULL);
      }


      // time_steps_type
      // 

      const time_steps_type::ode_type& time_steps_type::
      ode () const
      {
        return this->ode_.get ();
      }

      time_steps_type::ode_type& time_steps_type::
      ode ()
      {
        return this->ode_.get ();
      }

      void time_steps_type::
      ode (const ode_type& x)
      {
        this->ode_.set (x);
      }

      const time_steps_type::pde_type& time_steps_type::
      pde () const
      {
        return this->pde_.get ();
      }

      time_steps_type::pde_type& time_steps_type::
      pde ()
      {
        return this->pde_.get ();
      }

      void time_steps_type::
      pde (const pde_type& x)
      {
        this->pde_.set (x);
      }

      const time_steps_type::printing_type& time_steps_type::
      printing () const
      {
        return this->printing_.get ();
      }

      time_steps_type::printing_type& time_steps_type::
      printing ()
      {
        return this->printing_.get ();
      }

      void time_steps_type::
      printing (const printing_type& x)
      {
        this->printing_.set (x);
      }

      const time_steps_type::unit_type& time_steps_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const time_steps_type::unit_type& time_steps_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // ksp_tolerances_type
      // 

      const ksp_tolerances_type::KSPRelative_optional& ksp_tolerances_type::
      KSPRelative () const
      {
        return this->KSPRelative_;
      }

      ksp_tolerances_type::KSPRelative_optional& ksp_tolerances_type::
      KSPRelative ()
      {
        return this->KSPRelative_;
      }

      void ksp_tolerances_type::
      KSPRelative (const KSPRelative_type& x)
      {
        this->KSPRelative_.set (x);
      }

      void ksp_tolerances_type::
      KSPRelative (const KSPRelative_optional& x)
      {
        this->KSPRelative_ = x;
      }

      const ksp_tolerances_type::KSPAbsolute_optional& ksp_tolerances_type::
      KSPAbsolute () const
      {
        return this->KSPAbsolute_;
      }

      ksp_tolerances_type::KSPAbsolute_optional& ksp_tolerances_type::
      KSPAbsolute ()
      {
        return this->KSPAbsolute_;
      }

      void ksp_tolerances_type::
      KSPAbsolute (const KSPAbsolute_type& x)
      {
        this->KSPAbsolute_.set (x);
      }

      void ksp_tolerances_type::
      KSPAbsolute (const KSPAbsolute_optional& x)
      {
        this->KSPAbsolute_ = x;
      }


      // ksp_solver_type
      // 

      ksp_solver_type::
      ksp_solver_type (value v)
      : ::xml_schema::string (_xsd_ksp_solver_type_literals_[v])
      {
      }

      ksp_solver_type::
      ksp_solver_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      ksp_solver_type::
      ksp_solver_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      ksp_solver_type::
      ksp_solver_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      ksp_solver_type::
      ksp_solver_type (const ksp_solver_type& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      ksp_solver_type& ksp_solver_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_ksp_solver_type_literals_[v]);

        return *this;
      }


      // ksp_preconditioner_type
      // 

      ksp_preconditioner_type::
      ksp_preconditioner_type (value v)
      : ::xml_schema::string (_xsd_ksp_preconditioner_type_literals_[v])
      {
      }

      ksp_preconditioner_type::
      ksp_preconditioner_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      ksp_preconditioner_type::
      ksp_preconditioner_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      ksp_preconditioner_type::
      ksp_preconditioner_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      ksp_preconditioner_type::
      ksp_preconditioner_type (const ksp_preconditioner_type& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      ksp_preconditioner_type& ksp_preconditioner_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_ksp_preconditioner_type_literals_[v]);

        return *this;
      }


      // mesh_partitioning_type
      // 

      mesh_partitioning_type::
      mesh_partitioning_type (value v)
      : ::xml_schema::string (_xsd_mesh_partitioning_type_literals_[v])
      {
      }

      mesh_partitioning_type::
      mesh_partitioning_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      mesh_partitioning_type::
      mesh_partitioning_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      mesh_partitioning_type::
      mesh_partitioning_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      mesh_partitioning_type::
      mesh_partitioning_type (const mesh_partitioning_type& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      mesh_partitioning_type& mesh_partitioning_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_mesh_partitioning_type_literals_[v]);

        return *this;
      }


      // checkpoint_type
      // 

      const checkpoint_type::timestep_type& checkpoint_type::
      timestep () const
      {
        return this->timestep_.get ();
      }

      checkpoint_type::timestep_type& checkpoint_type::
      timestep ()
      {
        return this->timestep_.get ();
      }

      void checkpoint_type::
      timestep (const timestep_type& x)
      {
        this->timestep_.set (x);
      }

      const checkpoint_type::max_checkpoints_on_disk_type& checkpoint_type::
      max_checkpoints_on_disk () const
      {
        return this->max_checkpoints_on_disk_.get ();
      }

      checkpoint_type::max_checkpoints_on_disk_type& checkpoint_type::
      max_checkpoints_on_disk ()
      {
        return this->max_checkpoints_on_disk_.get ();
      }

      void checkpoint_type::
      max_checkpoints_on_disk (const max_checkpoints_on_disk_type& x)
      {
        this->max_checkpoints_on_disk_.set (x);
      }

      const checkpoint_type::unit_type& checkpoint_type::
      unit () const
      {
        return this->unit_.get ();
      }

      const checkpoint_type::unit_type& checkpoint_type::
      unit_default_value ()
      {
        return unit_default_value_;
      }


      // adaptivity_parameters_type
      // 

      const adaptivity_parameters_type::target_error_type& adaptivity_parameters_type::
      target_error () const
      {
        return this->target_error_.get ();
      }

      adaptivity_parameters_type::target_error_type& adaptivity_parameters_type::
      target_error ()
      {
        return this->target_error_.get ();
      }

      void adaptivity_parameters_type::
      target_error (const target_error_type& x)
      {
        this->target_error_.set (x);
      }

      const adaptivity_parameters_type::sigma_type& adaptivity_parameters_type::
      sigma () const
      {
        return this->sigma_.get ();
      }

      adaptivity_parameters_type::sigma_type& adaptivity_parameters_type::
      sigma ()
      {
        return this->sigma_.get ();
      }

      void adaptivity_parameters_type::
      sigma (const sigma_type& x)
      {
        this->sigma_.set (x);
      }

      const adaptivity_parameters_type::max_edge_length_type& adaptivity_parameters_type::
      max_edge_length () const
      {
        return this->max_edge_length_.get ();
      }

      adaptivity_parameters_type::max_edge_length_type& adaptivity_parameters_type::
      max_edge_length ()
      {
        return this->max_edge_length_.get ();
      }

      void adaptivity_parameters_type::
      max_edge_length (const max_edge_length_type& x)
      {
        this->max_edge_length_.set (x);
      }

      const adaptivity_parameters_type::min_edge_length_type& adaptivity_parameters_type::
      min_edge_length () const
      {
        return this->min_edge_length_.get ();
      }

      adaptivity_parameters_type::min_edge_length_type& adaptivity_parameters_type::
      min_edge_length ()
      {
        return this->min_edge_length_.get ();
      }

      void adaptivity_parameters_type::
      min_edge_length (const min_edge_length_type& x)
      {
        this->min_edge_length_.set (x);
      }

      const adaptivity_parameters_type::gradation_type& adaptivity_parameters_type::
      gradation () const
      {
        return this->gradation_.get ();
      }

      adaptivity_parameters_type::gradation_type& adaptivity_parameters_type::
      gradation ()
      {
        return this->gradation_.get ();
      }

      void adaptivity_parameters_type::
      gradation (const gradation_type& x)
      {
        this->gradation_.set (x);
      }

      const adaptivity_parameters_type::max_nodes_type& adaptivity_parameters_type::
      max_nodes () const
      {
        return this->max_nodes_.get ();
      }

      adaptivity_parameters_type::max_nodes_type& adaptivity_parameters_type::
      max_nodes ()
      {
        return this->max_nodes_.get ();
      }

      void adaptivity_parameters_type::
      max_nodes (const max_nodes_type& x)
      {
        this->max_nodes_.set (x);
      }

      const adaptivity_parameters_type::num_sweeps_type& adaptivity_parameters_type::
      num_sweeps () const
      {
        return this->num_sweeps_.get ();
      }

      adaptivity_parameters_type::num_sweeps_type& adaptivity_parameters_type::
      num_sweeps ()
      {
        return this->num_sweeps_.get ();
      }

      void adaptivity_parameters_type::
      num_sweeps (const num_sweeps_type& x)
      {
        this->num_sweeps_.set (x);
      }


      // cell_heterogeneities_type
      // 

      const cell_heterogeneities_type::CellHeterogeneity_sequence& cell_heterogeneities_type::
      CellHeterogeneity () const
      {
        return this->CellHeterogeneity_;
      }

      cell_heterogeneities_type::CellHeterogeneity_sequence& cell_heterogeneities_type::
      CellHeterogeneity ()
      {
        return this->CellHeterogeneity_;
      }

      void cell_heterogeneities_type::
      CellHeterogeneity (const CellHeterogeneity_sequence& s)
      {
        this->CellHeterogeneity_ = s;
      }


      // stimuli_type
      // 

      const stimuli_type::Stimulus_sequence& stimuli_type::
      Stimulus () const
      {
        return this->Stimulus_;
      }

      stimuli_type::Stimulus_sequence& stimuli_type::
      Stimulus ()
      {
        return this->Stimulus_;
      }

      void stimuli_type::
      Stimulus (const Stimulus_sequence& s)
      {
        this->Stimulus_ = s;
      }


      // simulation_type
      // 

      const simulation_type::SpaceDimension_optional& simulation_type::
      SpaceDimension () const
      {
        return this->SpaceDimension_;
      }

      simulation_type::SpaceDimension_optional& simulation_type::
      SpaceDimension ()
      {
        return this->SpaceDimension_;
      }

      void simulation_type::
      SpaceDimension (const SpaceDimension_type& x)
      {
        this->SpaceDimension_.set (x);
      }

      void simulation_type::
      SpaceDimension (const SpaceDimension_optional& x)
      {
        this->SpaceDimension_ = x;
      }

      const simulation_type::SimulationDuration_optional& simulation_type::
      SimulationDuration () const
      {
        return this->SimulationDuration_;
      }

      simulation_type::SimulationDuration_optional& simulation_type::
      SimulationDuration ()
      {
        return this->SimulationDuration_;
      }

      void simulation_type::
      SimulationDuration (const SimulationDuration_type& x)
      {
        this->SimulationDuration_.set (x);
      }

      void simulation_type::
      SimulationDuration (const SimulationDuration_optional& x)
      {
        this->SimulationDuration_ = x;
      }

      void simulation_type::
      SimulationDuration (::std::unique_ptr< SimulationDuration_type > x)
      {
        this->SimulationDuration_.set (std::move (x));
      }

      const simulation_type::Domain_optional& simulation_type::
      Domain () const
      {
        return this->Domain_;
      }

      simulation_type::Domain_optional& simulation_type::
      Domain ()
      {
        return this->Domain_;
      }

      void simulation_type::
      Domain (const Domain_type& x)
      {
        this->Domain_.set (x);
      }

      void simulation_type::
      Domain (const Domain_optional& x)
      {
        this->Domain_ = x;
      }

      void simulation_type::
      Domain (::std::unique_ptr< Domain_type > x)
      {
        this->Domain_.set (std::move (x));
      }

      const simulation_type::Purkinje_optional& simulation_type::
      Purkinje () const
      {
        return this->Purkinje_;
      }

      simulation_type::Purkinje_optional& simulation_type::
      Purkinje ()
      {
        return this->Purkinje_;
      }

      void simulation_type::
      Purkinje (const Purkinje_type& x)
      {
        this->Purkinje_.set (x);
      }

      void simulation_type::
      Purkinje (const Purkinje_optional& x)
      {
        this->Purkinje_ = x;
      }

      void simulation_type::
      Purkinje (::std::unique_ptr< Purkinje_type > x)
      {
        this->Purkinje_.set (std::move (x));
      }

      const simulation_type::Mesh_optional& simulation_type::
      Mesh () const
      {
        return this->Mesh_;
      }

      simulation_type::Mesh_optional& simulation_type::
      Mesh ()
      {
        return this->Mesh_;
      }

      void simulation_type::
      Mesh (const Mesh_type& x)
      {
        this->Mesh_.set (x);
      }

      void simulation_type::
      Mesh (const Mesh_optional& x)
      {
        this->Mesh_ = x;
      }

      void simulation_type::
      Mesh (::std::unique_ptr< Mesh_type > x)
      {
        this->Mesh_.set (std::move (x));
      }

      const simulation_type::IonicModels_optional& simulation_type::
      IonicModels () const
      {
        return this->IonicModels_;
      }

      simulation_type::IonicModels_optional& simulation_type::
      IonicModels ()
      {
        return this->IonicModels_;
      }

      void simulation_type::
      IonicModels (const IonicModels_type& x)
      {
        this->IonicModels_.set (x);
      }

      void simulation_type::
      IonicModels (const IonicModels_optional& x)
      {
        this->IonicModels_ = x;
      }

      void simulation_type::
      IonicModels (::std::unique_ptr< IonicModels_type > x)
      {
        this->IonicModels_.set (std::move (x));
      }

      const simulation_type::Stimuli_optional& simulation_type::
      Stimuli () const
      {
        return this->Stimuli_;
      }

      simulation_type::Stimuli_optional& simulation_type::
      Stimuli ()
      {
        return this->Stimuli_;
      }

      void simulation_type::
      Stimuli (const Stimuli_type& x)
      {
        this->Stimuli_.set (x);
      }

      void simulation_type::
      Stimuli (const Stimuli_optional& x)
      {
        this->Stimuli_ = x;
      }

      void simulation_type::
      Stimuli (::std::unique_ptr< Stimuli_type > x)
      {
        this->Stimuli_.set (std::move (x));
      }

      const simulation_type::Electrodes_optional& simulation_type::
      Electrodes () const
      {
        return this->Electrodes_;
      }

      simulation_type::Electrodes_optional& simulation_type::
      Electrodes ()
      {
        return this->Electrodes_;
      }

      void simulation_type::
      Electrodes (const Electrodes_type& x)
      {
        this->Electrodes_.set (x);
      }

      void simulation_type::
      Electrodes (const Electrodes_optional& x)
      {
        this->Electrodes_ = x;
      }

      void simulation_type::
      Electrodes (::std::unique_ptr< Electrodes_type > x)
      {
        this->Electrodes_.set (std::move (x));
      }

      const simulation_type::CellHeterogeneities_optional& simulation_type::
      CellHeterogeneities () const
      {
        return this->CellHeterogeneities_;
      }

      simulation_type::CellHeterogeneities_optional& simulation_type::
      CellHeterogeneities ()
      {
        return this->CellHeterogeneities_;
      }

      void simulation_type::
      CellHeterogeneities (const CellHeterogeneities_type& x)
      {
        this->CellHeterogeneities_.set (x);
      }

      void simulation_type::
      CellHeterogeneities (const CellHeterogeneities_optional& x)
      {
        this->CellHeterogeneities_ = x;
      }

      void simulation_type::
      CellHeterogeneities (::std::unique_ptr< CellHeterogeneities_type > x)
      {
        this->CellHeterogeneities_.set (std::move (x));
      }

      const simulation_type::OutputDirectory_optional& simulation_type::
      OutputDirectory () const
      {
        return this->OutputDirectory_;
      }

      simulation_type::OutputDirectory_optional& simulation_type::
      OutputDirectory ()
      {
        return this->OutputDirectory_;
      }

      void simulation_type::
      OutputDirectory (const OutputDirectory_type& x)
      {
        this->OutputDirectory_.set (x);
      }

      void simulation_type::
      OutputDirectory (const OutputDirectory_optional& x)
      {
        this->OutputDirectory_ = x;
      }

      void simulation_type::
      OutputDirectory (::std::unique_ptr< OutputDirectory_type > x)
      {
        this->OutputDirectory_.set (std::move (x));
      }

      const simulation_type::OutputFilenamePrefix_optional& simulation_type::
      OutputFilenamePrefix () const
      {
        return this->OutputFilenamePrefix_;
      }

      simulation_type::OutputFilenamePrefix_optional& simulation_type::
      OutputFilenamePrefix ()
      {
        return this->OutputFilenamePrefix_;
      }

      void simulation_type::
      OutputFilenamePrefix (const OutputFilenamePrefix_type& x)
      {
        this->OutputFilenamePrefix_.set (x);
      }

      void simulation_type::
      OutputFilenamePrefix (const OutputFilenamePrefix_optional& x)
      {
        this->OutputFilenamePrefix_ = x;
      }

      void simulation_type::
      OutputFilenamePrefix (::std::unique_ptr< OutputFilenamePrefix_type > x)
      {
        this->OutputFilenamePrefix_.set (std::move (x));
      }

      const simulation_type::OutputVariables_optional& simulation_type::
      OutputVariables () const
      {
        return this->OutputVariables_;
      }

      simulation_type::OutputVariables_optional& simulation_type::
      OutputVariables ()
      {
        return this->OutputVariables_;
      }

      void simulation_type::
      OutputVariables (const OutputVariables_type& x)
      {
        this->OutputVariables_.set (x);
      }

      void simulation_type::
      OutputVariables (const OutputVariables_optional& x)
      {
        this->OutputVariables_ = x;
      }

      void simulation_type::
      OutputVariables (::std::unique_ptr< OutputVariables_type > x)
      {
        this->OutputVariables_.set (std::move (x));
      }

      const simulation_type::OutputVisualizer_optional& simulation_type::
      OutputVisualizer () const
      {
        return this->OutputVisualizer_;
      }

      simulation_type::OutputVisualizer_optional& simulation_type::
      OutputVisualizer ()
      {
        return this->OutputVisualizer_;
      }

      void simulation_type::
      OutputVisualizer (const OutputVisualizer_type& x)
      {
        this->OutputVisualizer_.set (x);
      }

      void simulation_type::
      OutputVisualizer (const OutputVisualizer_optional& x)
      {
        this->OutputVisualizer_ = x;
      }

      void simulation_type::
      OutputVisualizer (::std::unique_ptr< OutputVisualizer_type > x)
      {
        this->OutputVisualizer_.set (std::move (x));
      }

      const simulation_type::OutputUsingOriginalNodeOrdering_optional& simulation_type::
      OutputUsingOriginalNodeOrdering () const
      {
        return this->OutputUsingOriginalNodeOrdering_;
      }

      simulation_type::OutputUsingOriginalNodeOrdering_optional& simulation_type::
      OutputUsingOriginalNodeOrdering ()
      {
        return this->OutputUsingOriginalNodeOrdering_;
      }

      void simulation_type::
      OutputUsingOriginalNodeOrdering (const OutputUsingOriginalNodeOrdering_type& x)
      {
        this->OutputUsingOriginalNodeOrdering_.set (x);
      }

      void simulation_type::
      OutputUsingOriginalNodeOrdering (const OutputUsingOriginalNodeOrdering_optional& x)
      {
        this->OutputUsingOriginalNodeOrdering_ = x;
      }

      void simulation_type::
      OutputUsingOriginalNodeOrdering (::std::unique_ptr< OutputUsingOriginalNodeOrdering_type > x)
      {
        this->OutputUsingOriginalNodeOrdering_.set (std::move (x));
      }

      const simulation_type::OutputUsingOriginalNodeOrdering_type& simulation_type::
      OutputUsingOriginalNodeOrdering_default_value ()
      {
        return OutputUsingOriginalNodeOrdering_default_value_;
      }

      const simulation_type::CheckpointSimulation_optional& simulation_type::
      CheckpointSimulation () const
      {
        return this->CheckpointSimulation_;
      }

      simulation_type::CheckpointSimulation_optional& simulation_type::
      CheckpointSimulation ()
      {
        return this->CheckpointSimulation_;
      }

      void simulation_type::
      CheckpointSimulation (const CheckpointSimulation_type& x)
      {
        this->CheckpointSimulation_.set (x);
      }

      void simulation_type::
      CheckpointSimulation (const CheckpointSimulation_optional& x)
      {
        this->CheckpointSimulation_ = x;
      }

      void simulation_type::
      CheckpointSimulation (::std::unique_ptr< CheckpointSimulation_type > x)
      {
        this->CheckpointSimulation_.set (std::move (x));
      }


      // resume_simulation_type
      // 

      const resume_simulation_type::ArchiveDirectory_type& resume_simulation_type::
      ArchiveDirectory () const
      {
        return this->ArchiveDirectory_.get ();
      }

      resume_simulation_type::ArchiveDirectory_type& resume_simulation_type::
      ArchiveDirectory ()
      {
        return this->ArchiveDirectory_.get ();
      }

      void resume_simulation_type::
      ArchiveDirectory (const ArchiveDirectory_type& x)
      {
        this->ArchiveDirectory_.set (x);
      }

      void resume_simulation_type::
      ArchiveDirectory (::std::unique_ptr< ArchiveDirectory_type > x)
      {
        this->ArchiveDirectory_.set (std::move (x));
      }

      const resume_simulation_type::SpaceDimension_type& resume_simulation_type::
      SpaceDimension () const
      {
        return this->SpaceDimension_.get ();
      }

      resume_simulation_type::SpaceDimension_type& resume_simulation_type::
      SpaceDimension ()
      {
        return this->SpaceDimension_.get ();
      }

      void resume_simulation_type::
      SpaceDimension (const SpaceDimension_type& x)
      {
        this->SpaceDimension_.set (x);
      }

      const resume_simulation_type::Domain_type& resume_simulation_type::
      Domain () const
      {
        return this->Domain_.get ();
      }

      resume_simulation_type::Domain_type& resume_simulation_type::
      Domain ()
      {
        return this->Domain_.get ();
      }

      void resume_simulation_type::
      Domain (const Domain_type& x)
      {
        this->Domain_.set (x);
      }

      void resume_simulation_type::
      Domain (::std::unique_ptr< Domain_type > x)
      {
        this->Domain_.set (std::move (x));
      }

      const resume_simulation_type::SimulationDuration_type& resume_simulation_type::
      SimulationDuration () const
      {
        return this->SimulationDuration_.get ();
      }

      resume_simulation_type::SimulationDuration_type& resume_simulation_type::
      SimulationDuration ()
      {
        return this->SimulationDuration_.get ();
      }

      void resume_simulation_type::
      SimulationDuration (const SimulationDuration_type& x)
      {
        this->SimulationDuration_.set (x);
      }

      void resume_simulation_type::
      SimulationDuration (::std::unique_ptr< SimulationDuration_type > x)
      {
        this->SimulationDuration_.set (std::move (x));
      }

      const resume_simulation_type::Stimuli_optional& resume_simulation_type::
      Stimuli () const
      {
        return this->Stimuli_;
      }

      resume_simulation_type::Stimuli_optional& resume_simulation_type::
      Stimuli ()
      {
        return this->Stimuli_;
      }

      void resume_simulation_type::
      Stimuli (const Stimuli_type& x)
      {
        this->Stimuli_.set (x);
      }

      void resume_simulation_type::
      Stimuli (const Stimuli_optional& x)
      {
        this->Stimuli_ = x;
      }

      void resume_simulation_type::
      Stimuli (::std::unique_ptr< Stimuli_type > x)
      {
        this->Stimuli_.set (std::move (x));
      }

      const resume_simulation_type::CellHeterogeneities_optional& resume_simulation_type::
      CellHeterogeneities () const
      {
        return this->CellHeterogeneities_;
      }

      resume_simulation_type::CellHeterogeneities_optional& resume_simulation_type::
      CellHeterogeneities ()
      {
        return this->CellHeterogeneities_;
      }

      void resume_simulation_type::
      CellHeterogeneities (const CellHeterogeneities_type& x)
      {
        this->CellHeterogeneities_.set (x);
      }

      void resume_simulation_type::
      CellHeterogeneities (const CellHeterogeneities_optional& x)
      {
        this->CellHeterogeneities_ = x;
      }

      void resume_simulation_type::
      CellHeterogeneities (::std::unique_ptr< CellHeterogeneities_type > x)
      {
        this->CellHeterogeneities_.set (std::move (x));
      }

      const resume_simulation_type::CheckpointSimulation_optional& resume_simulation_type::
      CheckpointSimulation () const
      {
        return this->CheckpointSimulation_;
      }

      resume_simulation_type::CheckpointSimulation_optional& resume_simulation_type::
      CheckpointSimulation ()
      {
        return this->CheckpointSimulation_;
      }

      void resume_simulation_type::
      CheckpointSimulation (const CheckpointSimulation_type& x)
      {
        this->CheckpointSimulation_.set (x);
      }

      void resume_simulation_type::
      CheckpointSimulation (const CheckpointSimulation_optional& x)
      {
        this->CheckpointSimulation_ = x;
      }

      void resume_simulation_type::
      CheckpointSimulation (::std::unique_ptr< CheckpointSimulation_type > x)
      {
        this->CheckpointSimulation_.set (std::move (x));
      }

      const resume_simulation_type::OutputVisualizer_optional& resume_simulation_type::
      OutputVisualizer () const
      {
        return this->OutputVisualizer_;
      }

      resume_simulation_type::OutputVisualizer_optional& resume_simulation_type::
      OutputVisualizer ()
      {
        return this->OutputVisualizer_;
      }

      void resume_simulation_type::
      OutputVisualizer (const OutputVisualizer_type& x)
      {
        this->OutputVisualizer_.set (x);
      }

      void resume_simulation_type::
      OutputVisualizer (const OutputVisualizer_optional& x)
      {
        this->OutputVisualizer_ = x;
      }

      void resume_simulation_type::
      OutputVisualizer (::std::unique_ptr< OutputVisualizer_type > x)
      {
        this->OutputVisualizer_.set (std::move (x));
      }


      // physiological_type
      // 

      const physiological_type::IntracellularConductivities_optional& physiological_type::
      IntracellularConductivities () const
      {
        return this->IntracellularConductivities_;
      }

      physiological_type::IntracellularConductivities_optional& physiological_type::
      IntracellularConductivities ()
      {
        return this->IntracellularConductivities_;
      }

      void physiological_type::
      IntracellularConductivities (const IntracellularConductivities_type& x)
      {
        this->IntracellularConductivities_.set (x);
      }

      void physiological_type::
      IntracellularConductivities (const IntracellularConductivities_optional& x)
      {
        this->IntracellularConductivities_ = x;
      }

      void physiological_type::
      IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > x)
      {
        this->IntracellularConductivities_.set (std::move (x));
      }

      const physiological_type::ExtracellularConductivities_optional& physiological_type::
      ExtracellularConductivities () const
      {
        return this->ExtracellularConductivities_;
      }

      physiological_type::ExtracellularConductivities_optional& physiological_type::
      ExtracellularConductivities ()
      {
        return this->ExtracellularConductivities_;
      }

      void physiological_type::
      ExtracellularConductivities (const ExtracellularConductivities_type& x)
      {
        this->ExtracellularConductivities_.set (x);
      }

      void physiological_type::
      ExtracellularConductivities (const ExtracellularConductivities_optional& x)
      {
        this->ExtracellularConductivities_ = x;
      }

      void physiological_type::
      ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > x)
      {
        this->ExtracellularConductivities_.set (std::move (x));
      }

      const physiological_type::BathConductivity_optional& physiological_type::
      BathConductivity () const
      {
        return this->BathConductivity_;
      }

      physiological_type::BathConductivity_optional& physiological_type::
      BathConductivity ()
      {
        return this->BathConductivity_;
      }

      void physiological_type::
      BathConductivity (const BathConductivity_type& x)
      {
        this->BathConductivity_.set (x);
      }

      void physiological_type::
      BathConductivity (const BathConductivity_optional& x)
      {
        this->BathConductivity_ = x;
      }

      void physiological_type::
      BathConductivity (::std::unique_ptr< BathConductivity_type > x)
      {
        this->BathConductivity_.set (std::move (x));
      }

      const physiological_type::ConductivityHeterogeneities_optional& physiological_type::
      ConductivityHeterogeneities () const
      {
        return this->ConductivityHeterogeneities_;
      }

      physiological_type::ConductivityHeterogeneities_optional& physiological_type::
      ConductivityHeterogeneities ()
      {
        return this->ConductivityHeterogeneities_;
      }

      void physiological_type::
      ConductivityHeterogeneities (const ConductivityHeterogeneities_type& x)
      {
        this->ConductivityHeterogeneities_.set (x);
      }

      void physiological_type::
      ConductivityHeterogeneities (const ConductivityHeterogeneities_optional& x)
      {
        this->ConductivityHeterogeneities_ = x;
      }

      void physiological_type::
      ConductivityHeterogeneities (::std::unique_ptr< ConductivityHeterogeneities_type > x)
      {
        this->ConductivityHeterogeneities_.set (std::move (x));
      }

      const physiological_type::SurfaceAreaToVolumeRatio_optional& physiological_type::
      SurfaceAreaToVolumeRatio () const
      {
        return this->SurfaceAreaToVolumeRatio_;
      }

      physiological_type::SurfaceAreaToVolumeRatio_optional& physiological_type::
      SurfaceAreaToVolumeRatio ()
      {
        return this->SurfaceAreaToVolumeRatio_;
      }

      void physiological_type::
      SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_type& x)
      {
        this->SurfaceAreaToVolumeRatio_.set (x);
      }

      void physiological_type::
      SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_optional& x)
      {
        this->SurfaceAreaToVolumeRatio_ = x;
      }

      void physiological_type::
      SurfaceAreaToVolumeRatio (::std::unique_ptr< SurfaceAreaToVolumeRatio_type > x)
      {
        this->SurfaceAreaToVolumeRatio_.set (std::move (x));
      }

      const physiological_type::Capacitance_optional& physiological_type::
      Capacitance () const
      {
        return this->Capacitance_;
      }

      physiological_type::Capacitance_optional& physiological_type::
      Capacitance ()
      {
        return this->Capacitance_;
      }

      void physiological_type::
      Capacitance (const Capacitance_type& x)
      {
        this->Capacitance_.set (x);
      }

      void physiological_type::
      Capacitance (const Capacitance_optional& x)
      {
        this->Capacitance_ = x;
      }

      void physiological_type::
      Capacitance (::std::unique_ptr< Capacitance_type > x)
      {
        this->Capacitance_.set (std::move (x));
      }

      const physiological_type::ApplyDrug_optional& physiological_type::
      ApplyDrug () const
      {
        return this->ApplyDrug_;
      }

      physiological_type::ApplyDrug_optional& physiological_type::
      ApplyDrug ()
      {
        return this->ApplyDrug_;
      }

      void physiological_type::
      ApplyDrug (const ApplyDrug_type& x)
      {
        this->ApplyDrug_.set (x);
      }

      void physiological_type::
      ApplyDrug (const ApplyDrug_optional& x)
      {
        this->ApplyDrug_ = x;
      }

      void physiological_type::
      ApplyDrug (::std::unique_ptr< ApplyDrug_type > x)
      {
        this->ApplyDrug_.set (std::move (x));
      }

      const physiological_type::Purkinje_optional& physiological_type::
      Purkinje () const
      {
        return this->Purkinje_;
      }

      physiological_type::Purkinje_optional& physiological_type::
      Purkinje ()
      {
        return this->Purkinje_;
      }

      void physiological_type::
      Purkinje (const Purkinje_type& x)
      {
        this->Purkinje_.set (x);
      }

      void physiological_type::
      Purkinje (const Purkinje_optional& x)
      {
        this->Purkinje_ = x;
      }

      void physiological_type::
      Purkinje (::std::unique_ptr< Purkinje_type > x)
      {
        this->Purkinje_.set (std::move (x));
      }


      // numerical_type
      // 

      const numerical_type::TimeSteps_optional& numerical_type::
      TimeSteps () const
      {
        return this->TimeSteps_;
      }

      numerical_type::TimeSteps_optional& numerical_type::
      TimeSteps ()
      {
        return this->TimeSteps_;
      }

      void numerical_type::
      TimeSteps (const TimeSteps_type& x)
      {
        this->TimeSteps_.set (x);
      }

      void numerical_type::
      TimeSteps (const TimeSteps_optional& x)
      {
        this->TimeSteps_ = x;
      }

      void numerical_type::
      TimeSteps (::std::unique_ptr< TimeSteps_type > x)
      {
        this->TimeSteps_.set (std::move (x));
      }

      const numerical_type::KSPTolerances_optional& numerical_type::
      KSPTolerances () const
      {
        return this->KSPTolerances_;
      }

      numerical_type::KSPTolerances_optional& numerical_type::
      KSPTolerances ()
      {
        return this->KSPTolerances_;
      }

      void numerical_type::
      KSPTolerances (const KSPTolerances_type& x)
      {
        this->KSPTolerances_.set (x);
      }

      void numerical_type::
      KSPTolerances (const KSPTolerances_optional& x)
      {
        this->KSPTolerances_ = x;
      }

      void numerical_type::
      KSPTolerances (::std::unique_ptr< KSPTolerances_type > x)
      {
        this->KSPTolerances_.set (std::move (x));
      }

      const numerical_type::KSPSolver_optional& numerical_type::
      KSPSolver () const
      {
        return this->KSPSolver_;
      }

      numerical_type::KSPSolver_optional& numerical_type::
      KSPSolver ()
      {
        return this->KSPSolver_;
      }

      void numerical_type::
      KSPSolver (const KSPSolver_type& x)
      {
        this->KSPSolver_.set (x);
      }

      void numerical_type::
      KSPSolver (const KSPSolver_optional& x)
      {
        this->KSPSolver_ = x;
      }

      void numerical_type::
      KSPSolver (::std::unique_ptr< KSPSolver_type > x)
      {
        this->KSPSolver_.set (std::move (x));
      }

      const numerical_type::KSPPreconditioner_optional& numerical_type::
      KSPPreconditioner () const
      {
        return this->KSPPreconditioner_;
      }

      numerical_type::KSPPreconditioner_optional& numerical_type::
      KSPPreconditioner ()
      {
        return this->KSPPreconditioner_;
      }

      void numerical_type::
      KSPPreconditioner (const KSPPreconditioner_type& x)
      {
        this->KSPPreconditioner_.set (x);
      }

      void numerical_type::
      KSPPreconditioner (const KSPPreconditioner_optional& x)
      {
        this->KSPPreconditioner_ = x;
      }

      void numerical_type::
      KSPPreconditioner (::std::unique_ptr< KSPPreconditioner_type > x)
      {
        this->KSPPreconditioner_.set (std::move (x));
      }

      const numerical_type::MeshPartitioning_optional& numerical_type::
      MeshPartitioning () const
      {
        return this->MeshPartitioning_;
      }

      numerical_type::MeshPartitioning_optional& numerical_type::
      MeshPartitioning ()
      {
        return this->MeshPartitioning_;
      }

      void numerical_type::
      MeshPartitioning (const MeshPartitioning_type& x)
      {
        this->MeshPartitioning_.set (x);
      }

      void numerical_type::
      MeshPartitioning (const MeshPartitioning_optional& x)
      {
        this->MeshPartitioning_ = x;
      }

      void numerical_type::
      MeshPartitioning (::std::unique_ptr< MeshPartitioning_type > x)
      {
        this->MeshPartitioning_.set (std::move (x));
      }

      const numerical_type::UseStateVariableInterpolation_optional& numerical_type::
      UseStateVariableInterpolation () const
      {
        return this->UseStateVariableInterpolation_;
      }

      numerical_type::UseStateVariableInterpolation_optional& numerical_type::
      UseStateVariableInterpolation ()
      {
        return this->UseStateVariableInterpolation_;
      }

      void numerical_type::
      UseStateVariableInterpolation (const UseStateVariableInterpolation_type& x)
      {
        this->UseStateVariableInterpolation_.set (x);
      }

      void numerical_type::
      UseStateVariableInterpolation (const UseStateVariableInterpolation_optional& x)
      {
        this->UseStateVariableInterpolation_ = x;
      }

      void numerical_type::
      UseStateVariableInterpolation (::std::unique_ptr< UseStateVariableInterpolation_type > x)
      {
        this->UseStateVariableInterpolation_.set (std::move (x));
      }

      const numerical_type::AdaptivityParameters_optional& numerical_type::
      AdaptivityParameters () const
      {
        return this->AdaptivityParameters_;
      }

      numerical_type::AdaptivityParameters_optional& numerical_type::
      AdaptivityParameters ()
      {
        return this->AdaptivityParameters_;
      }

      void numerical_type::
      AdaptivityParameters (const AdaptivityParameters_type& x)
      {
        this->AdaptivityParameters_.set (x);
      }

      void numerical_type::
      AdaptivityParameters (const AdaptivityParameters_optional& x)
      {
        this->AdaptivityParameters_ = x;
      }

      void numerical_type::
      AdaptivityParameters (::std::unique_ptr< AdaptivityParameters_type > x)
      {
        this->AdaptivityParameters_.set (std::move (x));
      }


      // postprocessing_type
      // 

      const postprocessing_type::ActionPotentialDurationMap_sequence& postprocessing_type::
      ActionPotentialDurationMap () const
      {
        return this->ActionPotentialDurationMap_;
      }

      postprocessing_type::ActionPotentialDurationMap_sequence& postprocessing_type::
      ActionPotentialDurationMap ()
      {
        return this->ActionPotentialDurationMap_;
      }

      void postprocessing_type::
      ActionPotentialDurationMap (const ActionPotentialDurationMap_sequence& s)
      {
        this->ActionPotentialDurationMap_ = s;
      }

      const postprocessing_type::UpstrokeTimeMap_sequence& postprocessing_type::
      UpstrokeTimeMap () const
      {
        return this->UpstrokeTimeMap_;
      }

      postprocessing_type::UpstrokeTimeMap_sequence& postprocessing_type::
      UpstrokeTimeMap ()
      {
        return this->UpstrokeTimeMap_;
      }

      void postprocessing_type::
      UpstrokeTimeMap (const UpstrokeTimeMap_sequence& s)
      {
        this->UpstrokeTimeMap_ = s;
      }

      const postprocessing_type::MaxUpstrokeVelocityMap_sequence& postprocessing_type::
      MaxUpstrokeVelocityMap () const
      {
        return this->MaxUpstrokeVelocityMap_;
      }

      postprocessing_type::MaxUpstrokeVelocityMap_sequence& postprocessing_type::
      MaxUpstrokeVelocityMap ()
      {
        return this->MaxUpstrokeVelocityMap_;
      }

      void postprocessing_type::
      MaxUpstrokeVelocityMap (const MaxUpstrokeVelocityMap_sequence& s)
      {
        this->MaxUpstrokeVelocityMap_ = s;
      }

      const postprocessing_type::ConductionVelocityMap_sequence& postprocessing_type::
      ConductionVelocityMap () const
      {
        return this->ConductionVelocityMap_;
      }

      postprocessing_type::ConductionVelocityMap_sequence& postprocessing_type::
      ConductionVelocityMap ()
      {
        return this->ConductionVelocityMap_;
      }

      void postprocessing_type::
      ConductionVelocityMap (const ConductionVelocityMap_sequence& s)
      {
        this->ConductionVelocityMap_ = s;
      }

      const postprocessing_type::TimeTraceAtNode_sequence& postprocessing_type::
      TimeTraceAtNode () const
      {
        return this->TimeTraceAtNode_;
      }

      postprocessing_type::TimeTraceAtNode_sequence& postprocessing_type::
      TimeTraceAtNode ()
      {
        return this->TimeTraceAtNode_;
      }

      void postprocessing_type::
      TimeTraceAtNode (const TimeTraceAtNode_sequence& s)
      {
        this->TimeTraceAtNode_ = s;
      }

      const postprocessing_type::PseudoEcgElectrodePosition_sequence& postprocessing_type::
      PseudoEcgElectrodePosition () const
      {
        return this->PseudoEcgElectrodePosition_;
      }

      postprocessing_type::PseudoEcgElectrodePosition_sequence& postprocessing_type::
      PseudoEcgElectrodePosition ()
      {
        return this->PseudoEcgElectrodePosition_;
      }

      void postprocessing_type::
      PseudoEcgElectrodePosition (const PseudoEcgElectrodePosition_sequence& s)
      {
        this->PseudoEcgElectrodePosition_ = s;
      }


      // chaste_parameters_type
      // 

      const chaste_parameters_type::Simulation_optional& chaste_parameters_type::
      Simulation () const
      {
        return this->Simulation_;
      }

      chaste_parameters_type::Simulation_optional& chaste_parameters_type::
      Simulation ()
      {
        return this->Simulation_;
      }

      void chaste_parameters_type::
      Simulation (const Simulation_type& x)
      {
        this->Simulation_.set (x);
      }

      void chaste_parameters_type::
      Simulation (const Simulation_optional& x)
      {
        this->Simulation_ = x;
      }

      void chaste_parameters_type::
      Simulation (::std::unique_ptr< Simulation_type > x)
      {
        this->Simulation_.set (std::move (x));
      }

      const chaste_parameters_type::ResumeSimulation_optional& chaste_parameters_type::
      ResumeSimulation () const
      {
        return this->ResumeSimulation_;
      }

      chaste_parameters_type::ResumeSimulation_optional& chaste_parameters_type::
      ResumeSimulation ()
      {
        return this->ResumeSimulation_;
      }

      void chaste_parameters_type::
      ResumeSimulation (const ResumeSimulation_type& x)
      {
        this->ResumeSimulation_.set (x);
      }

      void chaste_parameters_type::
      ResumeSimulation (const ResumeSimulation_optional& x)
      {
        this->ResumeSimulation_ = x;
      }

      void chaste_parameters_type::
      ResumeSimulation (::std::unique_ptr< ResumeSimulation_type > x)
      {
        this->ResumeSimulation_.set (std::move (x));
      }

      const chaste_parameters_type::Physiological_type& chaste_parameters_type::
      Physiological () const
      {
        return this->Physiological_.get ();
      }

      chaste_parameters_type::Physiological_type& chaste_parameters_type::
      Physiological ()
      {
        return this->Physiological_.get ();
      }

      void chaste_parameters_type::
      Physiological (const Physiological_type& x)
      {
        this->Physiological_.set (x);
      }

      void chaste_parameters_type::
      Physiological (::std::unique_ptr< Physiological_type > x)
      {
        this->Physiological_.set (std::move (x));
      }

      const chaste_parameters_type::Numerical_type& chaste_parameters_type::
      Numerical () const
      {
        return this->Numerical_.get ();
      }

      chaste_parameters_type::Numerical_type& chaste_parameters_type::
      Numerical ()
      {
        return this->Numerical_.get ();
      }

      void chaste_parameters_type::
      Numerical (const Numerical_type& x)
      {
        this->Numerical_.set (x);
      }

      void chaste_parameters_type::
      Numerical (::std::unique_ptr< Numerical_type > x)
      {
        this->Numerical_.set (std::move (x));
      }

      const chaste_parameters_type::PostProcessing_optional& chaste_parameters_type::
      PostProcessing () const
      {
        return this->PostProcessing_;
      }

      chaste_parameters_type::PostProcessing_optional& chaste_parameters_type::
      PostProcessing ()
      {
        return this->PostProcessing_;
      }

      void chaste_parameters_type::
      PostProcessing (const PostProcessing_type& x)
      {
        this->PostProcessing_.set (x);
      }

      void chaste_parameters_type::
      PostProcessing (const PostProcessing_optional& x)
      {
        this->PostProcessing_ = x;
      }

      void chaste_parameters_type::
      PostProcessing (::std::unique_ptr< PostProcessing_type > x)
      {
        this->PostProcessing_.set (std::move (x));
      }


      // purkinje_physiological_type
      // 

      const purkinje_physiological_type::SurfaceAreaToVolumeRatio_optional& purkinje_physiological_type::
      SurfaceAreaToVolumeRatio () const
      {
        return this->SurfaceAreaToVolumeRatio_;
      }

      purkinje_physiological_type::SurfaceAreaToVolumeRatio_optional& purkinje_physiological_type::
      SurfaceAreaToVolumeRatio ()
      {
        return this->SurfaceAreaToVolumeRatio_;
      }

      void purkinje_physiological_type::
      SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_type& x)
      {
        this->SurfaceAreaToVolumeRatio_.set (x);
      }

      void purkinje_physiological_type::
      SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_optional& x)
      {
        this->SurfaceAreaToVolumeRatio_ = x;
      }

      void purkinje_physiological_type::
      SurfaceAreaToVolumeRatio (::std::unique_ptr< SurfaceAreaToVolumeRatio_type > x)
      {
        this->SurfaceAreaToVolumeRatio_.set (std::move (x));
      }

      const purkinje_physiological_type::Capacitance_optional& purkinje_physiological_type::
      Capacitance () const
      {
        return this->Capacitance_;
      }

      purkinje_physiological_type::Capacitance_optional& purkinje_physiological_type::
      Capacitance ()
      {
        return this->Capacitance_;
      }

      void purkinje_physiological_type::
      Capacitance (const Capacitance_type& x)
      {
        this->Capacitance_.set (x);
      }

      void purkinje_physiological_type::
      Capacitance (const Capacitance_optional& x)
      {
        this->Capacitance_ = x;
      }

      void purkinje_physiological_type::
      Capacitance (::std::unique_ptr< Capacitance_type > x)
      {
        this->Capacitance_.set (std::move (x));
      }

      const purkinje_physiological_type::Conductivity_optional& purkinje_physiological_type::
      Conductivity () const
      {
        return this->Conductivity_;
      }

      purkinje_physiological_type::Conductivity_optional& purkinje_physiological_type::
      Conductivity ()
      {
        return this->Conductivity_;
      }

      void purkinje_physiological_type::
      Conductivity (const Conductivity_type& x)
      {
        this->Conductivity_.set (x);
      }

      void purkinje_physiological_type::
      Conductivity (const Conductivity_optional& x)
      {
        this->Conductivity_ = x;
      }

      void purkinje_physiological_type::
      Conductivity (::std::unique_ptr< Conductivity_type > x)
      {
        this->Conductivity_.set (std::move (x));
      }


      // purkinje_simulation_type
      // 


      // ConductivityHeterogeneities
      // 

      const ConductivityHeterogeneities::ConductivityHeterogeneity_sequence& ConductivityHeterogeneities::
      ConductivityHeterogeneity () const
      {
        return this->ConductivityHeterogeneity_;
      }

      ConductivityHeterogeneities::ConductivityHeterogeneity_sequence& ConductivityHeterogeneities::
      ConductivityHeterogeneity ()
      {
        return this->ConductivityHeterogeneity_;
      }

      void ConductivityHeterogeneities::
      ConductivityHeterogeneity (const ConductivityHeterogeneity_sequence& s)
      {
        this->ConductivityHeterogeneity_ = s;
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      // time_type
      //

      const time_type::unit_type time_type::unit_default_value_ (
        "ms");

      time_type::
      time_type (const ::xml_schema::decimal& _xsd_decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
        unit_ (unit_default_value (), this)
      {
      }

      time_type::
      time_type (const time_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
        unit_ (x.unit_, f, this)
      {
      }

      time_type::
      time_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void time_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      time_type* time_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class time_type (*this, f, c);
      }

      time_type& time_type::
      operator= (const time_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      time_type::
      ~time_type ()
      {
      }

      // dimensionless_type
      //

      const dimensionless_type::unit_type dimensionless_type::unit_default_value_ (
        "dimensionless");

      dimensionless_type::
      dimensionless_type (const ::xml_schema::decimal& _xsd_decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
        unit_ (unit_default_value (), this)
      {
      }

      dimensionless_type::
      dimensionless_type (const dimensionless_type& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
        unit_ (x.unit_, f, this)
      {
      }

      dimensionless_type::
      dimensionless_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void dimensionless_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      dimensionless_type* dimensionless_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class dimensionless_type (*this, f, c);
      }

      dimensionless_type& dimensionless_type::
      operator= (const dimensionless_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      dimensionless_type::
      ~dimensionless_type ()
      {
      }

      // conductivity_type
      //

      const conductivity_type::unit_type conductivity_type::unit_default_value_ (
        "mS/cm");

      conductivity_type::
      conductivity_type (const ::xml_schema::decimal& _xsd_decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
        unit_ (unit_default_value (), this)
      {
      }

      conductivity_type::
      conductivity_type (const conductivity_type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
        unit_ (x.unit_, f, this)
      {
      }

      conductivity_type::
      conductivity_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void conductivity_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      conductivity_type* conductivity_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class conductivity_type (*this, f, c);
      }

      conductivity_type& conductivity_type::
      operator= (const conductivity_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      conductivity_type::
      ~conductivity_type ()
      {
      }

      // stimulus_strength_type
      //

      const stimulus_strength_type::unit_type stimulus_strength_type::unit_default_value_ (
        "uA/cm^3");

      stimulus_strength_type::
      stimulus_strength_type (const ::xml_schema::decimal& _xsd_decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
        unit_ (unit_default_value (), this)
      {
      }

      stimulus_strength_type::
      stimulus_strength_type (const stimulus_strength_type& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
        unit_ (x.unit_, f, this)
      {
      }

      stimulus_strength_type::
      stimulus_strength_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void stimulus_strength_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      stimulus_strength_type* stimulus_strength_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class stimulus_strength_type (*this, f, c);
      }

      stimulus_strength_type& stimulus_strength_type::
      operator= (const stimulus_strength_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      stimulus_strength_type::
      ~stimulus_strength_type ()
      {
      }

      // surface_stimulus_strength_type
      //

      const surface_stimulus_strength_type::unit_type surface_stimulus_strength_type::unit_default_value_ (
        "uA/cm^2");

      surface_stimulus_strength_type::
      surface_stimulus_strength_type (const ::xml_schema::decimal& _xsd_decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
        unit_ (unit_default_value (), this)
      {
      }

      surface_stimulus_strength_type::
      surface_stimulus_strength_type (const surface_stimulus_strength_type& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
        unit_ (x.unit_, f, this)
      {
      }

      surface_stimulus_strength_type::
      surface_stimulus_strength_type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void surface_stimulus_strength_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      surface_stimulus_strength_type* surface_stimulus_strength_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class surface_stimulus_strength_type (*this, f, c);
      }

      surface_stimulus_strength_type& surface_stimulus_strength_type::
      operator= (const surface_stimulus_strength_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      surface_stimulus_strength_type::
      ~surface_stimulus_strength_type ()
      {
      }

      // inverse_length_type
      //

      const inverse_length_type::unit_type inverse_length_type::unit_default_value_ (
        "1/cm");

      inverse_length_type::
      inverse_length_type (const ::xml_schema::decimal& _xsd_decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
        unit_ (unit_default_value (), this)
      {
      }

      inverse_length_type::
      inverse_length_type (const inverse_length_type& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
        unit_ (x.unit_, f, this)
      {
      }

      inverse_length_type::
      inverse_length_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void inverse_length_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      inverse_length_type* inverse_length_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class inverse_length_type (*this, f, c);
      }

      inverse_length_type& inverse_length_type::
      operator= (const inverse_length_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      inverse_length_type::
      ~inverse_length_type ()
      {
      }

      // capacitance_type
      //

      const capacitance_type::unit_type capacitance_type::unit_default_value_ (
        "uF/cm^2");

      capacitance_type::
      capacitance_type (const ::xml_schema::decimal& _xsd_decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
        unit_ (unit_default_value (), this)
      {
      }

      capacitance_type::
      capacitance_type (const capacitance_type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
        unit_ (x.unit_, f, this)
      {
      }

      capacitance_type::
      capacitance_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void capacitance_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      capacitance_type* capacitance_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class capacitance_type (*this, f, c);
      }

      capacitance_type& capacitance_type::
      operator= (const capacitance_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      capacitance_type::
      ~capacitance_type ()
      {
      }

      // apply_drug_type
      //

      apply_drug_type::
      apply_drug_type (const concentration_type& concentration)
      : ::xml_schema::type (),
        IC50_ (this),
        concentration_ (concentration, this)
      {
      }

      apply_drug_type::
      apply_drug_type (const apply_drug_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        IC50_ (x.IC50_, f, this),
        concentration_ (x.concentration_, f, this)
      {
      }

      apply_drug_type::
      apply_drug_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        IC50_ (this),
        concentration_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void apply_drug_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // IC50
          //
          if (n.name () == "IC50" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< IC50_type > r (
              IC50_traits::create (i, f, this));

            this->IC50_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "concentration" && n.namespace_ ().empty ())
          {
            this->concentration_.set (concentration_traits::create (i, f, this));
            continue;
          }
        }

        if (!concentration_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "concentration",
            "");
        }
      }

      apply_drug_type* apply_drug_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class apply_drug_type (*this, f, c);
      }

      apply_drug_type& apply_drug_type::
      operator= (const apply_drug_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->IC50_ = x.IC50_;
          this->concentration_ = x.concentration_;
        }

        return *this;
      }

      apply_drug_type::
      ~apply_drug_type ()
      {
      }

      // ic50_type
      //

      ic50_type::
      ic50_type (const ::xml_schema::double_& _xsd_double__base,
                 const current_type& current)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
        current_ (current, this),
        hill_ (hill_default_value (), this)
      {
      }

      ic50_type::
      ic50_type (const ic50_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
        current_ (x.current_, f, this),
        hill_ (x.hill_, f, this)
      {
      }

      ic50_type::
      ic50_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
        current_ (this),
        hill_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void ic50_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "current" && n.namespace_ ().empty ())
          {
            this->current_.set (current_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "hill" && n.namespace_ ().empty ())
          {
            this->hill_.set (hill_traits::create (i, f, this));
            continue;
          }
        }

        if (!current_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "current",
            "");
        }

        if (!hill_.present ())
        {
          this->hill_.set (hill_default_value ());
        }
      }

      ic50_type* ic50_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ic50_type (*this, f, c);
      }

      ic50_type& ic50_type::
      operator= (const ic50_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (*this) = x;
          this->current_ = x.current_;
          this->hill_ = x.hill_;
        }

        return *this;
      }

      ic50_type::
      ~ic50_type ()
      {
      }

      // location_type
      //

      const location_type::unit_type location_type::unit_default_value_ (
        "cm");

      location_type::
      location_type ()
      : ::xml_schema::type (),
        Cuboid_ (this),
        Ellipsoid_ (this),
        NotUsed_ (this),
        EpiLayer_ (this),
        MidLayer_ (this),
        EndoLayer_ (this),
        unit_ (unit_default_value (), this)
      {
      }

      location_type::
      location_type (const location_type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Cuboid_ (x.Cuboid_, f, this),
        Ellipsoid_ (x.Ellipsoid_, f, this),
        NotUsed_ (x.NotUsed_, f, this),
        EpiLayer_ (x.EpiLayer_, f, this),
        MidLayer_ (x.MidLayer_, f, this),
        EndoLayer_ (x.EndoLayer_, f, this),
        unit_ (x.unit_, f, this)
      {
      }

      location_type::
      location_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Cuboid_ (this),
        Ellipsoid_ (this),
        NotUsed_ (this),
        EpiLayer_ (this),
        MidLayer_ (this),
        EndoLayer_ (this),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void location_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Cuboid
          //
          if (n.name () == "Cuboid" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Cuboid_type > r (
              Cuboid_traits::create (i, f, this));

            if (!this->Cuboid_)
            {
              this->Cuboid_.set (::std::move (r));
              continue;
            }
          }

          // Ellipsoid
          //
          if (n.name () == "Ellipsoid" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Ellipsoid_type > r (
              Ellipsoid_traits::create (i, f, this));

            if (!this->Ellipsoid_)
            {
              this->Ellipsoid_.set (::std::move (r));
              continue;
            }
          }

          // NotUsed
          //
          if (n.name () == "NotUsed" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            if (!this->NotUsed_)
            {
              this->NotUsed_.set (NotUsed_traits::create (i, f, this));
              continue;
            }
          }

          // EpiLayer
          //
          if (n.name () == "EpiLayer" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< EpiLayer_type > r (
              EpiLayer_traits::create (i, f, this));

            if (!this->EpiLayer_)
            {
              this->EpiLayer_.set (::std::move (r));
              continue;
            }
          }

          // MidLayer
          //
          if (n.name () == "MidLayer" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< MidLayer_type > r (
              MidLayer_traits::create (i, f, this));

            if (!this->MidLayer_)
            {
              this->MidLayer_.set (::std::move (r));
              continue;
            }
          }

          // EndoLayer
          //
          if (n.name () == "EndoLayer" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< EndoLayer_type > r (
              EndoLayer_traits::create (i, f, this));

            if (!this->EndoLayer_)
            {
              this->EndoLayer_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      location_type* location_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class location_type (*this, f, c);
      }

      location_type& location_type::
      operator= (const location_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Cuboid_ = x.Cuboid_;
          this->Ellipsoid_ = x.Ellipsoid_;
          this->NotUsed_ = x.NotUsed_;
          this->EpiLayer_ = x.EpiLayer_;
          this->MidLayer_ = x.MidLayer_;
          this->EndoLayer_ = x.EndoLayer_;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      location_type::
      ~location_type ()
      {
      }

      // domain_type
      //

      domain_type::
      domain_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_domain_type_convert ();
      }

      domain_type::
      domain_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_domain_type_convert ();
      }

      domain_type::
      domain_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_domain_type_convert ();
      }

      domain_type* domain_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class domain_type (*this, f, c);
      }

      domain_type::value domain_type::
      _xsd_domain_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_domain_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_domain_type_indexes_,
                          _xsd_domain_type_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_domain_type_indexes_ + 3 || _xsd_domain_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const domain_type::
      _xsd_domain_type_literals_[3] =
      {
        "Mono",
        "Bi",
        "BiWithBath"
      };

      const domain_type::value domain_type::
      _xsd_domain_type_indexes_[3] =
      {
        ::chaste::parameters::v2017_1::domain_type::Bi,
        ::chaste::parameters::v2017_1::domain_type::BiWithBath,
        ::chaste::parameters::v2017_1::domain_type::Mono
      };

      // axis_type
      //

      axis_type::
      axis_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_axis_type_convert ();
      }

      axis_type::
      axis_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_axis_type_convert ();
      }

      axis_type::
      axis_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_axis_type_convert ();
      }

      axis_type* axis_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class axis_type (*this, f, c);
      }

      axis_type::value axis_type::
      _xsd_axis_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_axis_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_axis_type_indexes_,
                          _xsd_axis_type_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_axis_type_indexes_ + 3 || _xsd_axis_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const axis_type::
      _xsd_axis_type_literals_[3] =
      {
        "x",
        "y",
        "z"
      };

      const axis_type::value axis_type::
      _xsd_axis_type_indexes_[3] =
      {
        ::chaste::parameters::v2017_1::axis_type::x,
        ::chaste::parameters::v2017_1::axis_type::y,
        ::chaste::parameters::v2017_1::axis_type::z
      };

      // ionic_models_available_type
      //

      ionic_models_available_type::
      ionic_models_available_type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_ionic_models_available_type_convert ();
      }

      ionic_models_available_type::
      ionic_models_available_type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_ionic_models_available_type_convert ();
      }

      ionic_models_available_type::
      ionic_models_available_type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_ionic_models_available_type_convert ();
      }

      ionic_models_available_type* ionic_models_available_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ionic_models_available_type (*this, f, c);
      }

      ionic_models_available_type::value ionic_models_available_type::
      _xsd_ionic_models_available_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ionic_models_available_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_ionic_models_available_type_indexes_,
                          _xsd_ionic_models_available_type_indexes_ + 13,
                          *this,
                          c));

        if (i == _xsd_ionic_models_available_type_indexes_ + 13 || _xsd_ionic_models_available_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const ionic_models_available_type::
      _xsd_ionic_models_available_type_literals_[13] =
      {
        "DifrancescoNoble",
        "Fox2002",
        "Fox2002BackwardEuler",
        "FaberRudy2000",
        "FaberRudy2000Optimised",
        "HodgkinHuxley",
        "LuoRudyI",
        "LuoRudyIBackwardEuler",
        "MahajanShiferaw",
        "MahajanShiferawBackwardEuler",
        "Maleckar",
        "tenTusscher2006",
        "tenTusscher2006BackwardEuler"
      };

      const ionic_models_available_type::value ionic_models_available_type::
      _xsd_ionic_models_available_type_indexes_[13] =
      {
        ::chaste::parameters::v2017_1::ionic_models_available_type::DifrancescoNoble,
        ::chaste::parameters::v2017_1::ionic_models_available_type::FaberRudy2000,
        ::chaste::parameters::v2017_1::ionic_models_available_type::FaberRudy2000Optimised,
        ::chaste::parameters::v2017_1::ionic_models_available_type::Fox2002,
        ::chaste::parameters::v2017_1::ionic_models_available_type::Fox2002BackwardEuler,
        ::chaste::parameters::v2017_1::ionic_models_available_type::HodgkinHuxley,
        ::chaste::parameters::v2017_1::ionic_models_available_type::LuoRudyI,
        ::chaste::parameters::v2017_1::ionic_models_available_type::LuoRudyIBackwardEuler,
        ::chaste::parameters::v2017_1::ionic_models_available_type::MahajanShiferaw,
        ::chaste::parameters::v2017_1::ionic_models_available_type::MahajanShiferawBackwardEuler,
        ::chaste::parameters::v2017_1::ionic_models_available_type::Maleckar,
        ::chaste::parameters::v2017_1::ionic_models_available_type::tenTusscher2006,
        ::chaste::parameters::v2017_1::ionic_models_available_type::tenTusscher2006BackwardEuler
      };

      // ionic_model_selection_type
      //

      ionic_model_selection_type::
      ionic_model_selection_type ()
      : ::xml_schema::type (),
        Hardcoded_ (this),
        Dynamic_ (this)
      {
      }

      ionic_model_selection_type::
      ionic_model_selection_type (const ionic_model_selection_type& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Hardcoded_ (x.Hardcoded_, f, this),
        Dynamic_ (x.Dynamic_, f, this)
      {
      }

      ionic_model_selection_type::
      ionic_model_selection_type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Hardcoded_ (this),
        Dynamic_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ionic_model_selection_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Hardcoded
          //
          if (n.name () == "Hardcoded" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Hardcoded_type > r (
              Hardcoded_traits::create (i, f, this));

            if (!this->Hardcoded_)
            {
              this->Hardcoded_.set (::std::move (r));
              continue;
            }
          }

          // Dynamic
          //
          if (n.name () == "Dynamic" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Dynamic_type > r (
              Dynamic_traits::create (i, f, this));

            if (!this->Dynamic_)
            {
              this->Dynamic_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      ionic_model_selection_type* ionic_model_selection_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ionic_model_selection_type (*this, f, c);
      }

      ionic_model_selection_type& ionic_model_selection_type::
      operator= (const ionic_model_selection_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Hardcoded_ = x.Hardcoded_;
          this->Dynamic_ = x.Dynamic_;
        }

        return *this;
      }

      ionic_model_selection_type::
      ~ionic_model_selection_type ()
      {
      }

      // dynamically_loaded_ionic_model_type
      //

      dynamically_loaded_ionic_model_type::
      dynamically_loaded_ionic_model_type (const Path_type& Path)
      : ::xml_schema::type (),
        Path_ (Path, this)
      {
      }

      dynamically_loaded_ionic_model_type::
      dynamically_loaded_ionic_model_type (::std::unique_ptr< Path_type > Path)
      : ::xml_schema::type (),
        Path_ (std::move (Path), this)
      {
      }

      dynamically_loaded_ionic_model_type::
      dynamically_loaded_ionic_model_type (const dynamically_loaded_ionic_model_type& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Path_ (x.Path_, f, this)
      {
      }

      dynamically_loaded_ionic_model_type::
      dynamically_loaded_ionic_model_type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Path_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void dynamically_loaded_ionic_model_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Path
          //
          if (n.name () == "Path" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Path_type > r (
              Path_traits::create (i, f, this));

            if (!Path_.present ())
            {
              this->Path_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!Path_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Path",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      dynamically_loaded_ionic_model_type* dynamically_loaded_ionic_model_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class dynamically_loaded_ionic_model_type (*this, f, c);
      }

      dynamically_loaded_ionic_model_type& dynamically_loaded_ionic_model_type::
      operator= (const dynamically_loaded_ionic_model_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Path_ = x.Path_;
        }

        return *this;
      }

      dynamically_loaded_ionic_model_type::
      ~dynamically_loaded_ionic_model_type ()
      {
      }

      // path_type
      //

      const path_type::relative_to_type path_type::relative_to_default_value_ (
        "cwd");

      path_type::
      path_type ()
      : ::xml_schema::string (),
        relative_to_ (relative_to_default_value (), this)
      {
      }

      path_type::
      path_type (const char* _xsd_string_base)
      : ::xml_schema::string (_xsd_string_base),
        relative_to_ (relative_to_default_value (), this)
      {
      }

      path_type::
      path_type (const ::std::string& _xsd_string_base)
      : ::xml_schema::string (_xsd_string_base),
        relative_to_ (relative_to_default_value (), this)
      {
      }

      path_type::
      path_type (const ::xml_schema::string& _xsd_string_base)
      : ::xml_schema::string (_xsd_string_base),
        relative_to_ (relative_to_default_value (), this)
      {
      }

      path_type::
      path_type (const path_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::string (x, f, c),
        relative_to_ (x.relative_to_, f, this)
      {
      }

      path_type::
      path_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
        relative_to_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void path_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "relative_to" && n.namespace_ ().empty ())
          {
            this->relative_to_.set (relative_to_traits::create (i, f, this));
            continue;
          }
        }

        if (!relative_to_.present ())
        {
          this->relative_to_.set (relative_to_default_value ());
        }
      }

      path_type* path_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class path_type (*this, f, c);
      }

      path_type& path_type::
      operator= (const path_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::string& > (*this) = x;
          this->relative_to_ = x.relative_to_;
        }

        return *this;
      }

      path_type::
      ~path_type ()
      {
      }

      // relative_to_type
      //

      relative_to_type::
      relative_to_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_relative_to_type_convert ();
      }

      relative_to_type::
      relative_to_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_relative_to_type_convert ();
      }

      relative_to_type::
      relative_to_type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_relative_to_type_convert ();
      }

      relative_to_type* relative_to_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class relative_to_type (*this, f, c);
      }

      relative_to_type::value relative_to_type::
      _xsd_relative_to_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_relative_to_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_relative_to_type_indexes_,
                          _xsd_relative_to_type_indexes_ + 6,
                          *this,
                          c));

        if (i == _xsd_relative_to_type_indexes_ + 6 || _xsd_relative_to_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const relative_to_type::
      _xsd_relative_to_type_literals_[6] =
      {
        "cwd",
        "chaste_test_output",
        "chaste_source_root",
        "chaste_build_root",
        "absolute",
        "this_file"
      };

      const relative_to_type::value relative_to_type::
      _xsd_relative_to_type_indexes_[6] =
      {
        ::chaste::parameters::v2017_1::relative_to_type::absolute,
        ::chaste::parameters::v2017_1::relative_to_type::chaste_build_root,
        ::chaste::parameters::v2017_1::relative_to_type::chaste_source_root,
        ::chaste::parameters::v2017_1::relative_to_type::chaste_test_output,
        ::chaste::parameters::v2017_1::relative_to_type::cwd,
        ::chaste::parameters::v2017_1::relative_to_type::this_file
      };

      // ionic_model_region_type
      //

      ionic_model_region_type::
      ionic_model_region_type (const IonicModel_type& IonicModel,
                               const Location_type& Location)
      : ::xml_schema::type (),
        IonicModel_ (IonicModel, this),
        Location_ (Location, this)
      {
      }

      ionic_model_region_type::
      ionic_model_region_type (::std::unique_ptr< IonicModel_type > IonicModel,
                               ::std::unique_ptr< Location_type > Location)
      : ::xml_schema::type (),
        IonicModel_ (std::move (IonicModel), this),
        Location_ (std::move (Location), this)
      {
      }

      ionic_model_region_type::
      ionic_model_region_type (const ionic_model_region_type& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        IonicModel_ (x.IonicModel_, f, this),
        Location_ (x.Location_, f, this)
      {
      }

      ionic_model_region_type::
      ionic_model_region_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        IonicModel_ (this),
        Location_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ionic_model_region_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // IonicModel
          //
          if (n.name () == "IonicModel" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< IonicModel_type > r (
              IonicModel_traits::create (i, f, this));

            if (!IonicModel_.present ())
            {
              this->IonicModel_.set (::std::move (r));
              continue;
            }
          }

          // Location
          //
          if (n.name () == "Location" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Location_type > r (
              Location_traits::create (i, f, this));

            if (!Location_.present ())
            {
              this->Location_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!IonicModel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "IonicModel",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Location_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Location",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      ionic_model_region_type* ionic_model_region_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ionic_model_region_type (*this, f, c);
      }

      ionic_model_region_type& ionic_model_region_type::
      operator= (const ionic_model_region_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->IonicModel_ = x.IonicModel_;
          this->Location_ = x.Location_;
        }

        return *this;
      }

      ionic_model_region_type::
      ~ionic_model_region_type ()
      {
      }

      // ionic_models_type
      //

      ionic_models_type::
      ionic_models_type (const Default_type& Default)
      : ::xml_schema::type (),
        Default_ (Default, this),
        Region_ (this)
      {
      }

      ionic_models_type::
      ionic_models_type (::std::unique_ptr< Default_type > Default)
      : ::xml_schema::type (),
        Default_ (std::move (Default), this),
        Region_ (this)
      {
      }

      ionic_models_type::
      ionic_models_type (const ionic_models_type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Default_ (x.Default_, f, this),
        Region_ (x.Region_, f, this)
      {
      }

      ionic_models_type::
      ionic_models_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Default_ (this),
        Region_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ionic_models_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Default
          //
          if (n.name () == "Default" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Default_type > r (
              Default_traits::create (i, f, this));

            if (!Default_.present ())
            {
              this->Default_.set (::std::move (r));
              continue;
            }
          }

          // Region
          //
          if (n.name () == "Region" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Region_type > r (
              Region_traits::create (i, f, this));

            this->Region_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!Default_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Default",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      ionic_models_type* ionic_models_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ionic_models_type (*this, f, c);
      }

      ionic_models_type& ionic_models_type::
      operator= (const ionic_models_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Default_ = x.Default_;
          this->Region_ = x.Region_;
        }

        return *this;
      }

      ionic_models_type::
      ~ionic_models_type ()
      {
      }

      // apd_map_type
      //

      const apd_map_type::threshold_unit_type apd_map_type::threshold_unit_default_value_ (
        "mV");

      apd_map_type::
      apd_map_type (const repolarisation_percentage_type& repolarisation_percentage,
                    const threshold_type& threshold)
      : ::xml_schema::type (),
        repolarisation_percentage_ (repolarisation_percentage, this),
        threshold_ (threshold, this),
        threshold_unit_ (threshold_unit_default_value (), this)
      {
      }

      apd_map_type::
      apd_map_type (const apd_map_type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        repolarisation_percentage_ (x.repolarisation_percentage_, f, this),
        threshold_ (x.threshold_, f, this),
        threshold_unit_ (x.threshold_unit_, f, this)
      {
      }

      apd_map_type::
      apd_map_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        repolarisation_percentage_ (this),
        threshold_ (this),
        threshold_unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void apd_map_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "repolarisation_percentage" && n.namespace_ ().empty ())
          {
            this->repolarisation_percentage_.set (repolarisation_percentage_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "threshold" && n.namespace_ ().empty ())
          {
            this->threshold_.set (threshold_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "threshold_unit" && n.namespace_ ().empty ())
          {
            this->threshold_unit_.set (threshold_unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!repolarisation_percentage_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "repolarisation_percentage",
            "");
        }

        if (!threshold_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "threshold",
            "");
        }

        if (!threshold_unit_.present ())
        {
          this->threshold_unit_.set (threshold_unit_default_value ());
        }
      }

      apd_map_type* apd_map_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class apd_map_type (*this, f, c);
      }

      apd_map_type& apd_map_type::
      operator= (const apd_map_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->repolarisation_percentage_ = x.repolarisation_percentage_;
          this->threshold_ = x.threshold_;
          this->threshold_unit_ = x.threshold_unit_;
        }

        return *this;
      }

      apd_map_type::
      ~apd_map_type ()
      {
      }

      // upstrokes_map_type
      //

      const upstrokes_map_type::threshold_unit_type upstrokes_map_type::threshold_unit_default_value_ (
        "mV");

      upstrokes_map_type::
      upstrokes_map_type (const threshold_type& threshold)
      : ::xml_schema::type (),
        threshold_ (threshold, this),
        threshold_unit_ (threshold_unit_default_value (), this)
      {
      }

      upstrokes_map_type::
      upstrokes_map_type (const upstrokes_map_type& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        threshold_ (x.threshold_, f, this),
        threshold_unit_ (x.threshold_unit_, f, this)
      {
      }

      upstrokes_map_type::
      upstrokes_map_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        threshold_ (this),
        threshold_unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void upstrokes_map_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "threshold" && n.namespace_ ().empty ())
          {
            this->threshold_.set (threshold_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "threshold_unit" && n.namespace_ ().empty ())
          {
            this->threshold_unit_.set (threshold_unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!threshold_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "threshold",
            "");
        }

        if (!threshold_unit_.present ())
        {
          this->threshold_unit_.set (threshold_unit_default_value ());
        }
      }

      upstrokes_map_type* upstrokes_map_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class upstrokes_map_type (*this, f, c);
      }

      upstrokes_map_type& upstrokes_map_type::
      operator= (const upstrokes_map_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->threshold_ = x.threshold_;
          this->threshold_unit_ = x.threshold_unit_;
        }

        return *this;
      }

      upstrokes_map_type::
      ~upstrokes_map_type ()
      {
      }

      // max_upstrokes_velocity_map_type
      //

      const max_upstrokes_velocity_map_type::threshold_unit_type max_upstrokes_velocity_map_type::threshold_unit_default_value_ (
        "mV");

      max_upstrokes_velocity_map_type::
      max_upstrokes_velocity_map_type (const threshold_type& threshold)
      : ::xml_schema::type (),
        threshold_ (threshold, this),
        threshold_unit_ (threshold_unit_default_value (), this)
      {
      }

      max_upstrokes_velocity_map_type::
      max_upstrokes_velocity_map_type (const max_upstrokes_velocity_map_type& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        threshold_ (x.threshold_, f, this),
        threshold_unit_ (x.threshold_unit_, f, this)
      {
      }

      max_upstrokes_velocity_map_type::
      max_upstrokes_velocity_map_type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        threshold_ (this),
        threshold_unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void max_upstrokes_velocity_map_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "threshold" && n.namespace_ ().empty ())
          {
            this->threshold_.set (threshold_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "threshold_unit" && n.namespace_ ().empty ())
          {
            this->threshold_unit_.set (threshold_unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!threshold_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "threshold",
            "");
        }

        if (!threshold_unit_.present ())
        {
          this->threshold_unit_.set (threshold_unit_default_value ());
        }
      }

      max_upstrokes_velocity_map_type* max_upstrokes_velocity_map_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class max_upstrokes_velocity_map_type (*this, f, c);
      }

      max_upstrokes_velocity_map_type& max_upstrokes_velocity_map_type::
      operator= (const max_upstrokes_velocity_map_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->threshold_ = x.threshold_;
          this->threshold_unit_ = x.threshold_unit_;
        }

        return *this;
      }

      max_upstrokes_velocity_map_type::
      ~max_upstrokes_velocity_map_type ()
      {
      }

      // conduction_velocity_map_type
      //

      conduction_velocity_map_type::
      conduction_velocity_map_type (const origin_node_type& origin_node)
      : ::xml_schema::type (),
        origin_node_ (origin_node, this)
      {
      }

      conduction_velocity_map_type::
      conduction_velocity_map_type (const conduction_velocity_map_type& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        origin_node_ (x.origin_node_, f, this)
      {
      }

      conduction_velocity_map_type::
      conduction_velocity_map_type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        origin_node_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void conduction_velocity_map_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "origin_node" && n.namespace_ ().empty ())
          {
            this->origin_node_.set (origin_node_traits::create (i, f, this));
            continue;
          }
        }

        if (!origin_node_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "origin_node",
            "");
        }
      }

      conduction_velocity_map_type* conduction_velocity_map_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class conduction_velocity_map_type (*this, f, c);
      }

      conduction_velocity_map_type& conduction_velocity_map_type::
      operator= (const conduction_velocity_map_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->origin_node_ = x.origin_node_;
        }

        return *this;
      }

      conduction_velocity_map_type::
      ~conduction_velocity_map_type ()
      {
      }

      // node_number_type
      //

      node_number_type::
      node_number_type (const node_number_type1& node_number)
      : ::xml_schema::type (),
        node_number_ (node_number, this)
      {
      }

      node_number_type::
      node_number_type (const node_number_type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        node_number_ (x.node_number_, f, this)
      {
      }

      node_number_type::
      node_number_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        node_number_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void node_number_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "node_number" && n.namespace_ ().empty ())
          {
            this->node_number_.set (node_number_traits::create (i, f, this));
            continue;
          }
        }

        if (!node_number_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "node_number",
            "");
        }
      }

      node_number_type* node_number_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class node_number_type (*this, f, c);
      }

      node_number_type& node_number_type::
      operator= (const node_number_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->node_number_ = x.node_number_;
        }

        return *this;
      }

      node_number_type::
      ~node_number_type ()
      {
      }

      // media_type
      //

      media_type::
      media_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_media_type_convert ();
      }

      media_type::
      media_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_media_type_convert ();
      }

      media_type::
      media_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_media_type_convert ();
      }

      media_type* media_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class media_type (*this, f, c);
      }

      media_type::value media_type::
      _xsd_media_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_media_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_media_type_indexes_,
                          _xsd_media_type_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_media_type_indexes_ + 3 || _xsd_media_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const media_type::
      _xsd_media_type_literals_[3] =
      {
        "Orthotropic",
        "Axisymmetric",
        "NoFibreOrientation"
      };

      const media_type::value media_type::
      _xsd_media_type_indexes_[3] =
      {
        ::chaste::parameters::v2017_1::media_type::Axisymmetric,
        ::chaste::parameters::v2017_1::media_type::NoFibreOrientation,
        ::chaste::parameters::v2017_1::media_type::Orthotropic
      };

      // point_type
      //

      point_type::
      point_type (const x_type& x,
                  const y_type& y,
                  const z_type& z)
      : ::xml_schema::type (),
        x_ (x, this),
        y_ (y, this),
        z_ (z, this)
      {
      }

      point_type::
      point_type (const point_type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        x_ (x.x_, f, this),
        y_ (x.y_, f, this),
        z_ (x.z_, f, this)
      {
      }

      point_type::
      point_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        x_ (this),
        y_ (this),
        z_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void point_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "x" && n.namespace_ ().empty ())
          {
            this->x_.set (x_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "y" && n.namespace_ ().empty ())
          {
            this->y_.set (y_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "z" && n.namespace_ ().empty ())
          {
            this->z_.set (z_traits::create (i, f, this));
            continue;
          }
        }

        if (!x_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "x",
            "");
        }

        if (!y_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "y",
            "");
        }

        if (!z_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "z",
            "");
        }
      }

      point_type* point_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class point_type (*this, f, c);
      }

      point_type& point_type::
      operator= (const point_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->x_ = x.x_;
          this->y_ = x.y_;
          this->z_ = x.z_;
        }

        return *this;
      }

      point_type::
      ~point_type ()
      {
      }

      // box_type
      //

      box_type::
      box_type (const LowerCoordinates_type& LowerCoordinates,
                const UpperCoordinates_type& UpperCoordinates)
      : ::xml_schema::type (),
        LowerCoordinates_ (LowerCoordinates, this),
        UpperCoordinates_ (UpperCoordinates, this)
      {
      }

      box_type::
      box_type (::std::unique_ptr< LowerCoordinates_type > LowerCoordinates,
                ::std::unique_ptr< UpperCoordinates_type > UpperCoordinates)
      : ::xml_schema::type (),
        LowerCoordinates_ (std::move (LowerCoordinates), this),
        UpperCoordinates_ (std::move (UpperCoordinates), this)
      {
      }

      box_type::
      box_type (const box_type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        LowerCoordinates_ (x.LowerCoordinates_, f, this),
        UpperCoordinates_ (x.UpperCoordinates_, f, this)
      {
      }

      box_type::
      box_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        LowerCoordinates_ (this),
        UpperCoordinates_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void box_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // LowerCoordinates
          //
          if (n.name () == "LowerCoordinates" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< LowerCoordinates_type > r (
              LowerCoordinates_traits::create (i, f, this));

            if (!LowerCoordinates_.present ())
            {
              this->LowerCoordinates_.set (::std::move (r));
              continue;
            }
          }

          // UpperCoordinates
          //
          if (n.name () == "UpperCoordinates" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< UpperCoordinates_type > r (
              UpperCoordinates_traits::create (i, f, this));

            if (!UpperCoordinates_.present ())
            {
              this->UpperCoordinates_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!LowerCoordinates_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "LowerCoordinates",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!UpperCoordinates_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "UpperCoordinates",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      box_type* box_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class box_type (*this, f, c);
      }

      box_type& box_type::
      operator= (const box_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->LowerCoordinates_ = x.LowerCoordinates_;
          this->UpperCoordinates_ = x.UpperCoordinates_;
        }

        return *this;
      }

      box_type::
      ~box_type ()
      {
      }

      // ellipsoid_type
      //

      ellipsoid_type::
      ellipsoid_type (const Centre_type& Centre,
                      const Radii_type& Radii)
      : ::xml_schema::type (),
        Centre_ (Centre, this),
        Radii_ (Radii, this)
      {
      }

      ellipsoid_type::
      ellipsoid_type (::std::unique_ptr< Centre_type > Centre,
                      ::std::unique_ptr< Radii_type > Radii)
      : ::xml_schema::type (),
        Centre_ (std::move (Centre), this),
        Radii_ (std::move (Radii), this)
      {
      }

      ellipsoid_type::
      ellipsoid_type (const ellipsoid_type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Centre_ (x.Centre_, f, this),
        Radii_ (x.Radii_, f, this)
      {
      }

      ellipsoid_type::
      ellipsoid_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Centre_ (this),
        Radii_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ellipsoid_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Centre
          //
          if (n.name () == "Centre" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Centre_type > r (
              Centre_traits::create (i, f, this));

            if (!Centre_.present ())
            {
              this->Centre_.set (::std::move (r));
              continue;
            }
          }

          // Radii
          //
          if (n.name () == "Radii" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Radii_type > r (
              Radii_traits::create (i, f, this));

            if (!Radii_.present ())
            {
              this->Radii_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!Centre_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Centre",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Radii_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Radii",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      ellipsoid_type* ellipsoid_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ellipsoid_type (*this, f, c);
      }

      ellipsoid_type& ellipsoid_type::
      operator= (const ellipsoid_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Centre_ = x.Centre_;
          this->Radii_ = x.Radii_;
        }

        return *this;
      }

      ellipsoid_type::
      ~ellipsoid_type ()
      {
      }

      // stimulus_type
      //

      stimulus_type::
      stimulus_type (const Strength_type& Strength,
                     const Duration_type& Duration,
                     const Delay_type& Delay,
                     const Location_type& Location)
      : ::xml_schema::type (),
        Strength_ (Strength, this),
        Duration_ (Duration, this),
        Delay_ (Delay, this),
        Period_ (this),
        StopTime_ (this),
        Location_ (Location, this)
      {
      }

      stimulus_type::
      stimulus_type (::std::unique_ptr< Strength_type > Strength,
                     ::std::unique_ptr< Duration_type > Duration,
                     ::std::unique_ptr< Delay_type > Delay,
                     ::std::unique_ptr< Location_type > Location)
      : ::xml_schema::type (),
        Strength_ (std::move (Strength), this),
        Duration_ (std::move (Duration), this),
        Delay_ (std::move (Delay), this),
        Period_ (this),
        StopTime_ (this),
        Location_ (std::move (Location), this)
      {
      }

      stimulus_type::
      stimulus_type (const stimulus_type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Strength_ (x.Strength_, f, this),
        Duration_ (x.Duration_, f, this),
        Delay_ (x.Delay_, f, this),
        Period_ (x.Period_, f, this),
        StopTime_ (x.StopTime_, f, this),
        Location_ (x.Location_, f, this)
      {
      }

      stimulus_type::
      stimulus_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Strength_ (this),
        Duration_ (this),
        Delay_ (this),
        Period_ (this),
        StopTime_ (this),
        Location_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void stimulus_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Strength
          //
          if (n.name () == "Strength" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Strength_type > r (
              Strength_traits::create (i, f, this));

            if (!Strength_.present ())
            {
              this->Strength_.set (::std::move (r));
              continue;
            }
          }

          // Duration
          //
          if (n.name () == "Duration" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Duration_type > r (
              Duration_traits::create (i, f, this));

            if (!Duration_.present ())
            {
              this->Duration_.set (::std::move (r));
              continue;
            }
          }

          // Delay
          //
          if (n.name () == "Delay" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Delay_type > r (
              Delay_traits::create (i, f, this));

            if (!Delay_.present ())
            {
              this->Delay_.set (::std::move (r));
              continue;
            }
          }

          // Period
          //
          if (n.name () == "Period" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Period_type > r (
              Period_traits::create (i, f, this));

            if (!this->Period_)
            {
              this->Period_.set (::std::move (r));
              continue;
            }
          }

          // StopTime
          //
          if (n.name () == "StopTime" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< StopTime_type > r (
              StopTime_traits::create (i, f, this));

            if (!this->StopTime_)
            {
              this->StopTime_.set (::std::move (r));
              continue;
            }
          }

          // Location
          //
          if (n.name () == "Location" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Location_type > r (
              Location_traits::create (i, f, this));

            if (!Location_.present ())
            {
              this->Location_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!Strength_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Strength",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Duration_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Duration",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Delay_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Delay",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Location_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Location",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      stimulus_type* stimulus_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class stimulus_type (*this, f, c);
      }

      stimulus_type& stimulus_type::
      operator= (const stimulus_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Strength_ = x.Strength_;
          this->Duration_ = x.Duration_;
          this->Delay_ = x.Delay_;
          this->Period_ = x.Period_;
          this->StopTime_ = x.StopTime_;
          this->Location_ = x.Location_;
        }

        return *this;
      }

      stimulus_type::
      ~stimulus_type ()
      {
      }

      // set_parameter_type
      //

      set_parameter_type::
      set_parameter_type (const name_type& name,
                          const value_type& value)
      : ::xml_schema::type (),
        name_ (name, this),
        value_ (value, this)
      {
      }

      set_parameter_type::
      set_parameter_type (const set_parameter_type& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this),
        value_ (x.value_, f, this)
      {
      }

      set_parameter_type::
      set_parameter_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (this),
        value_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void set_parameter_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "value" && n.namespace_ ().empty ())
          {
            this->value_.set (value_traits::create (i, f, this));
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }

        if (!value_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "value",
            "");
        }
      }

      set_parameter_type* set_parameter_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class set_parameter_type (*this, f, c);
      }

      set_parameter_type& set_parameter_type::
      operator= (const set_parameter_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->name_ = x.name_;
          this->value_ = x.value_;
        }

        return *this;
      }

      set_parameter_type::
      ~set_parameter_type ()
      {
      }

      // electrodes_type
      //

      electrodes_type::
      electrodes_type (const GroundSecondElectrode_type& GroundSecondElectrode,
                       const PerpendicularToAxis_type& PerpendicularToAxis,
                       const Strength_type& Strength,
                       const StartTime_type& StartTime,
                       const Duration_type& Duration)
      : ::xml_schema::type (),
        GroundSecondElectrode_ (GroundSecondElectrode, this),
        PerpendicularToAxis_ (PerpendicularToAxis, this),
        Strength_ (Strength, this),
        StartTime_ (StartTime, this),
        Duration_ (Duration, this)
      {
      }

      electrodes_type::
      electrodes_type (const GroundSecondElectrode_type& GroundSecondElectrode,
                       const PerpendicularToAxis_type& PerpendicularToAxis,
                       ::std::unique_ptr< Strength_type > Strength,
                       ::std::unique_ptr< StartTime_type > StartTime,
                       ::std::unique_ptr< Duration_type > Duration)
      : ::xml_schema::type (),
        GroundSecondElectrode_ (GroundSecondElectrode, this),
        PerpendicularToAxis_ (PerpendicularToAxis, this),
        Strength_ (std::move (Strength), this),
        StartTime_ (std::move (StartTime), this),
        Duration_ (std::move (Duration), this)
      {
      }

      electrodes_type::
      electrodes_type (const electrodes_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        GroundSecondElectrode_ (x.GroundSecondElectrode_, f, this),
        PerpendicularToAxis_ (x.PerpendicularToAxis_, f, this),
        Strength_ (x.Strength_, f, this),
        StartTime_ (x.StartTime_, f, this),
        Duration_ (x.Duration_, f, this)
      {
      }

      electrodes_type::
      electrodes_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        GroundSecondElectrode_ (this),
        PerpendicularToAxis_ (this),
        Strength_ (this),
        StartTime_ (this),
        Duration_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void electrodes_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // GroundSecondElectrode
          //
          if (n.name () == "GroundSecondElectrode" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< GroundSecondElectrode_type > r (
              GroundSecondElectrode_traits::create (i, f, this));

            if (!GroundSecondElectrode_.present ())
            {
              this->GroundSecondElectrode_.set (::std::move (r));
              continue;
            }
          }

          // PerpendicularToAxis
          //
          if (n.name () == "PerpendicularToAxis" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< PerpendicularToAxis_type > r (
              PerpendicularToAxis_traits::create (i, f, this));

            if (!PerpendicularToAxis_.present ())
            {
              this->PerpendicularToAxis_.set (::std::move (r));
              continue;
            }
          }

          // Strength
          //
          if (n.name () == "Strength" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Strength_type > r (
              Strength_traits::create (i, f, this));

            if (!Strength_.present ())
            {
              this->Strength_.set (::std::move (r));
              continue;
            }
          }

          // StartTime
          //
          if (n.name () == "StartTime" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< StartTime_type > r (
              StartTime_traits::create (i, f, this));

            if (!StartTime_.present ())
            {
              this->StartTime_.set (::std::move (r));
              continue;
            }
          }

          // Duration
          //
          if (n.name () == "Duration" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Duration_type > r (
              Duration_traits::create (i, f, this));

            if (!Duration_.present ())
            {
              this->Duration_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!GroundSecondElectrode_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "GroundSecondElectrode",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!PerpendicularToAxis_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "PerpendicularToAxis",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Strength_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Strength",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!StartTime_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "StartTime",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Duration_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Duration",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      electrodes_type* electrodes_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class electrodes_type (*this, f, c);
      }

      electrodes_type& electrodes_type::
      operator= (const electrodes_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->GroundSecondElectrode_ = x.GroundSecondElectrode_;
          this->PerpendicularToAxis_ = x.PerpendicularToAxis_;
          this->Strength_ = x.Strength_;
          this->StartTime_ = x.StartTime_;
          this->Duration_ = x.Duration_;
        }

        return *this;
      }

      electrodes_type::
      ~electrodes_type ()
      {
      }

      // cell_heterogeneity_type
      //

      cell_heterogeneity_type::
      cell_heterogeneity_type (const Location_type& Location)
      : ::xml_schema::type (),
        ScaleFactorGks_ (this),
        ScaleFactorIto_ (this),
        ScaleFactorGkr_ (this),
        Location_ (Location, this),
        SetParameter_ (this)
      {
      }

      cell_heterogeneity_type::
      cell_heterogeneity_type (::std::unique_ptr< Location_type > Location)
      : ::xml_schema::type (),
        ScaleFactorGks_ (this),
        ScaleFactorIto_ (this),
        ScaleFactorGkr_ (this),
        Location_ (std::move (Location), this),
        SetParameter_ (this)
      {
      }

      cell_heterogeneity_type::
      cell_heterogeneity_type (const cell_heterogeneity_type& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        ScaleFactorGks_ (x.ScaleFactorGks_, f, this),
        ScaleFactorIto_ (x.ScaleFactorIto_, f, this),
        ScaleFactorGkr_ (x.ScaleFactorGkr_, f, this),
        Location_ (x.Location_, f, this),
        SetParameter_ (x.SetParameter_, f, this)
      {
      }

      cell_heterogeneity_type::
      cell_heterogeneity_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        ScaleFactorGks_ (this),
        ScaleFactorIto_ (this),
        ScaleFactorGkr_ (this),
        Location_ (this),
        SetParameter_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void cell_heterogeneity_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // ScaleFactorGks
          //
          if (n.name () == "ScaleFactorGks" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ScaleFactorGks_type > r (
              ScaleFactorGks_traits::create (i, f, this));

            if (!this->ScaleFactorGks_)
            {
              this->ScaleFactorGks_.set (::std::move (r));
              continue;
            }
          }

          // ScaleFactorIto
          //
          if (n.name () == "ScaleFactorIto" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ScaleFactorIto_type > r (
              ScaleFactorIto_traits::create (i, f, this));

            if (!this->ScaleFactorIto_)
            {
              this->ScaleFactorIto_.set (::std::move (r));
              continue;
            }
          }

          // ScaleFactorGkr
          //
          if (n.name () == "ScaleFactorGkr" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ScaleFactorGkr_type > r (
              ScaleFactorGkr_traits::create (i, f, this));

            if (!this->ScaleFactorGkr_)
            {
              this->ScaleFactorGkr_.set (::std::move (r));
              continue;
            }
          }

          // Location
          //
          if (n.name () == "Location" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Location_type > r (
              Location_traits::create (i, f, this));

            if (!Location_.present ())
            {
              this->Location_.set (::std::move (r));
              continue;
            }
          }

          // SetParameter
          //
          if (n.name () == "SetParameter" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< SetParameter_type > r (
              SetParameter_traits::create (i, f, this));

            this->SetParameter_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!Location_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Location",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      cell_heterogeneity_type* cell_heterogeneity_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class cell_heterogeneity_type (*this, f, c);
      }

      cell_heterogeneity_type& cell_heterogeneity_type::
      operator= (const cell_heterogeneity_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->ScaleFactorGks_ = x.ScaleFactorGks_;
          this->ScaleFactorIto_ = x.ScaleFactorIto_;
          this->ScaleFactorGkr_ = x.ScaleFactorGkr_;
          this->Location_ = x.Location_;
          this->SetParameter_ = x.SetParameter_;
        }

        return *this;
      }

      cell_heterogeneity_type::
      ~cell_heterogeneity_type ()
      {
      }

      // conductivity_heterogeneity_type
      //

      conductivity_heterogeneity_type::
      conductivity_heterogeneity_type (const Location_type& Location)
      : ::xml_schema::type (),
        IntracellularConductivities_ (this),
        ExtracellularConductivities_ (this),
        Location_ (Location, this)
      {
      }

      conductivity_heterogeneity_type::
      conductivity_heterogeneity_type (::std::unique_ptr< Location_type > Location)
      : ::xml_schema::type (),
        IntracellularConductivities_ (this),
        ExtracellularConductivities_ (this),
        Location_ (std::move (Location), this)
      {
      }

      conductivity_heterogeneity_type::
      conductivity_heterogeneity_type (const conductivity_heterogeneity_type& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        IntracellularConductivities_ (x.IntracellularConductivities_, f, this),
        ExtracellularConductivities_ (x.ExtracellularConductivities_, f, this),
        Location_ (x.Location_, f, this)
      {
      }

      conductivity_heterogeneity_type::
      conductivity_heterogeneity_type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        IntracellularConductivities_ (this),
        ExtracellularConductivities_ (this),
        Location_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void conductivity_heterogeneity_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // IntracellularConductivities
          //
          if (n.name () == "IntracellularConductivities" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< IntracellularConductivities_type > r (
              IntracellularConductivities_traits::create (i, f, this));

            if (!this->IntracellularConductivities_)
            {
              this->IntracellularConductivities_.set (::std::move (r));
              continue;
            }
          }

          // ExtracellularConductivities
          //
          if (n.name () == "ExtracellularConductivities" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ExtracellularConductivities_type > r (
              ExtracellularConductivities_traits::create (i, f, this));

            if (!this->ExtracellularConductivities_)
            {
              this->ExtracellularConductivities_.set (::std::move (r));
              continue;
            }
          }

          // Location
          //
          if (n.name () == "Location" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Location_type > r (
              Location_traits::create (i, f, this));

            if (!Location_.present ())
            {
              this->Location_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!Location_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Location",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      conductivity_heterogeneity_type* conductivity_heterogeneity_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class conductivity_heterogeneity_type (*this, f, c);
      }

      conductivity_heterogeneity_type& conductivity_heterogeneity_type::
      operator= (const conductivity_heterogeneity_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->IntracellularConductivities_ = x.IntracellularConductivities_;
          this->ExtracellularConductivities_ = x.ExtracellularConductivities_;
          this->Location_ = x.Location_;
        }

        return *this;
      }

      conductivity_heterogeneity_type::
      ~conductivity_heterogeneity_type ()
      {
      }

      // slab_type
      //

      slab_type::
      slab_type (const x_type& x,
                 const y_type& y,
                 const z_type& z,
                 const inter_node_space_type& inter_node_space)
      : ::xml_schema::type (),
        x_ (x, this),
        y_ (y, this),
        z_ (z, this),
        inter_node_space_ (inter_node_space, this)
      {
      }

      slab_type::
      slab_type (const slab_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        x_ (x.x_, f, this),
        y_ (x.y_, f, this),
        z_ (x.z_, f, this),
        inter_node_space_ (x.inter_node_space_, f, this)
      {
      }

      slab_type::
      slab_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        x_ (this),
        y_ (this),
        z_ (this),
        inter_node_space_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void slab_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "x" && n.namespace_ ().empty ())
          {
            this->x_.set (x_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "y" && n.namespace_ ().empty ())
          {
            this->y_.set (y_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "z" && n.namespace_ ().empty ())
          {
            this->z_.set (z_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "inter_node_space" && n.namespace_ ().empty ())
          {
            this->inter_node_space_.set (inter_node_space_traits::create (i, f, this));
            continue;
          }
        }

        if (!x_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "x",
            "");
        }

        if (!y_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "y",
            "");
        }

        if (!z_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "z",
            "");
        }

        if (!inter_node_space_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "inter_node_space",
            "");
        }
      }

      slab_type* slab_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class slab_type (*this, f, c);
      }

      slab_type& slab_type::
      operator= (const slab_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->x_ = x.x_;
          this->y_ = x.y_;
          this->z_ = x.z_;
          this->inter_node_space_ = x.inter_node_space_;
        }

        return *this;
      }

      slab_type::
      ~slab_type ()
      {
      }

      // sheet_type
      //

      sheet_type::
      sheet_type (const x_type& x,
                  const y_type& y,
                  const inter_node_space_type& inter_node_space)
      : ::xml_schema::type (),
        x_ (x, this),
        y_ (y, this),
        inter_node_space_ (inter_node_space, this)
      {
      }

      sheet_type::
      sheet_type (const sheet_type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        x_ (x.x_, f, this),
        y_ (x.y_, f, this),
        inter_node_space_ (x.inter_node_space_, f, this)
      {
      }

      sheet_type::
      sheet_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        x_ (this),
        y_ (this),
        inter_node_space_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void sheet_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "x" && n.namespace_ ().empty ())
          {
            this->x_.set (x_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "y" && n.namespace_ ().empty ())
          {
            this->y_.set (y_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "inter_node_space" && n.namespace_ ().empty ())
          {
            this->inter_node_space_.set (inter_node_space_traits::create (i, f, this));
            continue;
          }
        }

        if (!x_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "x",
            "");
        }

        if (!y_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "y",
            "");
        }

        if (!inter_node_space_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "inter_node_space",
            "");
        }
      }

      sheet_type* sheet_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class sheet_type (*this, f, c);
      }

      sheet_type& sheet_type::
      operator= (const sheet_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->x_ = x.x_;
          this->y_ = x.y_;
          this->inter_node_space_ = x.inter_node_space_;
        }

        return *this;
      }

      sheet_type::
      ~sheet_type ()
      {
      }

      // fibre_type
      //

      fibre_type::
      fibre_type (const x_type& x,
                  const inter_node_space_type& inter_node_space)
      : ::xml_schema::type (),
        x_ (x, this),
        inter_node_space_ (inter_node_space, this)
      {
      }

      fibre_type::
      fibre_type (const fibre_type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        x_ (x.x_, f, this),
        inter_node_space_ (x.inter_node_space_, f, this)
      {
      }

      fibre_type::
      fibre_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        x_ (this),
        inter_node_space_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void fibre_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "x" && n.namespace_ ().empty ())
          {
            this->x_.set (x_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "inter_node_space" && n.namespace_ ().empty ())
          {
            this->inter_node_space_.set (inter_node_space_traits::create (i, f, this));
            continue;
          }
        }

        if (!x_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "x",
            "");
        }

        if (!inter_node_space_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "inter_node_space",
            "");
        }
      }

      fibre_type* fibre_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class fibre_type (*this, f, c);
      }

      fibre_type& fibre_type::
      operator= (const fibre_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->x_ = x.x_;
          this->inter_node_space_ = x.inter_node_space_;
        }

        return *this;
      }

      fibre_type::
      ~fibre_type ()
      {
      }

      // load_mesh_type
      //

      load_mesh_type::
      load_mesh_type (const name_type& name,
                      const conductivity_media_type& conductivity_media)
      : ::xml_schema::type (),
        name_ (name, this),
        conductivity_media_ (conductivity_media, this)
      {
      }

      load_mesh_type::
      load_mesh_type (const load_mesh_type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this),
        conductivity_media_ (x.conductivity_media_, f, this)
      {
      }

      load_mesh_type::
      load_mesh_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (this),
        conductivity_media_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void load_mesh_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "conductivity_media" && n.namespace_ ().empty ())
          {
            this->conductivity_media_.set (conductivity_media_traits::create (i, f, this));
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }

        if (!conductivity_media_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "conductivity_media",
            "");
        }
      }

      load_mesh_type* load_mesh_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class load_mesh_type (*this, f, c);
      }

      load_mesh_type& load_mesh_type::
      operator= (const load_mesh_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->name_ = x.name_;
          this->conductivity_media_ = x.conductivity_media_;
        }

        return *this;
      }

      load_mesh_type::
      ~load_mesh_type ()
      {
      }

      // mesh_type
      //

      const mesh_type::unit_type mesh_type::unit_default_value_ (
        "cm");

      mesh_type::
      mesh_type ()
      : ::xml_schema::type (),
        Slab_ (this),
        Sheet_ (this),
        Fibre_ (this),
        LoadMesh_ (this),
        unit_ (unit_default_value (), this)
      {
      }

      mesh_type::
      mesh_type (const mesh_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Slab_ (x.Slab_, f, this),
        Sheet_ (x.Sheet_, f, this),
        Fibre_ (x.Fibre_, f, this),
        LoadMesh_ (x.LoadMesh_, f, this),
        unit_ (x.unit_, f, this)
      {
      }

      mesh_type::
      mesh_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Slab_ (this),
        Sheet_ (this),
        Fibre_ (this),
        LoadMesh_ (this),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void mesh_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Slab
          //
          if (n.name () == "Slab" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Slab_type > r (
              Slab_traits::create (i, f, this));

            if (!this->Slab_)
            {
              this->Slab_.set (::std::move (r));
              continue;
            }
          }

          // Sheet
          //
          if (n.name () == "Sheet" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Sheet_type > r (
              Sheet_traits::create (i, f, this));

            if (!this->Sheet_)
            {
              this->Sheet_.set (::std::move (r));
              continue;
            }
          }

          // Fibre
          //
          if (n.name () == "Fibre" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Fibre_type > r (
              Fibre_traits::create (i, f, this));

            if (!this->Fibre_)
            {
              this->Fibre_.set (::std::move (r));
              continue;
            }
          }

          // LoadMesh
          //
          if (n.name () == "LoadMesh" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< LoadMesh_type > r (
              LoadMesh_traits::create (i, f, this));

            if (!this->LoadMesh_)
            {
              this->LoadMesh_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      mesh_type* mesh_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class mesh_type (*this, f, c);
      }

      mesh_type& mesh_type::
      operator= (const mesh_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Slab_ = x.Slab_;
          this->Sheet_ = x.Sheet_;
          this->Fibre_ = x.Fibre_;
          this->LoadMesh_ = x.LoadMesh_;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      mesh_type::
      ~mesh_type ()
      {
      }

      // conductivities_type
      //

      const conductivities_type::unit_type conductivities_type::unit_default_value_ (
        "mS/cm");

      conductivities_type::
      conductivities_type (const longi_type& longi,
                           const trans_type& trans,
                           const normal_type& normal)
      : ::xml_schema::type (),
        longi_ (longi, this),
        trans_ (trans, this),
        normal_ (normal, this),
        unit_ (unit_default_value (), this)
      {
      }

      conductivities_type::
      conductivities_type (const conductivities_type& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        longi_ (x.longi_, f, this),
        trans_ (x.trans_, f, this),
        normal_ (x.normal_, f, this),
        unit_ (x.unit_, f, this)
      {
      }

      conductivities_type::
      conductivities_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        longi_ (this),
        trans_ (this),
        normal_ (this),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void conductivities_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "longi" && n.namespace_ ().empty ())
          {
            this->longi_.set (longi_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "trans" && n.namespace_ ().empty ())
          {
            this->trans_.set (trans_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "normal" && n.namespace_ ().empty ())
          {
            this->normal_.set (normal_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!longi_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "longi",
            "");
        }

        if (!trans_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "trans",
            "");
        }

        if (!normal_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "normal",
            "");
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      conductivities_type* conductivities_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class conductivities_type (*this, f, c);
      }

      conductivities_type& conductivities_type::
      operator= (const conductivities_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->longi_ = x.longi_;
          this->trans_ = x.trans_;
          this->normal_ = x.normal_;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      conductivities_type::
      ~conductivities_type ()
      {
      }

      // var_type
      //

      var_type::
      var_type (const name_type& name)
      : ::xml_schema::type (),
        name_ (name, this)
      {
      }

      var_type::
      var_type (const var_type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this)
      {
      }

      var_type::
      var_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void var_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }
      }

      var_type* var_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class var_type (*this, f, c);
      }

      var_type& var_type::
      operator= (const var_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->name_ = x.name_;
        }

        return *this;
      }

      var_type::
      ~var_type ()
      {
      }

      // output_variables_type
      //

      output_variables_type::
      output_variables_type ()
      : ::xml_schema::type (),
        Var_ (this)
      {
      }

      output_variables_type::
      output_variables_type (const output_variables_type& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Var_ (x.Var_, f, this)
      {
      }

      output_variables_type::
      output_variables_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Var_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void output_variables_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Var
          //
          if (n.name () == "Var" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Var_type > r (
              Var_traits::create (i, f, this));

            this->Var_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      output_variables_type* output_variables_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class output_variables_type (*this, f, c);
      }

      output_variables_type& output_variables_type::
      operator= (const output_variables_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Var_ = x.Var_;
        }

        return *this;
      }

      output_variables_type::
      ~output_variables_type ()
      {
      }

      // yesno_type
      //

      yesno_type::
      yesno_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_yesno_type_convert ();
      }

      yesno_type::
      yesno_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_yesno_type_convert ();
      }

      yesno_type::
      yesno_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_yesno_type_convert ();
      }

      yesno_type* yesno_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class yesno_type (*this, f, c);
      }

      yesno_type::value yesno_type::
      _xsd_yesno_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yesno_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_yesno_type_indexes_,
                          _xsd_yesno_type_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_yesno_type_indexes_ + 2 || _xsd_yesno_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const yesno_type::
      _xsd_yesno_type_literals_[2] =
      {
        "yes",
        "no"
      };

      const yesno_type::value yesno_type::
      _xsd_yesno_type_indexes_[2] =
      {
        ::chaste::parameters::v2017_1::yesno_type::no,
        ::chaste::parameters::v2017_1::yesno_type::yes
      };

      // output_visualizer_type
      //

      const output_visualizer_type::meshalyzer_type output_visualizer_type::meshalyzer_default_value_ (
        "no");

      const output_visualizer_type::cmgui_type output_visualizer_type::cmgui_default_value_ (
        "no");

      const output_visualizer_type::vtk_type output_visualizer_type::vtk_default_value_ (
        "no");

      const output_visualizer_type::parallel_vtk_type output_visualizer_type::parallel_vtk_default_value_ (
        "no");

      output_visualizer_type::
      output_visualizer_type ()
      : ::xml_schema::type (),
        meshalyzer_ (meshalyzer_default_value (), this),
        cmgui_ (cmgui_default_value (), this),
        vtk_ (vtk_default_value (), this),
        parallel_vtk_ (parallel_vtk_default_value (), this),
        precision_ (precision_default_value (), this)
      {
      }

      output_visualizer_type::
      output_visualizer_type (const output_visualizer_type& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        meshalyzer_ (x.meshalyzer_, f, this),
        cmgui_ (x.cmgui_, f, this),
        vtk_ (x.vtk_, f, this),
        parallel_vtk_ (x.parallel_vtk_, f, this),
        precision_ (x.precision_, f, this)
      {
      }

      output_visualizer_type::
      output_visualizer_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        meshalyzer_ (this),
        cmgui_ (this),
        vtk_ (this),
        parallel_vtk_ (this),
        precision_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void output_visualizer_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "meshalyzer" && n.namespace_ ().empty ())
          {
            this->meshalyzer_.set (meshalyzer_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "cmgui" && n.namespace_ ().empty ())
          {
            this->cmgui_.set (cmgui_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "vtk" && n.namespace_ ().empty ())
          {
            this->vtk_.set (vtk_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "parallel_vtk" && n.namespace_ ().empty ())
          {
            this->parallel_vtk_.set (parallel_vtk_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "precision" && n.namespace_ ().empty ())
          {
            this->precision_.set (precision_traits::create (i, f, this));
            continue;
          }
        }

        if (!meshalyzer_.present ())
        {
          this->meshalyzer_.set (meshalyzer_default_value ());
        }

        if (!cmgui_.present ())
        {
          this->cmgui_.set (cmgui_default_value ());
        }

        if (!vtk_.present ())
        {
          this->vtk_.set (vtk_default_value ());
        }

        if (!parallel_vtk_.present ())
        {
          this->parallel_vtk_.set (parallel_vtk_default_value ());
        }

        if (!precision_.present ())
        {
          this->precision_.set (precision_default_value ());
        }
      }

      output_visualizer_type* output_visualizer_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class output_visualizer_type (*this, f, c);
      }

      output_visualizer_type& output_visualizer_type::
      operator= (const output_visualizer_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->meshalyzer_ = x.meshalyzer_;
          this->cmgui_ = x.cmgui_;
          this->vtk_ = x.vtk_;
          this->parallel_vtk_ = x.parallel_vtk_;
          this->precision_ = x.precision_;
        }

        return *this;
      }

      output_visualizer_type::
      ~output_visualizer_type ()
      {
      }

      // time_steps_type
      //

      const time_steps_type::unit_type time_steps_type::unit_default_value_ (
        "ms");

      time_steps_type::
      time_steps_type (const ode_type& ode,
                       const pde_type& pde,
                       const printing_type& printing)
      : ::xml_schema::type (),
        ode_ (ode, this),
        pde_ (pde, this),
        printing_ (printing, this),
        unit_ (unit_default_value (), this)
      {
      }

      time_steps_type::
      time_steps_type (const time_steps_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        ode_ (x.ode_, f, this),
        pde_ (x.pde_, f, this),
        printing_ (x.printing_, f, this),
        unit_ (x.unit_, f, this)
      {
      }

      time_steps_type::
      time_steps_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        ode_ (this),
        pde_ (this),
        printing_ (this),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void time_steps_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "ode" && n.namespace_ ().empty ())
          {
            this->ode_.set (ode_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "pde" && n.namespace_ ().empty ())
          {
            this->pde_.set (pde_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "printing" && n.namespace_ ().empty ())
          {
            this->printing_.set (printing_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!ode_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "ode",
            "");
        }

        if (!pde_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "pde",
            "");
        }

        if (!printing_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "printing",
            "");
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      time_steps_type* time_steps_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class time_steps_type (*this, f, c);
      }

      time_steps_type& time_steps_type::
      operator= (const time_steps_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->ode_ = x.ode_;
          this->pde_ = x.pde_;
          this->printing_ = x.printing_;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      time_steps_type::
      ~time_steps_type ()
      {
      }

      // ksp_tolerances_type
      //

      ksp_tolerances_type::
      ksp_tolerances_type ()
      : ::xml_schema::type (),
        KSPRelative_ (this),
        KSPAbsolute_ (this)
      {
      }

      ksp_tolerances_type::
      ksp_tolerances_type (const ksp_tolerances_type& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        KSPRelative_ (x.KSPRelative_, f, this),
        KSPAbsolute_ (x.KSPAbsolute_, f, this)
      {
      }

      ksp_tolerances_type::
      ksp_tolerances_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        KSPRelative_ (this),
        KSPAbsolute_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ksp_tolerances_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // KSPRelative
          //
          if (n.name () == "KSPRelative" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            if (!this->KSPRelative_)
            {
              this->KSPRelative_.set (KSPRelative_traits::create (i, f, this));
              continue;
            }
          }

          // KSPAbsolute
          //
          if (n.name () == "KSPAbsolute" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            if (!this->KSPAbsolute_)
            {
              this->KSPAbsolute_.set (KSPAbsolute_traits::create (i, f, this));
              continue;
            }
          }

          break;
        }
      }

      ksp_tolerances_type* ksp_tolerances_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ksp_tolerances_type (*this, f, c);
      }

      ksp_tolerances_type& ksp_tolerances_type::
      operator= (const ksp_tolerances_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->KSPRelative_ = x.KSPRelative_;
          this->KSPAbsolute_ = x.KSPAbsolute_;
        }

        return *this;
      }

      ksp_tolerances_type::
      ~ksp_tolerances_type ()
      {
      }

      // ksp_solver_type
      //

      ksp_solver_type::
      ksp_solver_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_ksp_solver_type_convert ();
      }

      ksp_solver_type::
      ksp_solver_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_ksp_solver_type_convert ();
      }

      ksp_solver_type::
      ksp_solver_type (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_ksp_solver_type_convert ();
      }

      ksp_solver_type* ksp_solver_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ksp_solver_type (*this, f, c);
      }

      ksp_solver_type::value ksp_solver_type::
      _xsd_ksp_solver_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_solver_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_ksp_solver_type_indexes_,
                          _xsd_ksp_solver_type_indexes_ + 4,
                          *this,
                          c));

        if (i == _xsd_ksp_solver_type_indexes_ + 4 || _xsd_ksp_solver_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const ksp_solver_type::
      _xsd_ksp_solver_type_literals_[4] =
      {
        "cg",
        "symmlq",
        "gmres",
        "chebychev"
      };

      const ksp_solver_type::value ksp_solver_type::
      _xsd_ksp_solver_type_indexes_[4] =
      {
        ::chaste::parameters::v2017_1::ksp_solver_type::cg,
        ::chaste::parameters::v2017_1::ksp_solver_type::chebychev,
        ::chaste::parameters::v2017_1::ksp_solver_type::gmres,
        ::chaste::parameters::v2017_1::ksp_solver_type::symmlq
      };

      // ksp_preconditioner_type
      //

      ksp_preconditioner_type::
      ksp_preconditioner_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_ksp_preconditioner_type_convert ();
      }

      ksp_preconditioner_type::
      ksp_preconditioner_type (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_ksp_preconditioner_type_convert ();
      }

      ksp_preconditioner_type::
      ksp_preconditioner_type (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_ksp_preconditioner_type_convert ();
      }

      ksp_preconditioner_type* ksp_preconditioner_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ksp_preconditioner_type (*this, f, c);
      }

      ksp_preconditioner_type::value ksp_preconditioner_type::
      _xsd_ksp_preconditioner_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_preconditioner_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_ksp_preconditioner_type_indexes_,
                          _xsd_ksp_preconditioner_type_indexes_ + 9,
                          *this,
                          c));

        if (i == _xsd_ksp_preconditioner_type_indexes_ + 9 || _xsd_ksp_preconditioner_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const ksp_preconditioner_type::
      _xsd_ksp_preconditioner_type_literals_[9] =
      {
        "jacobi",
        "bjacobi",
        "hypre",
        "ml",
        "spai",
        "blockdiagonal",
        "ldufactorisation",
        "twolevelsblockdiagonal",
        "none"
      };

      const ksp_preconditioner_type::value ksp_preconditioner_type::
      _xsd_ksp_preconditioner_type_indexes_[9] =
      {
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::bjacobi,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::blockdiagonal,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::hypre,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::jacobi,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::ldufactorisation,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::ml,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::none,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::spai,
        ::chaste::parameters::v2017_1::ksp_preconditioner_type::twolevelsblockdiagonal
      };

      // mesh_partitioning_type
      //

      mesh_partitioning_type::
      mesh_partitioning_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_mesh_partitioning_type_convert ();
      }

      mesh_partitioning_type::
      mesh_partitioning_type (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_mesh_partitioning_type_convert ();
      }

      mesh_partitioning_type::
      mesh_partitioning_type (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_mesh_partitioning_type_convert ();
      }

      mesh_partitioning_type* mesh_partitioning_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class mesh_partitioning_type (*this, f, c);
      }

      mesh_partitioning_type::value mesh_partitioning_type::
      _xsd_mesh_partitioning_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_mesh_partitioning_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_mesh_partitioning_type_indexes_,
                          _xsd_mesh_partitioning_type_indexes_ + 4,
                          *this,
                          c));

        if (i == _xsd_mesh_partitioning_type_indexes_ + 4 || _xsd_mesh_partitioning_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const mesh_partitioning_type::
      _xsd_mesh_partitioning_type_literals_[4] =
      {
        "dumb",
        "parmetis",
        "metis",
        "petsc"
      };

      const mesh_partitioning_type::value mesh_partitioning_type::
      _xsd_mesh_partitioning_type_indexes_[4] =
      {
        ::chaste::parameters::v2017_1::mesh_partitioning_type::dumb,
        ::chaste::parameters::v2017_1::mesh_partitioning_type::metis,
        ::chaste::parameters::v2017_1::mesh_partitioning_type::parmetis,
        ::chaste::parameters::v2017_1::mesh_partitioning_type::petsc
      };

      // checkpoint_type
      //

      const checkpoint_type::unit_type checkpoint_type::unit_default_value_ (
        "ms");

      checkpoint_type::
      checkpoint_type (const timestep_type& timestep,
                       const max_checkpoints_on_disk_type& max_checkpoints_on_disk)
      : ::xml_schema::type (),
        timestep_ (timestep, this),
        max_checkpoints_on_disk_ (max_checkpoints_on_disk, this),
        unit_ (unit_default_value (), this)
      {
      }

      checkpoint_type::
      checkpoint_type (const checkpoint_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        timestep_ (x.timestep_, f, this),
        max_checkpoints_on_disk_ (x.max_checkpoints_on_disk_, f, this),
        unit_ (x.unit_, f, this)
      {
      }

      checkpoint_type::
      checkpoint_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        timestep_ (this),
        max_checkpoints_on_disk_ (this),
        unit_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void checkpoint_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "timestep" && n.namespace_ ().empty ())
          {
            this->timestep_.set (timestep_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "max_checkpoints_on_disk" && n.namespace_ ().empty ())
          {
            this->max_checkpoints_on_disk_.set (max_checkpoints_on_disk_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }
        }

        if (!timestep_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "timestep",
            "");
        }

        if (!max_checkpoints_on_disk_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "max_checkpoints_on_disk",
            "");
        }

        if (!unit_.present ())
        {
          this->unit_.set (unit_default_value ());
        }
      }

      checkpoint_type* checkpoint_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class checkpoint_type (*this, f, c);
      }

      checkpoint_type& checkpoint_type::
      operator= (const checkpoint_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->timestep_ = x.timestep_;
          this->max_checkpoints_on_disk_ = x.max_checkpoints_on_disk_;
          this->unit_ = x.unit_;
        }

        return *this;
      }

      checkpoint_type::
      ~checkpoint_type ()
      {
      }

      // adaptivity_parameters_type
      //

      adaptivity_parameters_type::
      adaptivity_parameters_type (const target_error_type& target_error,
                                  const sigma_type& sigma,
                                  const max_edge_length_type& max_edge_length,
                                  const min_edge_length_type& min_edge_length,
                                  const gradation_type& gradation,
                                  const max_nodes_type& max_nodes,
                                  const num_sweeps_type& num_sweeps)
      : ::xml_schema::type (),
        target_error_ (target_error, this),
        sigma_ (sigma, this),
        max_edge_length_ (max_edge_length, this),
        min_edge_length_ (min_edge_length, this),
        gradation_ (gradation, this),
        max_nodes_ (max_nodes, this),
        num_sweeps_ (num_sweeps, this)
      {
      }

      adaptivity_parameters_type::
      adaptivity_parameters_type (const adaptivity_parameters_type& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        target_error_ (x.target_error_, f, this),
        sigma_ (x.sigma_, f, this),
        max_edge_length_ (x.max_edge_length_, f, this),
        min_edge_length_ (x.min_edge_length_, f, this),
        gradation_ (x.gradation_, f, this),
        max_nodes_ (x.max_nodes_, f, this),
        num_sweeps_ (x.num_sweeps_, f, this)
      {
      }

      adaptivity_parameters_type::
      adaptivity_parameters_type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        target_error_ (this),
        sigma_ (this),
        max_edge_length_ (this),
        min_edge_length_ (this),
        gradation_ (this),
        max_nodes_ (this),
        num_sweeps_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void adaptivity_parameters_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "target_error" && n.namespace_ ().empty ())
          {
            this->target_error_.set (target_error_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "sigma" && n.namespace_ ().empty ())
          {
            this->sigma_.set (sigma_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "max_edge_length" && n.namespace_ ().empty ())
          {
            this->max_edge_length_.set (max_edge_length_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "min_edge_length" && n.namespace_ ().empty ())
          {
            this->min_edge_length_.set (min_edge_length_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "gradation" && n.namespace_ ().empty ())
          {
            this->gradation_.set (gradation_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "max_nodes" && n.namespace_ ().empty ())
          {
            this->max_nodes_.set (max_nodes_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "num_sweeps" && n.namespace_ ().empty ())
          {
            this->num_sweeps_.set (num_sweeps_traits::create (i, f, this));
            continue;
          }
        }

        if (!target_error_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "target_error",
            "");
        }

        if (!sigma_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "sigma",
            "");
        }

        if (!max_edge_length_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "max_edge_length",
            "");
        }

        if (!min_edge_length_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "min_edge_length",
            "");
        }

        if (!gradation_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "gradation",
            "");
        }

        if (!max_nodes_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "max_nodes",
            "");
        }

        if (!num_sweeps_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "num_sweeps",
            "");
        }
      }

      adaptivity_parameters_type* adaptivity_parameters_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class adaptivity_parameters_type (*this, f, c);
      }

      adaptivity_parameters_type& adaptivity_parameters_type::
      operator= (const adaptivity_parameters_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->target_error_ = x.target_error_;
          this->sigma_ = x.sigma_;
          this->max_edge_length_ = x.max_edge_length_;
          this->min_edge_length_ = x.min_edge_length_;
          this->gradation_ = x.gradation_;
          this->max_nodes_ = x.max_nodes_;
          this->num_sweeps_ = x.num_sweeps_;
        }

        return *this;
      }

      adaptivity_parameters_type::
      ~adaptivity_parameters_type ()
      {
      }

      // cell_heterogeneities_type
      //

      cell_heterogeneities_type::
      cell_heterogeneities_type ()
      : ::xml_schema::type (),
        CellHeterogeneity_ (this)
      {
      }

      cell_heterogeneities_type::
      cell_heterogeneities_type (const cell_heterogeneities_type& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        CellHeterogeneity_ (x.CellHeterogeneity_, f, this)
      {
      }

      cell_heterogeneities_type::
      cell_heterogeneities_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        CellHeterogeneity_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void cell_heterogeneities_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // CellHeterogeneity
          //
          if (n.name () == "CellHeterogeneity" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< CellHeterogeneity_type > r (
              CellHeterogeneity_traits::create (i, f, this));

            this->CellHeterogeneity_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      cell_heterogeneities_type* cell_heterogeneities_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class cell_heterogeneities_type (*this, f, c);
      }

      cell_heterogeneities_type& cell_heterogeneities_type::
      operator= (const cell_heterogeneities_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->CellHeterogeneity_ = x.CellHeterogeneity_;
        }

        return *this;
      }

      cell_heterogeneities_type::
      ~cell_heterogeneities_type ()
      {
      }

      // stimuli_type
      //

      stimuli_type::
      stimuli_type ()
      : ::xml_schema::type (),
        Stimulus_ (this)
      {
      }

      stimuli_type::
      stimuli_type (const stimuli_type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Stimulus_ (x.Stimulus_, f, this)
      {
      }

      stimuli_type::
      stimuli_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Stimulus_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void stimuli_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Stimulus
          //
          if (n.name () == "Stimulus" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Stimulus_type > r (
              Stimulus_traits::create (i, f, this));

            this->Stimulus_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      stimuli_type* stimuli_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class stimuli_type (*this, f, c);
      }

      stimuli_type& stimuli_type::
      operator= (const stimuli_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Stimulus_ = x.Stimulus_;
        }

        return *this;
      }

      stimuli_type::
      ~stimuli_type ()
      {
      }

      // simulation_type
      //

      const simulation_type::OutputUsingOriginalNodeOrdering_type simulation_type::OutputUsingOriginalNodeOrdering_default_value_ (
        "no");

      simulation_type::
      simulation_type ()
      : ::xml_schema::type (),
        SpaceDimension_ (this),
        SimulationDuration_ (this),
        Domain_ (this),
        Purkinje_ (this),
        Mesh_ (this),
        IonicModels_ (this),
        Stimuli_ (this),
        Electrodes_ (this),
        CellHeterogeneities_ (this),
        OutputDirectory_ (this),
        OutputFilenamePrefix_ (this),
        OutputVariables_ (this),
        OutputVisualizer_ (this),
        OutputUsingOriginalNodeOrdering_ (this),
        CheckpointSimulation_ (this)
      {
      }

      simulation_type::
      simulation_type (const simulation_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        SpaceDimension_ (x.SpaceDimension_, f, this),
        SimulationDuration_ (x.SimulationDuration_, f, this),
        Domain_ (x.Domain_, f, this),
        Purkinje_ (x.Purkinje_, f, this),
        Mesh_ (x.Mesh_, f, this),
        IonicModels_ (x.IonicModels_, f, this),
        Stimuli_ (x.Stimuli_, f, this),
        Electrodes_ (x.Electrodes_, f, this),
        CellHeterogeneities_ (x.CellHeterogeneities_, f, this),
        OutputDirectory_ (x.OutputDirectory_, f, this),
        OutputFilenamePrefix_ (x.OutputFilenamePrefix_, f, this),
        OutputVariables_ (x.OutputVariables_, f, this),
        OutputVisualizer_ (x.OutputVisualizer_, f, this),
        OutputUsingOriginalNodeOrdering_ (x.OutputUsingOriginalNodeOrdering_, f, this),
        CheckpointSimulation_ (x.CheckpointSimulation_, f, this)
      {
      }

      simulation_type::
      simulation_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        SpaceDimension_ (this),
        SimulationDuration_ (this),
        Domain_ (this),
        Purkinje_ (this),
        Mesh_ (this),
        IonicModels_ (this),
        Stimuli_ (this),
        Electrodes_ (this),
        CellHeterogeneities_ (this),
        OutputDirectory_ (this),
        OutputFilenamePrefix_ (this),
        OutputVariables_ (this),
        OutputVisualizer_ (this),
        OutputUsingOriginalNodeOrdering_ (this),
        CheckpointSimulation_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void simulation_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // SpaceDimension
          //
          if (n.name () == "SpaceDimension" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            if (!this->SpaceDimension_)
            {
              this->SpaceDimension_.set (SpaceDimension_traits::create (i, f, this));
              continue;
            }
          }

          // SimulationDuration
          //
          if (n.name () == "SimulationDuration" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< SimulationDuration_type > r (
              SimulationDuration_traits::create (i, f, this));

            if (!this->SimulationDuration_)
            {
              this->SimulationDuration_.set (::std::move (r));
              continue;
            }
          }

          // Domain
          //
          if (n.name () == "Domain" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Domain_type > r (
              Domain_traits::create (i, f, this));

            if (!this->Domain_)
            {
              this->Domain_.set (::std::move (r));
              continue;
            }
          }

          // Purkinje
          //
          if (n.name () == "Purkinje" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Purkinje_type > r (
              Purkinje_traits::create (i, f, this));

            if (!this->Purkinje_)
            {
              this->Purkinje_.set (::std::move (r));
              continue;
            }
          }

          // Mesh
          //
          if (n.name () == "Mesh" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Mesh_type > r (
              Mesh_traits::create (i, f, this));

            if (!this->Mesh_)
            {
              this->Mesh_.set (::std::move (r));
              continue;
            }
          }

          // IonicModels
          //
          if (n.name () == "IonicModels" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< IonicModels_type > r (
              IonicModels_traits::create (i, f, this));

            if (!this->IonicModels_)
            {
              this->IonicModels_.set (::std::move (r));
              continue;
            }
          }

          // Stimuli
          //
          if (n.name () == "Stimuli" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Stimuli_type > r (
              Stimuli_traits::create (i, f, this));

            if (!this->Stimuli_)
            {
              this->Stimuli_.set (::std::move (r));
              continue;
            }
          }

          // Electrodes
          //
          if (n.name () == "Electrodes" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Electrodes_type > r (
              Electrodes_traits::create (i, f, this));

            if (!this->Electrodes_)
            {
              this->Electrodes_.set (::std::move (r));
              continue;
            }
          }

          // CellHeterogeneities
          //
          if (n.name () == "CellHeterogeneities" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< CellHeterogeneities_type > r (
              CellHeterogeneities_traits::create (i, f, this));

            if (!this->CellHeterogeneities_)
            {
              this->CellHeterogeneities_.set (::std::move (r));
              continue;
            }
          }

          // OutputDirectory
          //
          if (n.name () == "OutputDirectory" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< OutputDirectory_type > r (
              OutputDirectory_traits::create (i, f, this));

            if (!this->OutputDirectory_)
            {
              this->OutputDirectory_.set (::std::move (r));
              continue;
            }
          }

          // OutputFilenamePrefix
          //
          if (n.name () == "OutputFilenamePrefix" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< OutputFilenamePrefix_type > r (
              OutputFilenamePrefix_traits::create (i, f, this));

            if (!this->OutputFilenamePrefix_)
            {
              this->OutputFilenamePrefix_.set (::std::move (r));
              continue;
            }
          }

          // OutputVariables
          //
          if (n.name () == "OutputVariables" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< OutputVariables_type > r (
              OutputVariables_traits::create (i, f, this));

            if (!this->OutputVariables_)
            {
              this->OutputVariables_.set (::std::move (r));
              continue;
            }
          }

          // OutputVisualizer
          //
          if (n.name () == "OutputVisualizer" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< OutputVisualizer_type > r (
              OutputVisualizer_traits::create (i, f, this));

            if (!this->OutputVisualizer_)
            {
              this->OutputVisualizer_.set (::std::move (r));
              continue;
            }
          }

          // OutputUsingOriginalNodeOrdering
          //
          if (n.name () == "OutputUsingOriginalNodeOrdering" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< OutputUsingOriginalNodeOrdering_type > r (
              OutputUsingOriginalNodeOrdering_traits::create (i, f, this));

            if (!this->OutputUsingOriginalNodeOrdering_)
            {
              this->OutputUsingOriginalNodeOrdering_.set (::std::move (r));
              continue;
            }
          }

          // CheckpointSimulation
          //
          if (n.name () == "CheckpointSimulation" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< CheckpointSimulation_type > r (
              CheckpointSimulation_traits::create (i, f, this));

            if (!this->CheckpointSimulation_)
            {
              this->CheckpointSimulation_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      simulation_type* simulation_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class simulation_type (*this, f, c);
      }

      simulation_type& simulation_type::
      operator= (const simulation_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->SpaceDimension_ = x.SpaceDimension_;
          this->SimulationDuration_ = x.SimulationDuration_;
          this->Domain_ = x.Domain_;
          this->Purkinje_ = x.Purkinje_;
          this->Mesh_ = x.Mesh_;
          this->IonicModels_ = x.IonicModels_;
          this->Stimuli_ = x.Stimuli_;
          this->Electrodes_ = x.Electrodes_;
          this->CellHeterogeneities_ = x.CellHeterogeneities_;
          this->OutputDirectory_ = x.OutputDirectory_;
          this->OutputFilenamePrefix_ = x.OutputFilenamePrefix_;
          this->OutputVariables_ = x.OutputVariables_;
          this->OutputVisualizer_ = x.OutputVisualizer_;
          this->OutputUsingOriginalNodeOrdering_ = x.OutputUsingOriginalNodeOrdering_;
          this->CheckpointSimulation_ = x.CheckpointSimulation_;
        }

        return *this;
      }

      simulation_type::
      ~simulation_type ()
      {
      }

      // resume_simulation_type
      //

      resume_simulation_type::
      resume_simulation_type (const ArchiveDirectory_type& ArchiveDirectory,
                              const SpaceDimension_type& SpaceDimension,
                              const Domain_type& Domain,
                              const SimulationDuration_type& SimulationDuration)
      : ::xml_schema::type (),
        ArchiveDirectory_ (ArchiveDirectory, this),
        SpaceDimension_ (SpaceDimension, this),
        Domain_ (Domain, this),
        SimulationDuration_ (SimulationDuration, this),
        Stimuli_ (this),
        CellHeterogeneities_ (this),
        CheckpointSimulation_ (this),
        OutputVisualizer_ (this)
      {
      }

      resume_simulation_type::
      resume_simulation_type (::std::unique_ptr< ArchiveDirectory_type > ArchiveDirectory,
                              const SpaceDimension_type& SpaceDimension,
                              const Domain_type& Domain,
                              ::std::unique_ptr< SimulationDuration_type > SimulationDuration)
      : ::xml_schema::type (),
        ArchiveDirectory_ (std::move (ArchiveDirectory), this),
        SpaceDimension_ (SpaceDimension, this),
        Domain_ (Domain, this),
        SimulationDuration_ (std::move (SimulationDuration), this),
        Stimuli_ (this),
        CellHeterogeneities_ (this),
        CheckpointSimulation_ (this),
        OutputVisualizer_ (this)
      {
      }

      resume_simulation_type::
      resume_simulation_type (const resume_simulation_type& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        ArchiveDirectory_ (x.ArchiveDirectory_, f, this),
        SpaceDimension_ (x.SpaceDimension_, f, this),
        Domain_ (x.Domain_, f, this),
        SimulationDuration_ (x.SimulationDuration_, f, this),
        Stimuli_ (x.Stimuli_, f, this),
        CellHeterogeneities_ (x.CellHeterogeneities_, f, this),
        CheckpointSimulation_ (x.CheckpointSimulation_, f, this),
        OutputVisualizer_ (x.OutputVisualizer_, f, this)
      {
      }

      resume_simulation_type::
      resume_simulation_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        ArchiveDirectory_ (this),
        SpaceDimension_ (this),
        Domain_ (this),
        SimulationDuration_ (this),
        Stimuli_ (this),
        CellHeterogeneities_ (this),
        CheckpointSimulation_ (this),
        OutputVisualizer_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void resume_simulation_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // ArchiveDirectory
          //
          if (n.name () == "ArchiveDirectory" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ArchiveDirectory_type > r (
              ArchiveDirectory_traits::create (i, f, this));

            if (!ArchiveDirectory_.present ())
            {
              this->ArchiveDirectory_.set (::std::move (r));
              continue;
            }
          }

          // SpaceDimension
          //
          if (n.name () == "SpaceDimension" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            if (!SpaceDimension_.present ())
            {
              this->SpaceDimension_.set (SpaceDimension_traits::create (i, f, this));
              continue;
            }
          }

          // Domain
          //
          if (n.name () == "Domain" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Domain_type > r (
              Domain_traits::create (i, f, this));

            if (!Domain_.present ())
            {
              this->Domain_.set (::std::move (r));
              continue;
            }
          }

          // SimulationDuration
          //
          if (n.name () == "SimulationDuration" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< SimulationDuration_type > r (
              SimulationDuration_traits::create (i, f, this));

            if (!SimulationDuration_.present ())
            {
              this->SimulationDuration_.set (::std::move (r));
              continue;
            }
          }

          // Stimuli
          //
          if (n.name () == "Stimuli" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Stimuli_type > r (
              Stimuli_traits::create (i, f, this));

            if (!this->Stimuli_)
            {
              this->Stimuli_.set (::std::move (r));
              continue;
            }
          }

          // CellHeterogeneities
          //
          if (n.name () == "CellHeterogeneities" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< CellHeterogeneities_type > r (
              CellHeterogeneities_traits::create (i, f, this));

            if (!this->CellHeterogeneities_)
            {
              this->CellHeterogeneities_.set (::std::move (r));
              continue;
            }
          }

          // CheckpointSimulation
          //
          if (n.name () == "CheckpointSimulation" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< CheckpointSimulation_type > r (
              CheckpointSimulation_traits::create (i, f, this));

            if (!this->CheckpointSimulation_)
            {
              this->CheckpointSimulation_.set (::std::move (r));
              continue;
            }
          }

          // OutputVisualizer
          //
          if (n.name () == "OutputVisualizer" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< OutputVisualizer_type > r (
              OutputVisualizer_traits::create (i, f, this));

            if (!this->OutputVisualizer_)
            {
              this->OutputVisualizer_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!ArchiveDirectory_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "ArchiveDirectory",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!SpaceDimension_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "SpaceDimension",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Domain_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Domain",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!SimulationDuration_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "SimulationDuration",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      resume_simulation_type* resume_simulation_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class resume_simulation_type (*this, f, c);
      }

      resume_simulation_type& resume_simulation_type::
      operator= (const resume_simulation_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->ArchiveDirectory_ = x.ArchiveDirectory_;
          this->SpaceDimension_ = x.SpaceDimension_;
          this->Domain_ = x.Domain_;
          this->SimulationDuration_ = x.SimulationDuration_;
          this->Stimuli_ = x.Stimuli_;
          this->CellHeterogeneities_ = x.CellHeterogeneities_;
          this->CheckpointSimulation_ = x.CheckpointSimulation_;
          this->OutputVisualizer_ = x.OutputVisualizer_;
        }

        return *this;
      }

      resume_simulation_type::
      ~resume_simulation_type ()
      {
      }

      // physiological_type
      //

      physiological_type::
      physiological_type ()
      : ::xml_schema::type (),
        IntracellularConductivities_ (this),
        ExtracellularConductivities_ (this),
        BathConductivity_ (this),
        ConductivityHeterogeneities_ (this),
        SurfaceAreaToVolumeRatio_ (this),
        Capacitance_ (this),
        ApplyDrug_ (this),
        Purkinje_ (this)
      {
      }

      physiological_type::
      physiological_type (const physiological_type& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        IntracellularConductivities_ (x.IntracellularConductivities_, f, this),
        ExtracellularConductivities_ (x.ExtracellularConductivities_, f, this),
        BathConductivity_ (x.BathConductivity_, f, this),
        ConductivityHeterogeneities_ (x.ConductivityHeterogeneities_, f, this),
        SurfaceAreaToVolumeRatio_ (x.SurfaceAreaToVolumeRatio_, f, this),
        Capacitance_ (x.Capacitance_, f, this),
        ApplyDrug_ (x.ApplyDrug_, f, this),
        Purkinje_ (x.Purkinje_, f, this)
      {
      }

      physiological_type::
      physiological_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        IntracellularConductivities_ (this),
        ExtracellularConductivities_ (this),
        BathConductivity_ (this),
        ConductivityHeterogeneities_ (this),
        SurfaceAreaToVolumeRatio_ (this),
        Capacitance_ (this),
        ApplyDrug_ (this),
        Purkinje_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void physiological_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // IntracellularConductivities
          //
          if (n.name () == "IntracellularConductivities" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< IntracellularConductivities_type > r (
              IntracellularConductivities_traits::create (i, f, this));

            if (!this->IntracellularConductivities_)
            {
              this->IntracellularConductivities_.set (::std::move (r));
              continue;
            }
          }

          // ExtracellularConductivities
          //
          if (n.name () == "ExtracellularConductivities" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ExtracellularConductivities_type > r (
              ExtracellularConductivities_traits::create (i, f, this));

            if (!this->ExtracellularConductivities_)
            {
              this->ExtracellularConductivities_.set (::std::move (r));
              continue;
            }
          }

          // BathConductivity
          //
          if (n.name () == "BathConductivity" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< BathConductivity_type > r (
              BathConductivity_traits::create (i, f, this));

            if (!this->BathConductivity_)
            {
              this->BathConductivity_.set (::std::move (r));
              continue;
            }
          }

          // ConductivityHeterogeneities
          //
          if (n.name () == "ConductivityHeterogeneities" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ConductivityHeterogeneities_type > r (
              ConductivityHeterogeneities_traits::create (i, f, this));

            if (!this->ConductivityHeterogeneities_)
            {
              this->ConductivityHeterogeneities_.set (::std::move (r));
              continue;
            }
          }

          // SurfaceAreaToVolumeRatio
          //
          if (n.name () == "SurfaceAreaToVolumeRatio" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< SurfaceAreaToVolumeRatio_type > r (
              SurfaceAreaToVolumeRatio_traits::create (i, f, this));

            if (!this->SurfaceAreaToVolumeRatio_)
            {
              this->SurfaceAreaToVolumeRatio_.set (::std::move (r));
              continue;
            }
          }

          // Capacitance
          //
          if (n.name () == "Capacitance" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Capacitance_type > r (
              Capacitance_traits::create (i, f, this));

            if (!this->Capacitance_)
            {
              this->Capacitance_.set (::std::move (r));
              continue;
            }
          }

          // ApplyDrug
          //
          if (n.name () == "ApplyDrug" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ApplyDrug_type > r (
              ApplyDrug_traits::create (i, f, this));

            if (!this->ApplyDrug_)
            {
              this->ApplyDrug_.set (::std::move (r));
              continue;
            }
          }

          // Purkinje
          //
          if (n.name () == "Purkinje" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Purkinje_type > r (
              Purkinje_traits::create (i, f, this));

            if (!this->Purkinje_)
            {
              this->Purkinje_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      physiological_type* physiological_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class physiological_type (*this, f, c);
      }

      physiological_type& physiological_type::
      operator= (const physiological_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->IntracellularConductivities_ = x.IntracellularConductivities_;
          this->ExtracellularConductivities_ = x.ExtracellularConductivities_;
          this->BathConductivity_ = x.BathConductivity_;
          this->ConductivityHeterogeneities_ = x.ConductivityHeterogeneities_;
          this->SurfaceAreaToVolumeRatio_ = x.SurfaceAreaToVolumeRatio_;
          this->Capacitance_ = x.Capacitance_;
          this->ApplyDrug_ = x.ApplyDrug_;
          this->Purkinje_ = x.Purkinje_;
        }

        return *this;
      }

      physiological_type::
      ~physiological_type ()
      {
      }

      // numerical_type
      //

      numerical_type::
      numerical_type ()
      : ::xml_schema::type (),
        TimeSteps_ (this),
        KSPTolerances_ (this),
        KSPSolver_ (this),
        KSPPreconditioner_ (this),
        MeshPartitioning_ (this),
        UseStateVariableInterpolation_ (this),
        AdaptivityParameters_ (this)
      {
      }

      numerical_type::
      numerical_type (const numerical_type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        TimeSteps_ (x.TimeSteps_, f, this),
        KSPTolerances_ (x.KSPTolerances_, f, this),
        KSPSolver_ (x.KSPSolver_, f, this),
        KSPPreconditioner_ (x.KSPPreconditioner_, f, this),
        MeshPartitioning_ (x.MeshPartitioning_, f, this),
        UseStateVariableInterpolation_ (x.UseStateVariableInterpolation_, f, this),
        AdaptivityParameters_ (x.AdaptivityParameters_, f, this)
      {
      }

      numerical_type::
      numerical_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        TimeSteps_ (this),
        KSPTolerances_ (this),
        KSPSolver_ (this),
        KSPPreconditioner_ (this),
        MeshPartitioning_ (this),
        UseStateVariableInterpolation_ (this),
        AdaptivityParameters_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void numerical_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // TimeSteps
          //
          if (n.name () == "TimeSteps" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< TimeSteps_type > r (
              TimeSteps_traits::create (i, f, this));

            if (!this->TimeSteps_)
            {
              this->TimeSteps_.set (::std::move (r));
              continue;
            }
          }

          // KSPTolerances
          //
          if (n.name () == "KSPTolerances" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< KSPTolerances_type > r (
              KSPTolerances_traits::create (i, f, this));

            if (!this->KSPTolerances_)
            {
              this->KSPTolerances_.set (::std::move (r));
              continue;
            }
          }

          // KSPSolver
          //
          if (n.name () == "KSPSolver" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< KSPSolver_type > r (
              KSPSolver_traits::create (i, f, this));

            if (!this->KSPSolver_)
            {
              this->KSPSolver_.set (::std::move (r));
              continue;
            }
          }

          // KSPPreconditioner
          //
          if (n.name () == "KSPPreconditioner" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< KSPPreconditioner_type > r (
              KSPPreconditioner_traits::create (i, f, this));

            if (!this->KSPPreconditioner_)
            {
              this->KSPPreconditioner_.set (::std::move (r));
              continue;
            }
          }

          // MeshPartitioning
          //
          if (n.name () == "MeshPartitioning" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< MeshPartitioning_type > r (
              MeshPartitioning_traits::create (i, f, this));

            if (!this->MeshPartitioning_)
            {
              this->MeshPartitioning_.set (::std::move (r));
              continue;
            }
          }

          // UseStateVariableInterpolation
          //
          if (n.name () == "UseStateVariableInterpolation" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< UseStateVariableInterpolation_type > r (
              UseStateVariableInterpolation_traits::create (i, f, this));

            if (!this->UseStateVariableInterpolation_)
            {
              this->UseStateVariableInterpolation_.set (::std::move (r));
              continue;
            }
          }

          // AdaptivityParameters
          //
          if (n.name () == "AdaptivityParameters" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< AdaptivityParameters_type > r (
              AdaptivityParameters_traits::create (i, f, this));

            if (!this->AdaptivityParameters_)
            {
              this->AdaptivityParameters_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      numerical_type* numerical_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class numerical_type (*this, f, c);
      }

      numerical_type& numerical_type::
      operator= (const numerical_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->TimeSteps_ = x.TimeSteps_;
          this->KSPTolerances_ = x.KSPTolerances_;
          this->KSPSolver_ = x.KSPSolver_;
          this->KSPPreconditioner_ = x.KSPPreconditioner_;
          this->MeshPartitioning_ = x.MeshPartitioning_;
          this->UseStateVariableInterpolation_ = x.UseStateVariableInterpolation_;
          this->AdaptivityParameters_ = x.AdaptivityParameters_;
        }

        return *this;
      }

      numerical_type::
      ~numerical_type ()
      {
      }

      // postprocessing_type
      //

      postprocessing_type::
      postprocessing_type ()
      : ::xml_schema::type (),
        ActionPotentialDurationMap_ (this),
        UpstrokeTimeMap_ (this),
        MaxUpstrokeVelocityMap_ (this),
        ConductionVelocityMap_ (this),
        TimeTraceAtNode_ (this),
        PseudoEcgElectrodePosition_ (this)
      {
      }

      postprocessing_type::
      postprocessing_type (const postprocessing_type& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        ActionPotentialDurationMap_ (x.ActionPotentialDurationMap_, f, this),
        UpstrokeTimeMap_ (x.UpstrokeTimeMap_, f, this),
        MaxUpstrokeVelocityMap_ (x.MaxUpstrokeVelocityMap_, f, this),
        ConductionVelocityMap_ (x.ConductionVelocityMap_, f, this),
        TimeTraceAtNode_ (x.TimeTraceAtNode_, f, this),
        PseudoEcgElectrodePosition_ (x.PseudoEcgElectrodePosition_, f, this)
      {
      }

      postprocessing_type::
      postprocessing_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        ActionPotentialDurationMap_ (this),
        UpstrokeTimeMap_ (this),
        MaxUpstrokeVelocityMap_ (this),
        ConductionVelocityMap_ (this),
        TimeTraceAtNode_ (this),
        PseudoEcgElectrodePosition_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void postprocessing_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // ActionPotentialDurationMap
          //
          if (n.name () == "ActionPotentialDurationMap" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ActionPotentialDurationMap_type > r (
              ActionPotentialDurationMap_traits::create (i, f, this));

            this->ActionPotentialDurationMap_.push_back (::std::move (r));
            continue;
          }

          // UpstrokeTimeMap
          //
          if (n.name () == "UpstrokeTimeMap" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< UpstrokeTimeMap_type > r (
              UpstrokeTimeMap_traits::create (i, f, this));

            this->UpstrokeTimeMap_.push_back (::std::move (r));
            continue;
          }

          // MaxUpstrokeVelocityMap
          //
          if (n.name () == "MaxUpstrokeVelocityMap" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< MaxUpstrokeVelocityMap_type > r (
              MaxUpstrokeVelocityMap_traits::create (i, f, this));

            this->MaxUpstrokeVelocityMap_.push_back (::std::move (r));
            continue;
          }

          // ConductionVelocityMap
          //
          if (n.name () == "ConductionVelocityMap" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ConductionVelocityMap_type > r (
              ConductionVelocityMap_traits::create (i, f, this));

            this->ConductionVelocityMap_.push_back (::std::move (r));
            continue;
          }

          // TimeTraceAtNode
          //
          if (n.name () == "TimeTraceAtNode" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< TimeTraceAtNode_type > r (
              TimeTraceAtNode_traits::create (i, f, this));

            this->TimeTraceAtNode_.push_back (::std::move (r));
            continue;
          }

          // PseudoEcgElectrodePosition
          //
          if (n.name () == "PseudoEcgElectrodePosition" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< PseudoEcgElectrodePosition_type > r (
              PseudoEcgElectrodePosition_traits::create (i, f, this));

            this->PseudoEcgElectrodePosition_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      postprocessing_type* postprocessing_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class postprocessing_type (*this, f, c);
      }

      postprocessing_type& postprocessing_type::
      operator= (const postprocessing_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->ActionPotentialDurationMap_ = x.ActionPotentialDurationMap_;
          this->UpstrokeTimeMap_ = x.UpstrokeTimeMap_;
          this->MaxUpstrokeVelocityMap_ = x.MaxUpstrokeVelocityMap_;
          this->ConductionVelocityMap_ = x.ConductionVelocityMap_;
          this->TimeTraceAtNode_ = x.TimeTraceAtNode_;
          this->PseudoEcgElectrodePosition_ = x.PseudoEcgElectrodePosition_;
        }

        return *this;
      }

      postprocessing_type::
      ~postprocessing_type ()
      {
      }

      // chaste_parameters_type
      //

      chaste_parameters_type::
      chaste_parameters_type (const Physiological_type& Physiological,
                              const Numerical_type& Numerical)
      : ::xml_schema::type (),
        Simulation_ (this),
        ResumeSimulation_ (this),
        Physiological_ (Physiological, this),
        Numerical_ (Numerical, this),
        PostProcessing_ (this)
      {
      }

      chaste_parameters_type::
      chaste_parameters_type (::std::unique_ptr< Physiological_type > Physiological,
                              ::std::unique_ptr< Numerical_type > Numerical)
      : ::xml_schema::type (),
        Simulation_ (this),
        ResumeSimulation_ (this),
        Physiological_ (std::move (Physiological), this),
        Numerical_ (std::move (Numerical), this),
        PostProcessing_ (this)
      {
      }

      chaste_parameters_type::
      chaste_parameters_type (const chaste_parameters_type& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Simulation_ (x.Simulation_, f, this),
        ResumeSimulation_ (x.ResumeSimulation_, f, this),
        Physiological_ (x.Physiological_, f, this),
        Numerical_ (x.Numerical_, f, this),
        PostProcessing_ (x.PostProcessing_, f, this)
      {
      }

      chaste_parameters_type::
      chaste_parameters_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Simulation_ (this),
        ResumeSimulation_ (this),
        Physiological_ (this),
        Numerical_ (this),
        PostProcessing_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void chaste_parameters_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // Simulation
          //
          if (n.name () == "Simulation" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Simulation_type > r (
              Simulation_traits::create (i, f, this));

            if (!this->Simulation_)
            {
              this->Simulation_.set (::std::move (r));
              continue;
            }
          }

          // ResumeSimulation
          //
          if (n.name () == "ResumeSimulation" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ResumeSimulation_type > r (
              ResumeSimulation_traits::create (i, f, this));

            if (!this->ResumeSimulation_)
            {
              this->ResumeSimulation_.set (::std::move (r));
              continue;
            }
          }

          // Physiological
          //
          if (n.name () == "Physiological" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Physiological_type > r (
              Physiological_traits::create (i, f, this));

            if (!Physiological_.present ())
            {
              this->Physiological_.set (::std::move (r));
              continue;
            }
          }

          // Numerical
          //
          if (n.name () == "Numerical" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Numerical_type > r (
              Numerical_traits::create (i, f, this));

            if (!Numerical_.present ())
            {
              this->Numerical_.set (::std::move (r));
              continue;
            }
          }

          // PostProcessing
          //
          if (n.name () == "PostProcessing" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< PostProcessing_type > r (
              PostProcessing_traits::create (i, f, this));

            if (!this->PostProcessing_)
            {
              this->PostProcessing_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!Physiological_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Physiological",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }

        if (!Numerical_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "Numerical",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      chaste_parameters_type* chaste_parameters_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class chaste_parameters_type (*this, f, c);
      }

      chaste_parameters_type& chaste_parameters_type::
      operator= (const chaste_parameters_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->Simulation_ = x.Simulation_;
          this->ResumeSimulation_ = x.ResumeSimulation_;
          this->Physiological_ = x.Physiological_;
          this->Numerical_ = x.Numerical_;
          this->PostProcessing_ = x.PostProcessing_;
        }

        return *this;
      }

      chaste_parameters_type::
      ~chaste_parameters_type ()
      {
      }

      // purkinje_physiological_type
      //

      purkinje_physiological_type::
      purkinje_physiological_type ()
      : ::xml_schema::type (),
        SurfaceAreaToVolumeRatio_ (this),
        Capacitance_ (this),
        Conductivity_ (this)
      {
      }

      purkinje_physiological_type::
      purkinje_physiological_type (const purkinje_physiological_type& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        SurfaceAreaToVolumeRatio_ (x.SurfaceAreaToVolumeRatio_, f, this),
        Capacitance_ (x.Capacitance_, f, this),
        Conductivity_ (x.Conductivity_, f, this)
      {
      }

      purkinje_physiological_type::
      purkinje_physiological_type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        SurfaceAreaToVolumeRatio_ (this),
        Capacitance_ (this),
        Conductivity_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void purkinje_physiological_type::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // SurfaceAreaToVolumeRatio
          //
          if (n.name () == "SurfaceAreaToVolumeRatio" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< SurfaceAreaToVolumeRatio_type > r (
              SurfaceAreaToVolumeRatio_traits::create (i, f, this));

            if (!this->SurfaceAreaToVolumeRatio_)
            {
              this->SurfaceAreaToVolumeRatio_.set (::std::move (r));
              continue;
            }
          }

          // Capacitance
          //
          if (n.name () == "Capacitance" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Capacitance_type > r (
              Capacitance_traits::create (i, f, this));

            if (!this->Capacitance_)
            {
              this->Capacitance_.set (::std::move (r));
              continue;
            }
          }

          // Conductivity
          //
          if (n.name () == "Conductivity" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< Conductivity_type > r (
              Conductivity_traits::create (i, f, this));

            if (!this->Conductivity_)
            {
              this->Conductivity_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      purkinje_physiological_type* purkinje_physiological_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class purkinje_physiological_type (*this, f, c);
      }

      purkinje_physiological_type& purkinje_physiological_type::
      operator= (const purkinje_physiological_type& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->SurfaceAreaToVolumeRatio_ = x.SurfaceAreaToVolumeRatio_;
          this->Capacitance_ = x.Capacitance_;
          this->Conductivity_ = x.Conductivity_;
        }

        return *this;
      }

      purkinje_physiological_type::
      ~purkinje_physiological_type ()
      {
      }

      // purkinje_simulation_type
      //

      purkinje_simulation_type::
      purkinje_simulation_type ()
      : ::xml_schema::type ()
      {
      }

      purkinje_simulation_type::
      purkinje_simulation_type (const purkinje_simulation_type& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c)
      {
      }

      purkinje_simulation_type::
      purkinje_simulation_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
      : ::xml_schema::type (e, f, c)
      {
      }

      purkinje_simulation_type::
      purkinje_simulation_type (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
      : ::xml_schema::type (a, f, c)
      {
      }

      purkinje_simulation_type::
      purkinje_simulation_type (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
      : ::xml_schema::type (s, e, f, c)
      {
      }

      purkinje_simulation_type* purkinje_simulation_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class purkinje_simulation_type (*this, f, c);
      }

      purkinje_simulation_type::
      ~purkinje_simulation_type ()
      {
      }

      // ConductivityHeterogeneities
      //

      ConductivityHeterogeneities::
      ConductivityHeterogeneities ()
      : ::xml_schema::type (),
        ConductivityHeterogeneity_ (this)
      {
      }

      ConductivityHeterogeneities::
      ConductivityHeterogeneities (const ConductivityHeterogeneities& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        ConductivityHeterogeneity_ (x.ConductivityHeterogeneity_, f, this)
      {
      }

      ConductivityHeterogeneities::
      ConductivityHeterogeneities (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        ConductivityHeterogeneity_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ConductivityHeterogeneities::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // ConductivityHeterogeneity
          //
          if (n.name () == "ConductivityHeterogeneity" && n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
          {
            ::std::unique_ptr< ConductivityHeterogeneity_type > r (
              ConductivityHeterogeneity_traits::create (i, f, this));

            this->ConductivityHeterogeneity_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      ConductivityHeterogeneities* ConductivityHeterogeneities::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ConductivityHeterogeneities (*this, f, c);
      }

      ConductivityHeterogeneities& ConductivityHeterogeneities::
      operator= (const ConductivityHeterogeneities& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->ConductivityHeterogeneity_ = x.ConductivityHeterogeneity_;
        }

        return *this;
      }

      ConductivityHeterogeneities::
      ~ConductivityHeterogeneities ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > (
          ::chaste::parameters::v2017_1::ChasteParameters (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > (
          ::chaste::parameters::v2017_1::ChasteParameters (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > (
          ::chaste::parameters::v2017_1::ChasteParameters (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::chaste::parameters::v2017_1::ChasteParameters (isrc, f, p);
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::chaste::parameters::v2017_1::ChasteParameters (isrc, h, f, p);
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::chaste::parameters::v2017_1::ChasteParameters (isrc, h, f, p);
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::chaste::parameters::v2017_1::ChasteParameters (isrc, f, p);
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::chaste::parameters::v2017_1::ChasteParameters (isrc, h, f, p);
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::chaste::parameters::v2017_1::ChasteParameters (isrc, h, f, p);
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > (
          ::chaste::parameters::v2017_1::ChasteParameters (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > (
          ::chaste::parameters::v2017_1::ChasteParameters (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > (
          ::chaste::parameters::v2017_1::ChasteParameters (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
      {
        if (f & ::xml_schema::flags::keep_dom)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > (
            ::chaste::parameters::v2017_1::ChasteParameters (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "ChasteParameters" &&
            n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
        {
          ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > r (
            ::xsd::cxx::tree::traits< ::chaste::parameters::v2017_1::chaste_parameters_type, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "ChasteParameters",
          "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
      }

      ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type >
      ChasteParameters (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::flags::keep_dom) &&
           !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::xml_schema::flags::keep_dom)
          doc.setUserData (::xml_schema::dom::tree_node_key,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "ChasteParameters" &&
            n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
        {
          ::std::unique_ptr< ::chaste::parameters::v2017_1::chaste_parameters_type > r (
            ::xsd::cxx::tree::traits< ::chaste::parameters::v2017_1::chaste_parameters_type, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "ChasteParameters",
          "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace chaste
{
  namespace parameters
  {
    namespace v2017_1
    {
      void
      operator<< (::xercesc::DOMElement& e, const time_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const dimensionless_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const conductivity_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const stimulus_strength_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const surface_stimulus_strength_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const inverse_length_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const capacitance_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const apply_drug_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // IC50
        //
        for (apply_drug_type::IC50_const_iterator
             b (i.IC50 ().begin ()), n (i.IC50 ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IC50",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }

        // concentration
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "concentration",
              e));

          a << ::xml_schema::as_double(i.concentration ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ic50_type& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

        // current
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "current",
              e));

          a << i.current ();
        }

        // hill
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "hill",
              e));

          a << ::xml_schema::as_double(i.hill ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const location_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Cuboid
        //
        if (i.Cuboid ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Cuboid",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Cuboid ();
        }

        // Ellipsoid
        //
        if (i.Ellipsoid ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Ellipsoid",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Ellipsoid ();
        }

        // NotUsed
        //
        if (i.NotUsed ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "NotUsed",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.NotUsed ();
        }

        // EpiLayer
        //
        if (i.EpiLayer ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EpiLayer",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.EpiLayer ();
        }

        // MidLayer
        //
        if (i.MidLayer ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MidLayer",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.MidLayer ();
        }

        // EndoLayer
        //
        if (i.EndoLayer ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndoLayer",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.EndoLayer ();
        }

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const domain_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const domain_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const domain_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const axis_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const axis_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const axis_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const ionic_models_available_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const ionic_models_available_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const ionic_models_available_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const ionic_model_selection_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Hardcoded
        //
        if (i.Hardcoded ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Hardcoded",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Hardcoded ();
        }

        // Dynamic
        //
        if (i.Dynamic ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Dynamic",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Dynamic ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const dynamically_loaded_ionic_model_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Path
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Path",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Path ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const path_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);

        // relative_to
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "relative_to",
              e));

          a << i.relative_to ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const relative_to_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const relative_to_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const relative_to_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const ionic_model_region_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // IonicModel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IonicModel",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.IonicModel ();
        }

        // Location
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Location",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Location ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ionic_models_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Default
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Default",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Default ();
        }

        // Region
        //
        for (ionic_models_type::Region_const_iterator
             b (i.Region ().begin ()), n (i.Region ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Region",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const apd_map_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // repolarisation_percentage
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "repolarisation_percentage",
              e));

          a << ::xml_schema::as_double(i.repolarisation_percentage ());
        }

        // threshold
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "threshold",
              e));

          a << ::xml_schema::as_double(i.threshold ());
        }

        // threshold_unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "threshold_unit",
              e));

          a << i.threshold_unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const upstrokes_map_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // threshold
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "threshold",
              e));

          a << ::xml_schema::as_double(i.threshold ());
        }

        // threshold_unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "threshold_unit",
              e));

          a << i.threshold_unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const max_upstrokes_velocity_map_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // threshold
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "threshold",
              e));

          a << ::xml_schema::as_double(i.threshold ());
        }

        // threshold_unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "threshold_unit",
              e));

          a << i.threshold_unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const conduction_velocity_map_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // origin_node
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "origin_node",
              e));

          a << i.origin_node ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const node_number_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // node_number
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "node_number",
              e));

          a << i.node_number ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const media_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const media_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const media_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const point_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // x
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "x",
              e));

          a << ::xml_schema::as_double(i.x ());
        }

        // y
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "y",
              e));

          a << ::xml_schema::as_double(i.y ());
        }

        // z
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "z",
              e));

          a << ::xml_schema::as_double(i.z ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const box_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // LowerCoordinates
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LowerCoordinates",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.LowerCoordinates ();
        }

        // UpperCoordinates
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UpperCoordinates",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.UpperCoordinates ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ellipsoid_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Centre
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Centre",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Centre ();
        }

        // Radii
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Radii",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Radii ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const stimulus_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Strength
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Strength",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Strength ();
        }

        // Duration
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Duration",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Duration ();
        }

        // Delay
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Delay",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Delay ();
        }

        // Period
        //
        if (i.Period ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Period",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Period ();
        }

        // StopTime
        //
        if (i.StopTime ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StopTime",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.StopTime ();
        }

        // Location
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Location",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Location ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const set_parameter_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }

        // value
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "value",
              e));

          a << ::xml_schema::as_double(i.value ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const electrodes_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // GroundSecondElectrode
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "GroundSecondElectrode",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.GroundSecondElectrode ();
        }

        // PerpendicularToAxis
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PerpendicularToAxis",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.PerpendicularToAxis ();
        }

        // Strength
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Strength",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Strength ();
        }

        // StartTime
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StartTime",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.StartTime ();
        }

        // Duration
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Duration",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Duration ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const cell_heterogeneity_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // ScaleFactorGks
        //
        if (i.ScaleFactorGks ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ScaleFactorGks",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ScaleFactorGks ();
        }

        // ScaleFactorIto
        //
        if (i.ScaleFactorIto ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ScaleFactorIto",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ScaleFactorIto ();
        }

        // ScaleFactorGkr
        //
        if (i.ScaleFactorGkr ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ScaleFactorGkr",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ScaleFactorGkr ();
        }

        // Location
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Location",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Location ();
        }

        // SetParameter
        //
        for (cell_heterogeneity_type::SetParameter_const_iterator
             b (i.SetParameter ().begin ()), n (i.SetParameter ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SetParameter",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const conductivity_heterogeneity_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // IntracellularConductivities
        //
        if (i.IntracellularConductivities ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IntracellularConductivities",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.IntracellularConductivities ();
        }

        // ExtracellularConductivities
        //
        if (i.ExtracellularConductivities ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ExtracellularConductivities",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ExtracellularConductivities ();
        }

        // Location
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Location",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Location ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const slab_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // x
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "x",
              e));

          a << ::xml_schema::as_double(i.x ());
        }

        // y
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "y",
              e));

          a << ::xml_schema::as_double(i.y ());
        }

        // z
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "z",
              e));

          a << ::xml_schema::as_double(i.z ());
        }

        // inter_node_space
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "inter_node_space",
              e));

          a << ::xml_schema::as_double(i.inter_node_space ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const sheet_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // x
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "x",
              e));

          a << ::xml_schema::as_double(i.x ());
        }

        // y
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "y",
              e));

          a << ::xml_schema::as_double(i.y ());
        }

        // inter_node_space
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "inter_node_space",
              e));

          a << ::xml_schema::as_double(i.inter_node_space ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const fibre_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // x
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "x",
              e));

          a << ::xml_schema::as_double(i.x ());
        }

        // inter_node_space
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "inter_node_space",
              e));

          a << ::xml_schema::as_double(i.inter_node_space ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const load_mesh_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }

        // conductivity_media
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "conductivity_media",
              e));

          a << i.conductivity_media ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const mesh_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Slab
        //
        if (i.Slab ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Slab",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Slab ();
        }

        // Sheet
        //
        if (i.Sheet ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Sheet",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Sheet ();
        }

        // Fibre
        //
        if (i.Fibre ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Fibre",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Fibre ();
        }

        // LoadMesh
        //
        if (i.LoadMesh ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LoadMesh",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.LoadMesh ();
        }

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const conductivities_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // longi
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "longi",
              e));

          a << ::xml_schema::as_double(i.longi ());
        }

        // trans
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "trans",
              e));

          a << ::xml_schema::as_double(i.trans ());
        }

        // normal
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "normal",
              e));

          a << ::xml_schema::as_double(i.normal ());
        }

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const var_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const output_variables_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Var
        //
        for (output_variables_type::Var_const_iterator
             b (i.Var ().begin ()), n (i.Var ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Var",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const yesno_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const yesno_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const yesno_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const output_visualizer_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // meshalyzer
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "meshalyzer",
              e));

          a << i.meshalyzer ();
        }

        // cmgui
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "cmgui",
              e));

          a << i.cmgui ();
        }

        // vtk
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "vtk",
              e));

          a << i.vtk ();
        }

        // parallel_vtk
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "parallel_vtk",
              e));

          a << i.parallel_vtk ();
        }

        // precision
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "precision",
              e));

          a << i.precision ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const time_steps_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // ode
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "ode",
              e));

          a << ::xml_schema::as_double(i.ode ());
        }

        // pde
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "pde",
              e));

          a << ::xml_schema::as_double(i.pde ());
        }

        // printing
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "printing",
              e));

          a << ::xml_schema::as_double(i.printing ());
        }

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ksp_tolerances_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // KSPRelative
        //
        if (i.KSPRelative ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "KSPRelative",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << ::xml_schema::as_double(*i.KSPRelative ());
        }

        // KSPAbsolute
        //
        if (i.KSPAbsolute ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "KSPAbsolute",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << ::xml_schema::as_double(*i.KSPAbsolute ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ksp_solver_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const ksp_solver_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const ksp_solver_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const ksp_preconditioner_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const ksp_preconditioner_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const ksp_preconditioner_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const mesh_partitioning_type& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const mesh_partitioning_type& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const mesh_partitioning_type& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const checkpoint_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // timestep
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "timestep",
              e));

          a << ::xml_schema::as_double(i.timestep ());
        }

        // max_checkpoints_on_disk
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "max_checkpoints_on_disk",
              e));

          a << i.max_checkpoints_on_disk ();
        }

        // unit
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "unit",
              e));

          a << i.unit ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const adaptivity_parameters_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // target_error
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "target_error",
              e));

          a << ::xml_schema::as_double(i.target_error ());
        }

        // sigma
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "sigma",
              e));

          a << ::xml_schema::as_double(i.sigma ());
        }

        // max_edge_length
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "max_edge_length",
              e));

          a << ::xml_schema::as_double(i.max_edge_length ());
        }

        // min_edge_length
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "min_edge_length",
              e));

          a << ::xml_schema::as_double(i.min_edge_length ());
        }

        // gradation
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "gradation",
              e));

          a << ::xml_schema::as_double(i.gradation ());
        }

        // max_nodes
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "max_nodes",
              e));

          a << i.max_nodes ();
        }

        // num_sweeps
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "num_sweeps",
              e));

          a << i.num_sweeps ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const cell_heterogeneities_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // CellHeterogeneity
        //
        for (cell_heterogeneities_type::CellHeterogeneity_const_iterator
             b (i.CellHeterogeneity ().begin ()), n (i.CellHeterogeneity ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CellHeterogeneity",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const stimuli_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Stimulus
        //
        for (stimuli_type::Stimulus_const_iterator
             b (i.Stimulus ().begin ()), n (i.Stimulus ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Stimulus",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const simulation_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // SpaceDimension
        //
        if (i.SpaceDimension ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SpaceDimension",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.SpaceDimension ();
        }

        // SimulationDuration
        //
        if (i.SimulationDuration ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SimulationDuration",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.SimulationDuration ();
        }

        // Domain
        //
        if (i.Domain ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Domain",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Domain ();
        }

        // Purkinje
        //
        if (i.Purkinje ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Purkinje",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Purkinje ();
        }

        // Mesh
        //
        if (i.Mesh ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Mesh",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Mesh ();
        }

        // IonicModels
        //
        if (i.IonicModels ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IonicModels",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.IonicModels ();
        }

        // Stimuli
        //
        if (i.Stimuli ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Stimuli",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Stimuli ();
        }

        // Electrodes
        //
        if (i.Electrodes ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Electrodes",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Electrodes ();
        }

        // CellHeterogeneities
        //
        if (i.CellHeterogeneities ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CellHeterogeneities",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.CellHeterogeneities ();
        }

        // OutputDirectory
        //
        if (i.OutputDirectory ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OutputDirectory",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.OutputDirectory ();
        }

        // OutputFilenamePrefix
        //
        if (i.OutputFilenamePrefix ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OutputFilenamePrefix",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.OutputFilenamePrefix ();
        }

        // OutputVariables
        //
        if (i.OutputVariables ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OutputVariables",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.OutputVariables ();
        }

        // OutputVisualizer
        //
        if (i.OutputVisualizer ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OutputVisualizer",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.OutputVisualizer ();
        }

        // OutputUsingOriginalNodeOrdering
        //
        if (i.OutputUsingOriginalNodeOrdering ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OutputUsingOriginalNodeOrdering",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.OutputUsingOriginalNodeOrdering ();
        }

        // CheckpointSimulation
        //
        if (i.CheckpointSimulation ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CheckpointSimulation",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.CheckpointSimulation ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const resume_simulation_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // ArchiveDirectory
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ArchiveDirectory",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.ArchiveDirectory ();
        }

        // SpaceDimension
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SpaceDimension",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.SpaceDimension ();
        }

        // Domain
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Domain",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Domain ();
        }

        // SimulationDuration
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SimulationDuration",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.SimulationDuration ();
        }

        // Stimuli
        //
        if (i.Stimuli ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Stimuli",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Stimuli ();
        }

        // CellHeterogeneities
        //
        if (i.CellHeterogeneities ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CellHeterogeneities",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.CellHeterogeneities ();
        }

        // CheckpointSimulation
        //
        if (i.CheckpointSimulation ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CheckpointSimulation",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.CheckpointSimulation ();
        }

        // OutputVisualizer
        //
        if (i.OutputVisualizer ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OutputVisualizer",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.OutputVisualizer ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const physiological_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // IntracellularConductivities
        //
        if (i.IntracellularConductivities ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IntracellularConductivities",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.IntracellularConductivities ();
        }

        // ExtracellularConductivities
        //
        if (i.ExtracellularConductivities ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ExtracellularConductivities",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ExtracellularConductivities ();
        }

        // BathConductivity
        //
        if (i.BathConductivity ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BathConductivity",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.BathConductivity ();
        }

        // ConductivityHeterogeneities
        //
        if (i.ConductivityHeterogeneities ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ConductivityHeterogeneities",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ConductivityHeterogeneities ();
        }

        // SurfaceAreaToVolumeRatio
        //
        if (i.SurfaceAreaToVolumeRatio ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SurfaceAreaToVolumeRatio",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.SurfaceAreaToVolumeRatio ();
        }

        // Capacitance
        //
        if (i.Capacitance ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Capacitance",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Capacitance ();
        }

        // ApplyDrug
        //
        if (i.ApplyDrug ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ApplyDrug",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ApplyDrug ();
        }

        // Purkinje
        //
        if (i.Purkinje ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Purkinje",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Purkinje ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const numerical_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // TimeSteps
        //
        if (i.TimeSteps ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeSteps",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.TimeSteps ();
        }

        // KSPTolerances
        //
        if (i.KSPTolerances ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "KSPTolerances",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.KSPTolerances ();
        }

        // KSPSolver
        //
        if (i.KSPSolver ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "KSPSolver",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.KSPSolver ();
        }

        // KSPPreconditioner
        //
        if (i.KSPPreconditioner ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "KSPPreconditioner",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.KSPPreconditioner ();
        }

        // MeshPartitioning
        //
        if (i.MeshPartitioning ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MeshPartitioning",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.MeshPartitioning ();
        }

        // UseStateVariableInterpolation
        //
        if (i.UseStateVariableInterpolation ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UseStateVariableInterpolation",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.UseStateVariableInterpolation ();
        }

        // AdaptivityParameters
        //
        if (i.AdaptivityParameters ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdaptivityParameters",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.AdaptivityParameters ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const postprocessing_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // ActionPotentialDurationMap
        //
        for (postprocessing_type::ActionPotentialDurationMap_const_iterator
             b (i.ActionPotentialDurationMap ().begin ()), n (i.ActionPotentialDurationMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ActionPotentialDurationMap",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }

        // UpstrokeTimeMap
        //
        for (postprocessing_type::UpstrokeTimeMap_const_iterator
             b (i.UpstrokeTimeMap ().begin ()), n (i.UpstrokeTimeMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UpstrokeTimeMap",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }

        // MaxUpstrokeVelocityMap
        //
        for (postprocessing_type::MaxUpstrokeVelocityMap_const_iterator
             b (i.MaxUpstrokeVelocityMap ().begin ()), n (i.MaxUpstrokeVelocityMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MaxUpstrokeVelocityMap",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }

        // ConductionVelocityMap
        //
        for (postprocessing_type::ConductionVelocityMap_const_iterator
             b (i.ConductionVelocityMap ().begin ()), n (i.ConductionVelocityMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ConductionVelocityMap",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }

        // TimeTraceAtNode
        //
        for (postprocessing_type::TimeTraceAtNode_const_iterator
             b (i.TimeTraceAtNode ().begin ()), n (i.TimeTraceAtNode ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeTraceAtNode",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }

        // PseudoEcgElectrodePosition
        //
        for (postprocessing_type::PseudoEcgElectrodePosition_const_iterator
             b (i.PseudoEcgElectrodePosition ().begin ()), n (i.PseudoEcgElectrodePosition ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PseudoEcgElectrodePosition",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const chaste_parameters_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Simulation
        //
        if (i.Simulation ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Simulation",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Simulation ();
        }

        // ResumeSimulation
        //
        if (i.ResumeSimulation ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ResumeSimulation",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.ResumeSimulation ();
        }

        // Physiological
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Physiological",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Physiological ();
        }

        // Numerical
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Numerical",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << i.Numerical ();
        }

        // PostProcessing
        //
        if (i.PostProcessing ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PostProcessing",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.PostProcessing ();
        }
      }

      void
      ChasteParameters (::std::ostream& o,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::chaste::parameters::v2017_1::ChasteParameters (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      ChasteParameters (::std::ostream& o,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::chaste::parameters::v2017_1::ChasteParameters (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      ChasteParameters (::std::ostream& o,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::chaste::parameters::v2017_1::ChasteParameters (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      ChasteParameters (::xercesc::XMLFormatTarget& t,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::chaste::parameters::v2017_1::ChasteParameters (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      ChasteParameters (::xercesc::XMLFormatTarget& t,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::chaste::parameters::v2017_1::ChasteParameters (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      ChasteParameters (::xercesc::XMLFormatTarget& t,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::chaste::parameters::v2017_1::ChasteParameters (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      ChasteParameters (::xercesc::DOMDocument& d,
                        const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        ::xml_schema::flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "ChasteParameters" &&
            n.namespace_ () == "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ChasteParameters",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1");
        }
      }

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      ChasteParameters (const ::chaste::parameters::v2017_1::chaste_parameters_type& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "ChasteParameters",
            "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
            m, f));

        ::chaste::parameters::v2017_1::ChasteParameters (*d, s, f);
        return d;
      }

      void
      operator<< (::xercesc::DOMElement& e, const purkinje_physiological_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // SurfaceAreaToVolumeRatio
        //
        if (i.SurfaceAreaToVolumeRatio ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SurfaceAreaToVolumeRatio",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.SurfaceAreaToVolumeRatio ();
        }

        // Capacitance
        //
        if (i.Capacitance ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Capacitance",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Capacitance ();
        }

        // Conductivity
        //
        if (i.Conductivity ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Conductivity",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *i.Conductivity ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const purkinje_simulation_type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr&, const purkinje_simulation_type&)
      {
      }

      void
      operator<< (::xml_schema::list_stream&,
                  const purkinje_simulation_type&)
      {
      }

      void
      operator<< (::xercesc::DOMElement& e, const ConductivityHeterogeneities& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // ConductivityHeterogeneity
        //
        for (ConductivityHeterogeneities::ConductivityHeterogeneity_const_iterator
             b (i.ConductivityHeterogeneity ().begin ()), n (i.ConductivityHeterogeneity ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ConductivityHeterogeneity",
              "https://chaste.comlab.ox.ac.uk/nss/parameters/2017_1",
              e));

          s << *b;
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
// LCOV_EXCL_STOP
//
// End epilogue.

