// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
// LCOV_EXCL_START
/** @autogenerated */
#include <streambuf>
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ChasteParameters_1_1.hpp"

namespace chaste
{
  namespace parameters
  {
    // time_type
    // 

    const time_type::unit_type& time_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const time_type::unit_type& time_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // dimensionless_type
    // 

    const dimensionless_type::unit_type& dimensionless_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const dimensionless_type::unit_type& dimensionless_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // conductivity_type
    // 

    const conductivity_type::unit_type& conductivity_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const conductivity_type::unit_type& conductivity_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // stimulus_strength_type
    // 

    const stimulus_strength_type::unit_type& stimulus_strength_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const stimulus_strength_type::unit_type& stimulus_strength_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // inverse_length_type
    // 

    const inverse_length_type::unit_type& inverse_length_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const inverse_length_type::unit_type& inverse_length_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // capacitance_type
    // 

    const capacitance_type::unit_type& capacitance_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const capacitance_type::unit_type& capacitance_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // location_type
    // 

    const location_type::Cuboid_type& location_type::
    Cuboid () const
    {
      return this->Cuboid_.get ();
    }

    location_type::Cuboid_type& location_type::
    Cuboid ()
    {
      return this->Cuboid_.get ();
    }

    void location_type::
    Cuboid (const Cuboid_type& x)
    {
      this->Cuboid_.set (x);
    }

    void location_type::
    Cuboid (::std::unique_ptr< Cuboid_type > x)
    {
      this->Cuboid_.set (std::move (x));
    }

    const location_type::unit_type& location_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const location_type::unit_type& location_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // domain_type
    // 

    domain_type::
    domain_type (value v)
    : ::xml_schema::string (_xsd_domain_type_literals_[v])
    {
    }

    domain_type::
    domain_type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    domain_type::
    domain_type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    domain_type::
    domain_type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    domain_type::
    domain_type (const domain_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    domain_type& domain_type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_domain_type_literals_[v]);

      return *this;
    }


    // ionic_models_available_type
    // 

    ionic_models_available_type::
    ionic_models_available_type (value v)
    : ::xml_schema::string (_xsd_ionic_models_available_type_literals_[v])
    {
    }

    ionic_models_available_type::
    ionic_models_available_type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ionic_models_available_type::
    ionic_models_available_type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ionic_models_available_type::
    ionic_models_available_type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ionic_models_available_type::
    ionic_models_available_type (const ionic_models_available_type& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ionic_models_available_type& ionic_models_available_type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ionic_models_available_type_literals_[v]);

      return *this;
    }


    // ionic_model_region_type
    // 

    const ionic_model_region_type::IonicModel_type& ionic_model_region_type::
    IonicModel () const
    {
      return this->IonicModel_.get ();
    }

    ionic_model_region_type::IonicModel_type& ionic_model_region_type::
    IonicModel ()
    {
      return this->IonicModel_.get ();
    }

    void ionic_model_region_type::
    IonicModel (const IonicModel_type& x)
    {
      this->IonicModel_.set (x);
    }

    void ionic_model_region_type::
    IonicModel (::std::unique_ptr< IonicModel_type > x)
    {
      this->IonicModel_.set (std::move (x));
    }

    const ionic_model_region_type::Location_type& ionic_model_region_type::
    Location () const
    {
      return this->Location_.get ();
    }

    ionic_model_region_type::Location_type& ionic_model_region_type::
    Location ()
    {
      return this->Location_.get ();
    }

    void ionic_model_region_type::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ionic_model_region_type::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }


    // ionic_models_type
    // 

    const ionic_models_type::Default_type& ionic_models_type::
    Default () const
    {
      return this->Default_.get ();
    }

    ionic_models_type::Default_type& ionic_models_type::
    Default ()
    {
      return this->Default_.get ();
    }

    void ionic_models_type::
    Default (const Default_type& x)
    {
      this->Default_.set (x);
    }

    void ionic_models_type::
    Default (::std::unique_ptr< Default_type > x)
    {
      this->Default_.set (std::move (x));
    }

    const ionic_models_type::Region_sequence& ionic_models_type::
    Region () const
    {
      return this->Region_;
    }

    ionic_models_type::Region_sequence& ionic_models_type::
    Region ()
    {
      return this->Region_;
    }

    void ionic_models_type::
    Region (const Region_sequence& s)
    {
      this->Region_ = s;
    }


    // apd_map_type
    // 

    const apd_map_type::repolarisation_percentage_type& apd_map_type::
    repolarisation_percentage () const
    {
      return this->repolarisation_percentage_.get ();
    }

    apd_map_type::repolarisation_percentage_type& apd_map_type::
    repolarisation_percentage ()
    {
      return this->repolarisation_percentage_.get ();
    }

    void apd_map_type::
    repolarisation_percentage (const repolarisation_percentage_type& x)
    {
      this->repolarisation_percentage_.set (x);
    }

    const apd_map_type::threshold_type& apd_map_type::
    threshold () const
    {
      return this->threshold_.get ();
    }

    apd_map_type::threshold_type& apd_map_type::
    threshold ()
    {
      return this->threshold_.get ();
    }

    void apd_map_type::
    threshold (const threshold_type& x)
    {
      this->threshold_.set (x);
    }

    const apd_map_type::threshold_unit_type& apd_map_type::
    threshold_unit () const
    {
      return this->threshold_unit_.get ();
    }

    const apd_map_type::threshold_unit_type& apd_map_type::
    threshold_unit_default_value ()
    {
      return threshold_unit_default_value_;
    }


    // upstrokes_map_type
    // 

    const upstrokes_map_type::threshold_type& upstrokes_map_type::
    threshold () const
    {
      return this->threshold_.get ();
    }

    upstrokes_map_type::threshold_type& upstrokes_map_type::
    threshold ()
    {
      return this->threshold_.get ();
    }

    void upstrokes_map_type::
    threshold (const threshold_type& x)
    {
      this->threshold_.set (x);
    }

    const upstrokes_map_type::threshold_unit_type& upstrokes_map_type::
    threshold_unit () const
    {
      return this->threshold_unit_.get ();
    }

    const upstrokes_map_type::threshold_unit_type& upstrokes_map_type::
    threshold_unit_default_value ()
    {
      return threshold_unit_default_value_;
    }


    // empty_type
    // 


    // conduction_velocity_map_type
    // 

    const conduction_velocity_map_type::origin_node_type& conduction_velocity_map_type::
    origin_node () const
    {
      return this->origin_node_.get ();
    }

    conduction_velocity_map_type::origin_node_type& conduction_velocity_map_type::
    origin_node ()
    {
      return this->origin_node_.get ();
    }

    void conduction_velocity_map_type::
    origin_node (const origin_node_type& x)
    {
      this->origin_node_.set (x);
    }


    // media_type
    // 

    media_type::
    media_type (value v)
    : ::xml_schema::string (_xsd_media_type_literals_[v])
    {
    }

    media_type::
    media_type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    media_type::
    media_type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    media_type::
    media_type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    media_type::
    media_type (const media_type& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    media_type& media_type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_media_type_literals_[v]);

      return *this;
    }


    // point_type
    // 

    const point_type::x_type& point_type::
    x () const
    {
      return this->x_.get ();
    }

    point_type::x_type& point_type::
    x ()
    {
      return this->x_.get ();
    }

    void point_type::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const point_type::y_type& point_type::
    y () const
    {
      return this->y_.get ();
    }

    point_type::y_type& point_type::
    y ()
    {
      return this->y_.get ();
    }

    void point_type::
    y (const y_type& x)
    {
      this->y_.set (x);
    }

    const point_type::z_type& point_type::
    z () const
    {
      return this->z_.get ();
    }

    point_type::z_type& point_type::
    z ()
    {
      return this->z_.get ();
    }

    void point_type::
    z (const z_type& x)
    {
      this->z_.set (x);
    }


    // box_type
    // 

    const box_type::LowerCoordinates_type& box_type::
    LowerCoordinates () const
    {
      return this->LowerCoordinates_.get ();
    }

    box_type::LowerCoordinates_type& box_type::
    LowerCoordinates ()
    {
      return this->LowerCoordinates_.get ();
    }

    void box_type::
    LowerCoordinates (const LowerCoordinates_type& x)
    {
      this->LowerCoordinates_.set (x);
    }

    void box_type::
    LowerCoordinates (::std::unique_ptr< LowerCoordinates_type > x)
    {
      this->LowerCoordinates_.set (std::move (x));
    }

    const box_type::UpperCoordinates_type& box_type::
    UpperCoordinates () const
    {
      return this->UpperCoordinates_.get ();
    }

    box_type::UpperCoordinates_type& box_type::
    UpperCoordinates ()
    {
      return this->UpperCoordinates_.get ();
    }

    void box_type::
    UpperCoordinates (const UpperCoordinates_type& x)
    {
      this->UpperCoordinates_.set (x);
    }

    void box_type::
    UpperCoordinates (::std::unique_ptr< UpperCoordinates_type > x)
    {
      this->UpperCoordinates_.set (std::move (x));
    }


    // stimulus_type
    // 

    const stimulus_type::Strength_type& stimulus_type::
    Strength () const
    {
      return this->Strength_.get ();
    }

    stimulus_type::Strength_type& stimulus_type::
    Strength ()
    {
      return this->Strength_.get ();
    }

    void stimulus_type::
    Strength (const Strength_type& x)
    {
      this->Strength_.set (x);
    }

    void stimulus_type::
    Strength (::std::unique_ptr< Strength_type > x)
    {
      this->Strength_.set (std::move (x));
    }

    const stimulus_type::Duration_type& stimulus_type::
    Duration () const
    {
      return this->Duration_.get ();
    }

    stimulus_type::Duration_type& stimulus_type::
    Duration ()
    {
      return this->Duration_.get ();
    }

    void stimulus_type::
    Duration (const Duration_type& x)
    {
      this->Duration_.set (x);
    }

    void stimulus_type::
    Duration (::std::unique_ptr< Duration_type > x)
    {
      this->Duration_.set (std::move (x));
    }

    const stimulus_type::Delay_type& stimulus_type::
    Delay () const
    {
      return this->Delay_.get ();
    }

    stimulus_type::Delay_type& stimulus_type::
    Delay ()
    {
      return this->Delay_.get ();
    }

    void stimulus_type::
    Delay (const Delay_type& x)
    {
      this->Delay_.set (x);
    }

    void stimulus_type::
    Delay (::std::unique_ptr< Delay_type > x)
    {
      this->Delay_.set (std::move (x));
    }

    const stimulus_type::Location_type& stimulus_type::
    Location () const
    {
      return this->Location_.get ();
    }

    stimulus_type::Location_type& stimulus_type::
    Location ()
    {
      return this->Location_.get ();
    }

    void stimulus_type::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void stimulus_type::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }


    // cell_heterogeneity_type
    // 

    const cell_heterogeneity_type::ScaleFactorGks_type& cell_heterogeneity_type::
    ScaleFactorGks () const
    {
      return this->ScaleFactorGks_.get ();
    }

    cell_heterogeneity_type::ScaleFactorGks_type& cell_heterogeneity_type::
    ScaleFactorGks ()
    {
      return this->ScaleFactorGks_.get ();
    }

    void cell_heterogeneity_type::
    ScaleFactorGks (const ScaleFactorGks_type& x)
    {
      this->ScaleFactorGks_.set (x);
    }

    void cell_heterogeneity_type::
    ScaleFactorGks (::std::unique_ptr< ScaleFactorGks_type > x)
    {
      this->ScaleFactorGks_.set (std::move (x));
    }

    const cell_heterogeneity_type::ScaleFactorIto_type& cell_heterogeneity_type::
    ScaleFactorIto () const
    {
      return this->ScaleFactorIto_.get ();
    }

    cell_heterogeneity_type::ScaleFactorIto_type& cell_heterogeneity_type::
    ScaleFactorIto ()
    {
      return this->ScaleFactorIto_.get ();
    }

    void cell_heterogeneity_type::
    ScaleFactorIto (const ScaleFactorIto_type& x)
    {
      this->ScaleFactorIto_.set (x);
    }

    void cell_heterogeneity_type::
    ScaleFactorIto (::std::unique_ptr< ScaleFactorIto_type > x)
    {
      this->ScaleFactorIto_.set (std::move (x));
    }

    const cell_heterogeneity_type::ScaleFactorGkr_type& cell_heterogeneity_type::
    ScaleFactorGkr () const
    {
      return this->ScaleFactorGkr_.get ();
    }

    cell_heterogeneity_type::ScaleFactorGkr_type& cell_heterogeneity_type::
    ScaleFactorGkr ()
    {
      return this->ScaleFactorGkr_.get ();
    }

    void cell_heterogeneity_type::
    ScaleFactorGkr (const ScaleFactorGkr_type& x)
    {
      this->ScaleFactorGkr_.set (x);
    }

    void cell_heterogeneity_type::
    ScaleFactorGkr (::std::unique_ptr< ScaleFactorGkr_type > x)
    {
      this->ScaleFactorGkr_.set (std::move (x));
    }

    const cell_heterogeneity_type::Location_type& cell_heterogeneity_type::
    Location () const
    {
      return this->Location_.get ();
    }

    cell_heterogeneity_type::Location_type& cell_heterogeneity_type::
    Location ()
    {
      return this->Location_.get ();
    }

    void cell_heterogeneity_type::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void cell_heterogeneity_type::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }


    // conductivity_heterogeneity_type
    // 

    const conductivity_heterogeneity_type::IntracellularConductivities_optional& conductivity_heterogeneity_type::
    IntracellularConductivities () const
    {
      return this->IntracellularConductivities_;
    }

    conductivity_heterogeneity_type::IntracellularConductivities_optional& conductivity_heterogeneity_type::
    IntracellularConductivities ()
    {
      return this->IntracellularConductivities_;
    }

    void conductivity_heterogeneity_type::
    IntracellularConductivities (const IntracellularConductivities_type& x)
    {
      this->IntracellularConductivities_.set (x);
    }

    void conductivity_heterogeneity_type::
    IntracellularConductivities (const IntracellularConductivities_optional& x)
    {
      this->IntracellularConductivities_ = x;
    }

    void conductivity_heterogeneity_type::
    IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > x)
    {
      this->IntracellularConductivities_.set (std::move (x));
    }

    const conductivity_heterogeneity_type::ExtracellularConductivities_optional& conductivity_heterogeneity_type::
    ExtracellularConductivities () const
    {
      return this->ExtracellularConductivities_;
    }

    conductivity_heterogeneity_type::ExtracellularConductivities_optional& conductivity_heterogeneity_type::
    ExtracellularConductivities ()
    {
      return this->ExtracellularConductivities_;
    }

    void conductivity_heterogeneity_type::
    ExtracellularConductivities (const ExtracellularConductivities_type& x)
    {
      this->ExtracellularConductivities_.set (x);
    }

    void conductivity_heterogeneity_type::
    ExtracellularConductivities (const ExtracellularConductivities_optional& x)
    {
      this->ExtracellularConductivities_ = x;
    }

    void conductivity_heterogeneity_type::
    ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > x)
    {
      this->ExtracellularConductivities_.set (std::move (x));
    }

    const conductivity_heterogeneity_type::Location_type& conductivity_heterogeneity_type::
    Location () const
    {
      return this->Location_.get ();
    }

    conductivity_heterogeneity_type::Location_type& conductivity_heterogeneity_type::
    Location ()
    {
      return this->Location_.get ();
    }

    void conductivity_heterogeneity_type::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void conductivity_heterogeneity_type::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }


    // slab_type
    // 

    const slab_type::x_type& slab_type::
    x () const
    {
      return this->x_.get ();
    }

    slab_type::x_type& slab_type::
    x ()
    {
      return this->x_.get ();
    }

    void slab_type::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const slab_type::y_type& slab_type::
    y () const
    {
      return this->y_.get ();
    }

    slab_type::y_type& slab_type::
    y ()
    {
      return this->y_.get ();
    }

    void slab_type::
    y (const y_type& x)
    {
      this->y_.set (x);
    }

    const slab_type::z_type& slab_type::
    z () const
    {
      return this->z_.get ();
    }

    slab_type::z_type& slab_type::
    z ()
    {
      return this->z_.get ();
    }

    void slab_type::
    z (const z_type& x)
    {
      this->z_.set (x);
    }

    const slab_type::inter_node_space_type& slab_type::
    inter_node_space () const
    {
      return this->inter_node_space_.get ();
    }

    slab_type::inter_node_space_type& slab_type::
    inter_node_space ()
    {
      return this->inter_node_space_.get ();
    }

    void slab_type::
    inter_node_space (const inter_node_space_type& x)
    {
      this->inter_node_space_.set (x);
    }


    // sheet_type
    // 

    const sheet_type::x_type& sheet_type::
    x () const
    {
      return this->x_.get ();
    }

    sheet_type::x_type& sheet_type::
    x ()
    {
      return this->x_.get ();
    }

    void sheet_type::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const sheet_type::y_type& sheet_type::
    y () const
    {
      return this->y_.get ();
    }

    sheet_type::y_type& sheet_type::
    y ()
    {
      return this->y_.get ();
    }

    void sheet_type::
    y (const y_type& x)
    {
      this->y_.set (x);
    }

    const sheet_type::inter_node_space_type& sheet_type::
    inter_node_space () const
    {
      return this->inter_node_space_.get ();
    }

    sheet_type::inter_node_space_type& sheet_type::
    inter_node_space ()
    {
      return this->inter_node_space_.get ();
    }

    void sheet_type::
    inter_node_space (const inter_node_space_type& x)
    {
      this->inter_node_space_.set (x);
    }


    // fibre_type
    // 

    const fibre_type::x_type& fibre_type::
    x () const
    {
      return this->x_.get ();
    }

    fibre_type::x_type& fibre_type::
    x ()
    {
      return this->x_.get ();
    }

    void fibre_type::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const fibre_type::inter_node_space_type& fibre_type::
    inter_node_space () const
    {
      return this->inter_node_space_.get ();
    }

    fibre_type::inter_node_space_type& fibre_type::
    inter_node_space ()
    {
      return this->inter_node_space_.get ();
    }

    void fibre_type::
    inter_node_space (const inter_node_space_type& x)
    {
      this->inter_node_space_.set (x);
    }


    // load_mesh_type
    // 

    const load_mesh_type::name_type& load_mesh_type::
    name () const
    {
      return this->name_.get ();
    }

    load_mesh_type::name_type& load_mesh_type::
    name ()
    {
      return this->name_.get ();
    }

    void load_mesh_type::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void load_mesh_type::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const load_mesh_type::conductivity_media_type& load_mesh_type::
    conductivity_media () const
    {
      return this->conductivity_media_.get ();
    }

    load_mesh_type::conductivity_media_type& load_mesh_type::
    conductivity_media ()
    {
      return this->conductivity_media_.get ();
    }

    void load_mesh_type::
    conductivity_media (const conductivity_media_type& x)
    {
      this->conductivity_media_.set (x);
    }

    void load_mesh_type::
    conductivity_media (::std::unique_ptr< conductivity_media_type > x)
    {
      this->conductivity_media_.set (std::move (x));
    }


    // mesh_type
    // 

    const mesh_type::Slab_optional& mesh_type::
    Slab () const
    {
      return this->Slab_;
    }

    mesh_type::Slab_optional& mesh_type::
    Slab ()
    {
      return this->Slab_;
    }

    void mesh_type::
    Slab (const Slab_type& x)
    {
      this->Slab_.set (x);
    }

    void mesh_type::
    Slab (const Slab_optional& x)
    {
      this->Slab_ = x;
    }

    void mesh_type::
    Slab (::std::unique_ptr< Slab_type > x)
    {
      this->Slab_.set (std::move (x));
    }

    const mesh_type::Sheet_optional& mesh_type::
    Sheet () const
    {
      return this->Sheet_;
    }

    mesh_type::Sheet_optional& mesh_type::
    Sheet ()
    {
      return this->Sheet_;
    }

    void mesh_type::
    Sheet (const Sheet_type& x)
    {
      this->Sheet_.set (x);
    }

    void mesh_type::
    Sheet (const Sheet_optional& x)
    {
      this->Sheet_ = x;
    }

    void mesh_type::
    Sheet (::std::unique_ptr< Sheet_type > x)
    {
      this->Sheet_.set (std::move (x));
    }

    const mesh_type::Fibre_optional& mesh_type::
    Fibre () const
    {
      return this->Fibre_;
    }

    mesh_type::Fibre_optional& mesh_type::
    Fibre ()
    {
      return this->Fibre_;
    }

    void mesh_type::
    Fibre (const Fibre_type& x)
    {
      this->Fibre_.set (x);
    }

    void mesh_type::
    Fibre (const Fibre_optional& x)
    {
      this->Fibre_ = x;
    }

    void mesh_type::
    Fibre (::std::unique_ptr< Fibre_type > x)
    {
      this->Fibre_.set (std::move (x));
    }

    const mesh_type::LoadMesh_optional& mesh_type::
    LoadMesh () const
    {
      return this->LoadMesh_;
    }

    mesh_type::LoadMesh_optional& mesh_type::
    LoadMesh ()
    {
      return this->LoadMesh_;
    }

    void mesh_type::
    LoadMesh (const LoadMesh_type& x)
    {
      this->LoadMesh_.set (x);
    }

    void mesh_type::
    LoadMesh (const LoadMesh_optional& x)
    {
      this->LoadMesh_ = x;
    }

    void mesh_type::
    LoadMesh (::std::unique_ptr< LoadMesh_type > x)
    {
      this->LoadMesh_.set (std::move (x));
    }

    const mesh_type::unit_type& mesh_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const mesh_type::unit_type& mesh_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // conductivities_type
    // 

    const conductivities_type::longi_type& conductivities_type::
    longi () const
    {
      return this->longi_.get ();
    }

    conductivities_type::longi_type& conductivities_type::
    longi ()
    {
      return this->longi_.get ();
    }

    void conductivities_type::
    longi (const longi_type& x)
    {
      this->longi_.set (x);
    }

    const conductivities_type::trans_type& conductivities_type::
    trans () const
    {
      return this->trans_.get ();
    }

    conductivities_type::trans_type& conductivities_type::
    trans ()
    {
      return this->trans_.get ();
    }

    void conductivities_type::
    trans (const trans_type& x)
    {
      this->trans_.set (x);
    }

    const conductivities_type::normal_type& conductivities_type::
    normal () const
    {
      return this->normal_.get ();
    }

    conductivities_type::normal_type& conductivities_type::
    normal ()
    {
      return this->normal_.get ();
    }

    void conductivities_type::
    normal (const normal_type& x)
    {
      this->normal_.set (x);
    }

    const conductivities_type::unit_type& conductivities_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const conductivities_type::unit_type& conductivities_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // time_steps_type
    // 

    const time_steps_type::ode_type& time_steps_type::
    ode () const
    {
      return this->ode_.get ();
    }

    time_steps_type::ode_type& time_steps_type::
    ode ()
    {
      return this->ode_.get ();
    }

    void time_steps_type::
    ode (const ode_type& x)
    {
      this->ode_.set (x);
    }

    const time_steps_type::pde_type& time_steps_type::
    pde () const
    {
      return this->pde_.get ();
    }

    time_steps_type::pde_type& time_steps_type::
    pde ()
    {
      return this->pde_.get ();
    }

    void time_steps_type::
    pde (const pde_type& x)
    {
      this->pde_.set (x);
    }

    const time_steps_type::printing_type& time_steps_type::
    printing () const
    {
      return this->printing_.get ();
    }

    time_steps_type::printing_type& time_steps_type::
    printing ()
    {
      return this->printing_.get ();
    }

    void time_steps_type::
    printing (const printing_type& x)
    {
      this->printing_.set (x);
    }

    const time_steps_type::unit_type& time_steps_type::
    unit () const
    {
      return this->unit_.get ();
    }

    const time_steps_type::unit_type& time_steps_type::
    unit_default_value ()
    {
      return unit_default_value_;
    }


    // ksp_use_type
    // 

    ksp_use_type::
    ksp_use_type (value v)
    : ::xml_schema::string (_xsd_ksp_use_type_literals_[v])
    {
    }

    ksp_use_type::
    ksp_use_type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ksp_use_type::
    ksp_use_type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ksp_use_type::
    ksp_use_type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ksp_use_type::
    ksp_use_type (const ksp_use_type& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ksp_use_type& ksp_use_type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ksp_use_type_literals_[v]);

      return *this;
    }


    // ksp_tolerances_type
    // 

    const ksp_tolerances_type::KSPRelative_optional& ksp_tolerances_type::
    KSPRelative () const
    {
      return this->KSPRelative_;
    }

    ksp_tolerances_type::KSPRelative_optional& ksp_tolerances_type::
    KSPRelative ()
    {
      return this->KSPRelative_;
    }

    void ksp_tolerances_type::
    KSPRelative (const KSPRelative_type& x)
    {
      this->KSPRelative_.set (x);
    }

    void ksp_tolerances_type::
    KSPRelative (const KSPRelative_optional& x)
    {
      this->KSPRelative_ = x;
    }

    const ksp_tolerances_type::KSPAbsolute_optional& ksp_tolerances_type::
    KSPAbsolute () const
    {
      return this->KSPAbsolute_;
    }

    ksp_tolerances_type::KSPAbsolute_optional& ksp_tolerances_type::
    KSPAbsolute ()
    {
      return this->KSPAbsolute_;
    }

    void ksp_tolerances_type::
    KSPAbsolute (const KSPAbsolute_type& x)
    {
      this->KSPAbsolute_.set (x);
    }

    void ksp_tolerances_type::
    KSPAbsolute (const KSPAbsolute_optional& x)
    {
      this->KSPAbsolute_ = x;
    }


    // ksp_solver_type
    // 

    ksp_solver_type::
    ksp_solver_type (value v)
    : ::xml_schema::string (_xsd_ksp_solver_type_literals_[v])
    {
    }

    ksp_solver_type::
    ksp_solver_type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ksp_solver_type::
    ksp_solver_type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ksp_solver_type::
    ksp_solver_type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ksp_solver_type::
    ksp_solver_type (const ksp_solver_type& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ksp_solver_type& ksp_solver_type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ksp_solver_type_literals_[v]);

      return *this;
    }


    // ksp_preconditioner_type
    // 

    ksp_preconditioner_type::
    ksp_preconditioner_type (value v)
    : ::xml_schema::string (_xsd_ksp_preconditioner_type_literals_[v])
    {
    }

    ksp_preconditioner_type::
    ksp_preconditioner_type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ksp_preconditioner_type::
    ksp_preconditioner_type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ksp_preconditioner_type::
    ksp_preconditioner_type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ksp_preconditioner_type::
    ksp_preconditioner_type (const ksp_preconditioner_type& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ksp_preconditioner_type& ksp_preconditioner_type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ksp_preconditioner_type_literals_[v]);

      return *this;
    }


    // simulation_type
    // 

    const simulation_type::SpaceDimension_optional& simulation_type::
    SpaceDimension () const
    {
      return this->SpaceDimension_;
    }

    simulation_type::SpaceDimension_optional& simulation_type::
    SpaceDimension ()
    {
      return this->SpaceDimension_;
    }

    void simulation_type::
    SpaceDimension (const SpaceDimension_type& x)
    {
      this->SpaceDimension_.set (x);
    }

    void simulation_type::
    SpaceDimension (const SpaceDimension_optional& x)
    {
      this->SpaceDimension_ = x;
    }

    const simulation_type::SimulationDuration_optional& simulation_type::
    SimulationDuration () const
    {
      return this->SimulationDuration_;
    }

    simulation_type::SimulationDuration_optional& simulation_type::
    SimulationDuration ()
    {
      return this->SimulationDuration_;
    }

    void simulation_type::
    SimulationDuration (const SimulationDuration_type& x)
    {
      this->SimulationDuration_.set (x);
    }

    void simulation_type::
    SimulationDuration (const SimulationDuration_optional& x)
    {
      this->SimulationDuration_ = x;
    }

    void simulation_type::
    SimulationDuration (::std::unique_ptr< SimulationDuration_type > x)
    {
      this->SimulationDuration_.set (std::move (x));
    }

    const simulation_type::Domain_optional& simulation_type::
    Domain () const
    {
      return this->Domain_;
    }

    simulation_type::Domain_optional& simulation_type::
    Domain ()
    {
      return this->Domain_;
    }

    void simulation_type::
    Domain (const Domain_type& x)
    {
      this->Domain_.set (x);
    }

    void simulation_type::
    Domain (const Domain_optional& x)
    {
      this->Domain_ = x;
    }

    void simulation_type::
    Domain (::std::unique_ptr< Domain_type > x)
    {
      this->Domain_.set (std::move (x));
    }

    const simulation_type::Mesh_optional& simulation_type::
    Mesh () const
    {
      return this->Mesh_;
    }

    simulation_type::Mesh_optional& simulation_type::
    Mesh ()
    {
      return this->Mesh_;
    }

    void simulation_type::
    Mesh (const Mesh_type& x)
    {
      this->Mesh_.set (x);
    }

    void simulation_type::
    Mesh (const Mesh_optional& x)
    {
      this->Mesh_ = x;
    }

    void simulation_type::
    Mesh (::std::unique_ptr< Mesh_type > x)
    {
      this->Mesh_.set (std::move (x));
    }

    const simulation_type::IonicModels_optional& simulation_type::
    IonicModels () const
    {
      return this->IonicModels_;
    }

    simulation_type::IonicModels_optional& simulation_type::
    IonicModels ()
    {
      return this->IonicModels_;
    }

    void simulation_type::
    IonicModels (const IonicModels_type& x)
    {
      this->IonicModels_.set (x);
    }

    void simulation_type::
    IonicModels (const IonicModels_optional& x)
    {
      this->IonicModels_ = x;
    }

    void simulation_type::
    IonicModels (::std::unique_ptr< IonicModels_type > x)
    {
      this->IonicModels_.set (std::move (x));
    }

    const simulation_type::Stimuli_optional& simulation_type::
    Stimuli () const
    {
      return this->Stimuli_;
    }

    simulation_type::Stimuli_optional& simulation_type::
    Stimuli ()
    {
      return this->Stimuli_;
    }

    void simulation_type::
    Stimuli (const Stimuli_type& x)
    {
      this->Stimuli_.set (x);
    }

    void simulation_type::
    Stimuli (const Stimuli_optional& x)
    {
      this->Stimuli_ = x;
    }

    void simulation_type::
    Stimuli (::std::unique_ptr< Stimuli_type > x)
    {
      this->Stimuli_.set (std::move (x));
    }

    const simulation_type::CellHeterogeneities_optional& simulation_type::
    CellHeterogeneities () const
    {
      return this->CellHeterogeneities_;
    }

    simulation_type::CellHeterogeneities_optional& simulation_type::
    CellHeterogeneities ()
    {
      return this->CellHeterogeneities_;
    }

    void simulation_type::
    CellHeterogeneities (const CellHeterogeneities_type& x)
    {
      this->CellHeterogeneities_.set (x);
    }

    void simulation_type::
    CellHeterogeneities (const CellHeterogeneities_optional& x)
    {
      this->CellHeterogeneities_ = x;
    }

    void simulation_type::
    CellHeterogeneities (::std::unique_ptr< CellHeterogeneities_type > x)
    {
      this->CellHeterogeneities_.set (std::move (x));
    }

    const simulation_type::ConductivityHeterogeneities_optional& simulation_type::
    ConductivityHeterogeneities () const
    {
      return this->ConductivityHeterogeneities_;
    }

    simulation_type::ConductivityHeterogeneities_optional& simulation_type::
    ConductivityHeterogeneities ()
    {
      return this->ConductivityHeterogeneities_;
    }

    void simulation_type::
    ConductivityHeterogeneities (const ConductivityHeterogeneities_type& x)
    {
      this->ConductivityHeterogeneities_.set (x);
    }

    void simulation_type::
    ConductivityHeterogeneities (const ConductivityHeterogeneities_optional& x)
    {
      this->ConductivityHeterogeneities_ = x;
    }

    void simulation_type::
    ConductivityHeterogeneities (::std::unique_ptr< ConductivityHeterogeneities_type > x)
    {
      this->ConductivityHeterogeneities_.set (std::move (x));
    }

    const simulation_type::OutputDirectory_optional& simulation_type::
    OutputDirectory () const
    {
      return this->OutputDirectory_;
    }

    simulation_type::OutputDirectory_optional& simulation_type::
    OutputDirectory ()
    {
      return this->OutputDirectory_;
    }

    void simulation_type::
    OutputDirectory (const OutputDirectory_type& x)
    {
      this->OutputDirectory_.set (x);
    }

    void simulation_type::
    OutputDirectory (const OutputDirectory_optional& x)
    {
      this->OutputDirectory_ = x;
    }

    void simulation_type::
    OutputDirectory (::std::unique_ptr< OutputDirectory_type > x)
    {
      this->OutputDirectory_.set (std::move (x));
    }

    const simulation_type::OutputFilenamePrefix_optional& simulation_type::
    OutputFilenamePrefix () const
    {
      return this->OutputFilenamePrefix_;
    }

    simulation_type::OutputFilenamePrefix_optional& simulation_type::
    OutputFilenamePrefix ()
    {
      return this->OutputFilenamePrefix_;
    }

    void simulation_type::
    OutputFilenamePrefix (const OutputFilenamePrefix_type& x)
    {
      this->OutputFilenamePrefix_.set (x);
    }

    void simulation_type::
    OutputFilenamePrefix (const OutputFilenamePrefix_optional& x)
    {
      this->OutputFilenamePrefix_ = x;
    }

    void simulation_type::
    OutputFilenamePrefix (::std::unique_ptr< OutputFilenamePrefix_type > x)
    {
      this->OutputFilenamePrefix_.set (std::move (x));
    }


    // physiological_type
    // 

    const physiological_type::IntracellularConductivities_optional& physiological_type::
    IntracellularConductivities () const
    {
      return this->IntracellularConductivities_;
    }

    physiological_type::IntracellularConductivities_optional& physiological_type::
    IntracellularConductivities ()
    {
      return this->IntracellularConductivities_;
    }

    void physiological_type::
    IntracellularConductivities (const IntracellularConductivities_type& x)
    {
      this->IntracellularConductivities_.set (x);
    }

    void physiological_type::
    IntracellularConductivities (const IntracellularConductivities_optional& x)
    {
      this->IntracellularConductivities_ = x;
    }

    void physiological_type::
    IntracellularConductivities (::std::unique_ptr< IntracellularConductivities_type > x)
    {
      this->IntracellularConductivities_.set (std::move (x));
    }

    const physiological_type::ExtracellularConductivities_optional& physiological_type::
    ExtracellularConductivities () const
    {
      return this->ExtracellularConductivities_;
    }

    physiological_type::ExtracellularConductivities_optional& physiological_type::
    ExtracellularConductivities ()
    {
      return this->ExtracellularConductivities_;
    }

    void physiological_type::
    ExtracellularConductivities (const ExtracellularConductivities_type& x)
    {
      this->ExtracellularConductivities_.set (x);
    }

    void physiological_type::
    ExtracellularConductivities (const ExtracellularConductivities_optional& x)
    {
      this->ExtracellularConductivities_ = x;
    }

    void physiological_type::
    ExtracellularConductivities (::std::unique_ptr< ExtracellularConductivities_type > x)
    {
      this->ExtracellularConductivities_.set (std::move (x));
    }

    const physiological_type::BathConductivity_optional& physiological_type::
    BathConductivity () const
    {
      return this->BathConductivity_;
    }

    physiological_type::BathConductivity_optional& physiological_type::
    BathConductivity ()
    {
      return this->BathConductivity_;
    }

    void physiological_type::
    BathConductivity (const BathConductivity_type& x)
    {
      this->BathConductivity_.set (x);
    }

    void physiological_type::
    BathConductivity (const BathConductivity_optional& x)
    {
      this->BathConductivity_ = x;
    }

    void physiological_type::
    BathConductivity (::std::unique_ptr< BathConductivity_type > x)
    {
      this->BathConductivity_.set (std::move (x));
    }

    const physiological_type::SurfaceAreaToVolumeRatio_optional& physiological_type::
    SurfaceAreaToVolumeRatio () const
    {
      return this->SurfaceAreaToVolumeRatio_;
    }

    physiological_type::SurfaceAreaToVolumeRatio_optional& physiological_type::
    SurfaceAreaToVolumeRatio ()
    {
      return this->SurfaceAreaToVolumeRatio_;
    }

    void physiological_type::
    SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_type& x)
    {
      this->SurfaceAreaToVolumeRatio_.set (x);
    }

    void physiological_type::
    SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio_optional& x)
    {
      this->SurfaceAreaToVolumeRatio_ = x;
    }

    void physiological_type::
    SurfaceAreaToVolumeRatio (::std::unique_ptr< SurfaceAreaToVolumeRatio_type > x)
    {
      this->SurfaceAreaToVolumeRatio_.set (std::move (x));
    }

    const physiological_type::Capacitance_optional& physiological_type::
    Capacitance () const
    {
      return this->Capacitance_;
    }

    physiological_type::Capacitance_optional& physiological_type::
    Capacitance ()
    {
      return this->Capacitance_;
    }

    void physiological_type::
    Capacitance (const Capacitance_type& x)
    {
      this->Capacitance_.set (x);
    }

    void physiological_type::
    Capacitance (const Capacitance_optional& x)
    {
      this->Capacitance_ = x;
    }

    void physiological_type::
    Capacitance (::std::unique_ptr< Capacitance_type > x)
    {
      this->Capacitance_.set (std::move (x));
    }


    // numerical_type
    // 

    const numerical_type::TimeSteps_optional& numerical_type::
    TimeSteps () const
    {
      return this->TimeSteps_;
    }

    numerical_type::TimeSteps_optional& numerical_type::
    TimeSteps ()
    {
      return this->TimeSteps_;
    }

    void numerical_type::
    TimeSteps (const TimeSteps_type& x)
    {
      this->TimeSteps_.set (x);
    }

    void numerical_type::
    TimeSteps (const TimeSteps_optional& x)
    {
      this->TimeSteps_ = x;
    }

    void numerical_type::
    TimeSteps (::std::unique_ptr< TimeSteps_type > x)
    {
      this->TimeSteps_.set (std::move (x));
    }

    const numerical_type::KSPTolerances_optional& numerical_type::
    KSPTolerances () const
    {
      return this->KSPTolerances_;
    }

    numerical_type::KSPTolerances_optional& numerical_type::
    KSPTolerances ()
    {
      return this->KSPTolerances_;
    }

    void numerical_type::
    KSPTolerances (const KSPTolerances_type& x)
    {
      this->KSPTolerances_.set (x);
    }

    void numerical_type::
    KSPTolerances (const KSPTolerances_optional& x)
    {
      this->KSPTolerances_ = x;
    }

    void numerical_type::
    KSPTolerances (::std::unique_ptr< KSPTolerances_type > x)
    {
      this->KSPTolerances_.set (std::move (x));
    }

    const numerical_type::KSPSolver_optional& numerical_type::
    KSPSolver () const
    {
      return this->KSPSolver_;
    }

    numerical_type::KSPSolver_optional& numerical_type::
    KSPSolver ()
    {
      return this->KSPSolver_;
    }

    void numerical_type::
    KSPSolver (const KSPSolver_type& x)
    {
      this->KSPSolver_.set (x);
    }

    void numerical_type::
    KSPSolver (const KSPSolver_optional& x)
    {
      this->KSPSolver_ = x;
    }

    void numerical_type::
    KSPSolver (::std::unique_ptr< KSPSolver_type > x)
    {
      this->KSPSolver_.set (std::move (x));
    }

    const numerical_type::KSPPreconditioner_optional& numerical_type::
    KSPPreconditioner () const
    {
      return this->KSPPreconditioner_;
    }

    numerical_type::KSPPreconditioner_optional& numerical_type::
    KSPPreconditioner ()
    {
      return this->KSPPreconditioner_;
    }

    void numerical_type::
    KSPPreconditioner (const KSPPreconditioner_type& x)
    {
      this->KSPPreconditioner_.set (x);
    }

    void numerical_type::
    KSPPreconditioner (const KSPPreconditioner_optional& x)
    {
      this->KSPPreconditioner_ = x;
    }

    void numerical_type::
    KSPPreconditioner (::std::unique_ptr< KSPPreconditioner_type > x)
    {
      this->KSPPreconditioner_.set (std::move (x));
    }


    // postprocessing_type
    // 

    const postprocessing_type::ActionPotentialDurationMap_sequence& postprocessing_type::
    ActionPotentialDurationMap () const
    {
      return this->ActionPotentialDurationMap_;
    }

    postprocessing_type::ActionPotentialDurationMap_sequence& postprocessing_type::
    ActionPotentialDurationMap ()
    {
      return this->ActionPotentialDurationMap_;
    }

    void postprocessing_type::
    ActionPotentialDurationMap (const ActionPotentialDurationMap_sequence& s)
    {
      this->ActionPotentialDurationMap_ = s;
    }

    const postprocessing_type::UpstrokeTimeMap_sequence& postprocessing_type::
    UpstrokeTimeMap () const
    {
      return this->UpstrokeTimeMap_;
    }

    postprocessing_type::UpstrokeTimeMap_sequence& postprocessing_type::
    UpstrokeTimeMap ()
    {
      return this->UpstrokeTimeMap_;
    }

    void postprocessing_type::
    UpstrokeTimeMap (const UpstrokeTimeMap_sequence& s)
    {
      this->UpstrokeTimeMap_ = s;
    }

    const postprocessing_type::MaxUpstrokeVelocityMap_optional& postprocessing_type::
    MaxUpstrokeVelocityMap () const
    {
      return this->MaxUpstrokeVelocityMap_;
    }

    postprocessing_type::MaxUpstrokeVelocityMap_optional& postprocessing_type::
    MaxUpstrokeVelocityMap ()
    {
      return this->MaxUpstrokeVelocityMap_;
    }

    void postprocessing_type::
    MaxUpstrokeVelocityMap (const MaxUpstrokeVelocityMap_type& x)
    {
      this->MaxUpstrokeVelocityMap_.set (x);
    }

    void postprocessing_type::
    MaxUpstrokeVelocityMap (const MaxUpstrokeVelocityMap_optional& x)
    {
      this->MaxUpstrokeVelocityMap_ = x;
    }

    void postprocessing_type::
    MaxUpstrokeVelocityMap (::std::unique_ptr< MaxUpstrokeVelocityMap_type > x)
    {
      this->MaxUpstrokeVelocityMap_.set (std::move (x));
    }

    const postprocessing_type::ConductionVelocityMap_sequence& postprocessing_type::
    ConductionVelocityMap () const
    {
      return this->ConductionVelocityMap_;
    }

    postprocessing_type::ConductionVelocityMap_sequence& postprocessing_type::
    ConductionVelocityMap ()
    {
      return this->ConductionVelocityMap_;
    }

    void postprocessing_type::
    ConductionVelocityMap (const ConductionVelocityMap_sequence& s)
    {
      this->ConductionVelocityMap_ = s;
    }


    // chaste_parameters_type
    // 

    const chaste_parameters_type::Simulation_type& chaste_parameters_type::
    Simulation () const
    {
      return this->Simulation_.get ();
    }

    chaste_parameters_type::Simulation_type& chaste_parameters_type::
    Simulation ()
    {
      return this->Simulation_.get ();
    }

    void chaste_parameters_type::
    Simulation (const Simulation_type& x)
    {
      this->Simulation_.set (x);
    }

    void chaste_parameters_type::
    Simulation (::std::unique_ptr< Simulation_type > x)
    {
      this->Simulation_.set (std::move (x));
    }

    const chaste_parameters_type::Physiological_type& chaste_parameters_type::
    Physiological () const
    {
      return this->Physiological_.get ();
    }

    chaste_parameters_type::Physiological_type& chaste_parameters_type::
    Physiological ()
    {
      return this->Physiological_.get ();
    }

    void chaste_parameters_type::
    Physiological (const Physiological_type& x)
    {
      this->Physiological_.set (x);
    }

    void chaste_parameters_type::
    Physiological (::std::unique_ptr< Physiological_type > x)
    {
      this->Physiological_.set (std::move (x));
    }

    const chaste_parameters_type::Numerical_type& chaste_parameters_type::
    Numerical () const
    {
      return this->Numerical_.get ();
    }

    chaste_parameters_type::Numerical_type& chaste_parameters_type::
    Numerical ()
    {
      return this->Numerical_.get ();
    }

    void chaste_parameters_type::
    Numerical (const Numerical_type& x)
    {
      this->Numerical_.set (x);
    }

    void chaste_parameters_type::
    Numerical (::std::unique_ptr< Numerical_type > x)
    {
      this->Numerical_.set (std::move (x));
    }

    const chaste_parameters_type::PostProcessing_optional& chaste_parameters_type::
    PostProcessing () const
    {
      return this->PostProcessing_;
    }

    chaste_parameters_type::PostProcessing_optional& chaste_parameters_type::
    PostProcessing ()
    {
      return this->PostProcessing_;
    }

    void chaste_parameters_type::
    PostProcessing (const PostProcessing_type& x)
    {
      this->PostProcessing_.set (x);
    }

    void chaste_parameters_type::
    PostProcessing (const PostProcessing_optional& x)
    {
      this->PostProcessing_ = x;
    }

    void chaste_parameters_type::
    PostProcessing (::std::unique_ptr< PostProcessing_type > x)
    {
      this->PostProcessing_.set (std::move (x));
    }


    // Stimuli
    // 

    const Stimuli::Stimulus_sequence& Stimuli::
    Stimulus () const
    {
      return this->Stimulus_;
    }

    Stimuli::Stimulus_sequence& Stimuli::
    Stimulus ()
    {
      return this->Stimulus_;
    }

    void Stimuli::
    Stimulus (const Stimulus_sequence& s)
    {
      this->Stimulus_ = s;
    }


    // CellHeterogeneities
    // 

    const CellHeterogeneities::CellHeterogeneity_sequence& CellHeterogeneities::
    CellHeterogeneity () const
    {
      return this->CellHeterogeneity_;
    }

    CellHeterogeneities::CellHeterogeneity_sequence& CellHeterogeneities::
    CellHeterogeneity ()
    {
      return this->CellHeterogeneity_;
    }

    void CellHeterogeneities::
    CellHeterogeneity (const CellHeterogeneity_sequence& s)
    {
      this->CellHeterogeneity_ = s;
    }


    // ConductivityHeterogeneities
    // 

    const ConductivityHeterogeneities::ConductivityHeterogeneity_sequence& ConductivityHeterogeneities::
    ConductivityHeterogeneity () const
    {
      return this->ConductivityHeterogeneity_;
    }

    ConductivityHeterogeneities::ConductivityHeterogeneity_sequence& ConductivityHeterogeneities::
    ConductivityHeterogeneity ()
    {
      return this->ConductivityHeterogeneity_;
    }

    void ConductivityHeterogeneities::
    ConductivityHeterogeneity (const ConductivityHeterogeneity_sequence& s)
    {
      this->ConductivityHeterogeneity_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace chaste
{
  namespace parameters
  {
    // time_type
    //

    const time_type::unit_type time_type::unit_default_value_ (
      "ms");

    time_type::
    time_type (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      unit_ (unit_default_value (), this)
    {
    }

    time_type::
    time_type (const time_type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      unit_ (x.unit_, f, this)
    {
    }

    time_type::
    time_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void time_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    time_type* time_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class time_type (*this, f, c);
    }

    time_type& time_type::
    operator= (const time_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    time_type::
    ~time_type ()
    {
    }

    // dimensionless_type
    //

    const dimensionless_type::unit_type dimensionless_type::unit_default_value_ (
      "dimensionless");

    dimensionless_type::
    dimensionless_type (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      unit_ (unit_default_value (), this)
    {
    }

    dimensionless_type::
    dimensionless_type (const dimensionless_type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      unit_ (x.unit_, f, this)
    {
    }

    dimensionless_type::
    dimensionless_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void dimensionless_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    dimensionless_type* dimensionless_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class dimensionless_type (*this, f, c);
    }

    dimensionless_type& dimensionless_type::
    operator= (const dimensionless_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    dimensionless_type::
    ~dimensionless_type ()
    {
    }

    // conductivity_type
    //

    const conductivity_type::unit_type conductivity_type::unit_default_value_ (
      "mS/cm");

    conductivity_type::
    conductivity_type (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      unit_ (unit_default_value (), this)
    {
    }

    conductivity_type::
    conductivity_type (const conductivity_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      unit_ (x.unit_, f, this)
    {
    }

    conductivity_type::
    conductivity_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void conductivity_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    conductivity_type* conductivity_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class conductivity_type (*this, f, c);
    }

    conductivity_type& conductivity_type::
    operator= (const conductivity_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    conductivity_type::
    ~conductivity_type ()
    {
    }

    // stimulus_strength_type
    //

    const stimulus_strength_type::unit_type stimulus_strength_type::unit_default_value_ (
      "uA/cm^3");

    stimulus_strength_type::
    stimulus_strength_type (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      unit_ (unit_default_value (), this)
    {
    }

    stimulus_strength_type::
    stimulus_strength_type (const stimulus_strength_type& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      unit_ (x.unit_, f, this)
    {
    }

    stimulus_strength_type::
    stimulus_strength_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void stimulus_strength_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    stimulus_strength_type* stimulus_strength_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class stimulus_strength_type (*this, f, c);
    }

    stimulus_strength_type& stimulus_strength_type::
    operator= (const stimulus_strength_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    stimulus_strength_type::
    ~stimulus_strength_type ()
    {
    }

    // inverse_length_type
    //

    const inverse_length_type::unit_type inverse_length_type::unit_default_value_ (
      "1/cm");

    inverse_length_type::
    inverse_length_type (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      unit_ (unit_default_value (), this)
    {
    }

    inverse_length_type::
    inverse_length_type (const inverse_length_type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      unit_ (x.unit_, f, this)
    {
    }

    inverse_length_type::
    inverse_length_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void inverse_length_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    inverse_length_type* inverse_length_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class inverse_length_type (*this, f, c);
    }

    inverse_length_type& inverse_length_type::
    operator= (const inverse_length_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    inverse_length_type::
    ~inverse_length_type ()
    {
    }

    // capacitance_type
    //

    const capacitance_type::unit_type capacitance_type::unit_default_value_ (
      "uF/cm^2");

    capacitance_type::
    capacitance_type (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      unit_ (unit_default_value (), this)
    {
    }

    capacitance_type::
    capacitance_type (const capacitance_type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      unit_ (x.unit_, f, this)
    {
    }

    capacitance_type::
    capacitance_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void capacitance_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    capacitance_type* capacitance_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class capacitance_type (*this, f, c);
    }

    capacitance_type& capacitance_type::
    operator= (const capacitance_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    capacitance_type::
    ~capacitance_type ()
    {
    }

    // location_type
    //

    const location_type::unit_type location_type::unit_default_value_ (
      "cm");

    location_type::
    location_type (const Cuboid_type& Cuboid)
    : ::xml_schema::type (),
      Cuboid_ (Cuboid, this),
      unit_ (unit_default_value (), this)
    {
    }

    location_type::
    location_type (::std::unique_ptr< Cuboid_type > Cuboid)
    : ::xml_schema::type (),
      Cuboid_ (std::move (Cuboid), this),
      unit_ (unit_default_value (), this)
    {
    }

    location_type::
    location_type (const location_type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Cuboid_ (x.Cuboid_, f, this),
      unit_ (x.unit_, f, this)
    {
    }

    location_type::
    location_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Cuboid_ (this),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void location_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Cuboid
        //
        if (n.name () == "Cuboid" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Cuboid_type > r (
            Cuboid_traits::create (i, f, this));

          if (!Cuboid_.present ())
          {
            this->Cuboid_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Cuboid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Cuboid",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    location_type* location_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class location_type (*this, f, c);
    }

    location_type& location_type::
    operator= (const location_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Cuboid_ = x.Cuboid_;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    location_type::
    ~location_type ()
    {
    }

    // domain_type
    //

    domain_type::
    domain_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_domain_type_convert ();
    }

    domain_type::
    domain_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_domain_type_convert ();
    }

    domain_type::
    domain_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_domain_type_convert ();
    }

    domain_type* domain_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class domain_type (*this, f, c);
    }

    domain_type::value domain_type::
    _xsd_domain_type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_domain_type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_domain_type_indexes_,
                        _xsd_domain_type_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_domain_type_indexes_ + 2 || _xsd_domain_type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const domain_type::
    _xsd_domain_type_literals_[2] =
    {
      "Mono",
      "Bi"
    };

    const domain_type::value domain_type::
    _xsd_domain_type_indexes_[2] =
    {
      ::chaste::parameters::domain_type::Bi,
      ::chaste::parameters::domain_type::Mono
    };

    // ionic_models_available_type
    //

    ionic_models_available_type::
    ionic_models_available_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ionic_models_available_type_convert ();
    }

    ionic_models_available_type::
    ionic_models_available_type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ionic_models_available_type_convert ();
    }

    ionic_models_available_type::
    ionic_models_available_type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ionic_models_available_type_convert ();
    }

    ionic_models_available_type* ionic_models_available_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ionic_models_available_type (*this, f, c);
    }

    ionic_models_available_type::value ionic_models_available_type::
    _xsd_ionic_models_available_type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ionic_models_available_type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ionic_models_available_type_indexes_,
                        _xsd_ionic_models_available_type_indexes_ + 9,
                        *this,
                        c));

      if (i == _xsd_ionic_models_available_type_indexes_ + 9 || _xsd_ionic_models_available_type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ionic_models_available_type::
    _xsd_ionic_models_available_type_literals_[9] =
    {
      "Fox2002BackwardEuler",
      "LuoRudyIBackwardEuler",
      "LuoRudyI",
      "FaberRudy2000Optimised",
      "FaberRudy2000",
      "DifrancescoNoble",
      "MahajanShiferaw",
      "HodgkinHuxley",
      "tenTusscher2006"
    };

    const ionic_models_available_type::value ionic_models_available_type::
    _xsd_ionic_models_available_type_indexes_[9] =
    {
      ::chaste::parameters::ionic_models_available_type::DifrancescoNoble,
      ::chaste::parameters::ionic_models_available_type::FaberRudy2000,
      ::chaste::parameters::ionic_models_available_type::FaberRudy2000Optimised,
      ::chaste::parameters::ionic_models_available_type::Fox2002BackwardEuler,
      ::chaste::parameters::ionic_models_available_type::HodgkinHuxley,
      ::chaste::parameters::ionic_models_available_type::LuoRudyI,
      ::chaste::parameters::ionic_models_available_type::LuoRudyIBackwardEuler,
      ::chaste::parameters::ionic_models_available_type::MahajanShiferaw,
      ::chaste::parameters::ionic_models_available_type::tenTusscher2006
    };

    // ionic_model_region_type
    //

    ionic_model_region_type::
    ionic_model_region_type (const IonicModel_type& IonicModel,
                             const Location_type& Location)
    : ::xml_schema::type (),
      IonicModel_ (IonicModel, this),
      Location_ (Location, this)
    {
    }

    ionic_model_region_type::
    ionic_model_region_type (const IonicModel_type& IonicModel,
                             ::std::unique_ptr< Location_type > Location)
    : ::xml_schema::type (),
      IonicModel_ (IonicModel, this),
      Location_ (std::move (Location), this)
    {
    }

    ionic_model_region_type::
    ionic_model_region_type (const ionic_model_region_type& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IonicModel_ (x.IonicModel_, f, this),
      Location_ (x.Location_, f, this)
    {
    }

    ionic_model_region_type::
    ionic_model_region_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IonicModel_ (this),
      Location_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ionic_model_region_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IonicModel
        //
        if (n.name () == "IonicModel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IonicModel_type > r (
            IonicModel_traits::create (i, f, this));

          if (!IonicModel_.present ())
          {
            this->IonicModel_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!IonicModel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IonicModel",
          "");
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "");
      }
    }

    ionic_model_region_type* ionic_model_region_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ionic_model_region_type (*this, f, c);
    }

    ionic_model_region_type& ionic_model_region_type::
    operator= (const ionic_model_region_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IonicModel_ = x.IonicModel_;
        this->Location_ = x.Location_;
      }

      return *this;
    }

    ionic_model_region_type::
    ~ionic_model_region_type ()
    {
    }

    // ionic_models_type
    //

    ionic_models_type::
    ionic_models_type (const Default_type& Default)
    : ::xml_schema::type (),
      Default_ (Default, this),
      Region_ (this)
    {
    }

    ionic_models_type::
    ionic_models_type (const ionic_models_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Default_ (x.Default_, f, this),
      Region_ (x.Region_, f, this)
    {
    }

    ionic_models_type::
    ionic_models_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Default_ (this),
      Region_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ionic_models_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Default
        //
        if (n.name () == "Default" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Default_type > r (
            Default_traits::create (i, f, this));

          if (!Default_.present ())
          {
            this->Default_.set (::std::move (r));
            continue;
          }
        }

        // Region
        //
        if (n.name () == "Region" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Region_type > r (
            Region_traits::create (i, f, this));

          this->Region_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!Default_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Default",
          "");
      }
    }

    ionic_models_type* ionic_models_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ionic_models_type (*this, f, c);
    }

    ionic_models_type& ionic_models_type::
    operator= (const ionic_models_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Default_ = x.Default_;
        this->Region_ = x.Region_;
      }

      return *this;
    }

    ionic_models_type::
    ~ionic_models_type ()
    {
    }

    // apd_map_type
    //

    const apd_map_type::threshold_unit_type apd_map_type::threshold_unit_default_value_ (
      "mV");

    apd_map_type::
    apd_map_type (const repolarisation_percentage_type& repolarisation_percentage,
                  const threshold_type& threshold)
    : ::xml_schema::type (),
      repolarisation_percentage_ (repolarisation_percentage, this),
      threshold_ (threshold, this),
      threshold_unit_ (threshold_unit_default_value (), this)
    {
    }

    apd_map_type::
    apd_map_type (const apd_map_type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      repolarisation_percentage_ (x.repolarisation_percentage_, f, this),
      threshold_ (x.threshold_, f, this),
      threshold_unit_ (x.threshold_unit_, f, this)
    {
    }

    apd_map_type::
    apd_map_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      repolarisation_percentage_ (this),
      threshold_ (this),
      threshold_unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void apd_map_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "repolarisation_percentage" && n.namespace_ ().empty ())
        {
          this->repolarisation_percentage_.set (repolarisation_percentage_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "threshold" && n.namespace_ ().empty ())
        {
          this->threshold_.set (threshold_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "threshold_unit" && n.namespace_ ().empty ())
        {
          this->threshold_unit_.set (threshold_unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!repolarisation_percentage_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "repolarisation_percentage",
          "");
      }

      if (!threshold_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "threshold",
          "");
      }

      if (!threshold_unit_.present ())
      {
        this->threshold_unit_.set (threshold_unit_default_value ());
      }
    }

    apd_map_type* apd_map_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class apd_map_type (*this, f, c);
    }

    apd_map_type& apd_map_type::
    operator= (const apd_map_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->repolarisation_percentage_ = x.repolarisation_percentage_;
        this->threshold_ = x.threshold_;
        this->threshold_unit_ = x.threshold_unit_;
      }

      return *this;
    }

    apd_map_type::
    ~apd_map_type ()
    {
    }

    // upstrokes_map_type
    //

    const upstrokes_map_type::threshold_unit_type upstrokes_map_type::threshold_unit_default_value_ (
      "mV");

    upstrokes_map_type::
    upstrokes_map_type (const threshold_type& threshold)
    : ::xml_schema::type (),
      threshold_ (threshold, this),
      threshold_unit_ (threshold_unit_default_value (), this)
    {
    }

    upstrokes_map_type::
    upstrokes_map_type (const upstrokes_map_type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      threshold_ (x.threshold_, f, this),
      threshold_unit_ (x.threshold_unit_, f, this)
    {
    }

    upstrokes_map_type::
    upstrokes_map_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      threshold_ (this),
      threshold_unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void upstrokes_map_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "threshold" && n.namespace_ ().empty ())
        {
          this->threshold_.set (threshold_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "threshold_unit" && n.namespace_ ().empty ())
        {
          this->threshold_unit_.set (threshold_unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!threshold_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "threshold",
          "");
      }

      if (!threshold_unit_.present ())
      {
        this->threshold_unit_.set (threshold_unit_default_value ());
      }
    }

    upstrokes_map_type* upstrokes_map_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class upstrokes_map_type (*this, f, c);
    }

    upstrokes_map_type& upstrokes_map_type::
    operator= (const upstrokes_map_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->threshold_ = x.threshold_;
        this->threshold_unit_ = x.threshold_unit_;
      }

      return *this;
    }

    upstrokes_map_type::
    ~upstrokes_map_type ()
    {
    }

    // empty_type
    //

    empty_type::
    empty_type ()
    : ::xml_schema::type ()
    {
    }

    empty_type::
    empty_type (const empty_type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    empty_type::
    empty_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    empty_type::
    empty_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    empty_type::
    empty_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    empty_type* empty_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class empty_type (*this, f, c);
    }

    empty_type::
    ~empty_type ()
    {
    }

    // conduction_velocity_map_type
    //

    conduction_velocity_map_type::
    conduction_velocity_map_type (const origin_node_type& origin_node)
    : ::xml_schema::type (),
      origin_node_ (origin_node, this)
    {
    }

    conduction_velocity_map_type::
    conduction_velocity_map_type (const conduction_velocity_map_type& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      origin_node_ (x.origin_node_, f, this)
    {
    }

    conduction_velocity_map_type::
    conduction_velocity_map_type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      origin_node_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void conduction_velocity_map_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "origin_node" && n.namespace_ ().empty ())
        {
          this->origin_node_.set (origin_node_traits::create (i, f, this));
          continue;
        }
      }

      if (!origin_node_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "origin_node",
          "");
      }
    }

    conduction_velocity_map_type* conduction_velocity_map_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class conduction_velocity_map_type (*this, f, c);
    }

    conduction_velocity_map_type& conduction_velocity_map_type::
    operator= (const conduction_velocity_map_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->origin_node_ = x.origin_node_;
      }

      return *this;
    }

    conduction_velocity_map_type::
    ~conduction_velocity_map_type ()
    {
    }

    // media_type
    //

    media_type::
    media_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_media_type_convert ();
    }

    media_type::
    media_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_media_type_convert ();
    }

    media_type::
    media_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_media_type_convert ();
    }

    media_type* media_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class media_type (*this, f, c);
    }

    media_type::value media_type::
    _xsd_media_type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_media_type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_media_type_indexes_,
                        _xsd_media_type_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_media_type_indexes_ + 3 || _xsd_media_type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const media_type::
    _xsd_media_type_literals_[3] =
    {
      "Orthotropic",
      "Axisymmetric",
      "NoFibreOrientation"
    };

    const media_type::value media_type::
    _xsd_media_type_indexes_[3] =
    {
      ::chaste::parameters::media_type::Axisymmetric,
      ::chaste::parameters::media_type::NoFibreOrientation,
      ::chaste::parameters::media_type::Orthotropic
    };

    // point_type
    //

    point_type::
    point_type (const x_type& x,
                const y_type& y,
                const z_type& z)
    : ::xml_schema::type (),
      x_ (x, this),
      y_ (y, this),
      z_ (z, this)
    {
    }

    point_type::
    point_type (const point_type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      z_ (x.z_, f, this)
    {
    }

    point_type::
    point_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (this),
      y_ (this),
      z_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void point_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "z" && n.namespace_ ().empty ())
        {
          this->z_.set (z_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }

      if (!z_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "z",
          "");
      }
    }

    point_type* point_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class point_type (*this, f, c);
    }

    point_type& point_type::
    operator= (const point_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
      }

      return *this;
    }

    point_type::
    ~point_type ()
    {
    }

    // box_type
    //

    box_type::
    box_type (const LowerCoordinates_type& LowerCoordinates,
              const UpperCoordinates_type& UpperCoordinates)
    : ::xml_schema::type (),
      LowerCoordinates_ (LowerCoordinates, this),
      UpperCoordinates_ (UpperCoordinates, this)
    {
    }

    box_type::
    box_type (::std::unique_ptr< LowerCoordinates_type > LowerCoordinates,
              ::std::unique_ptr< UpperCoordinates_type > UpperCoordinates)
    : ::xml_schema::type (),
      LowerCoordinates_ (std::move (LowerCoordinates), this),
      UpperCoordinates_ (std::move (UpperCoordinates), this)
    {
    }

    box_type::
    box_type (const box_type& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LowerCoordinates_ (x.LowerCoordinates_, f, this),
      UpperCoordinates_ (x.UpperCoordinates_, f, this)
    {
    }

    box_type::
    box_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LowerCoordinates_ (this),
      UpperCoordinates_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void box_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LowerCoordinates
        //
        if (n.name () == "LowerCoordinates" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< LowerCoordinates_type > r (
            LowerCoordinates_traits::create (i, f, this));

          if (!LowerCoordinates_.present ())
          {
            this->LowerCoordinates_.set (::std::move (r));
            continue;
          }
        }

        // UpperCoordinates
        //
        if (n.name () == "UpperCoordinates" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< UpperCoordinates_type > r (
            UpperCoordinates_traits::create (i, f, this));

          if (!UpperCoordinates_.present ())
          {
            this->UpperCoordinates_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!LowerCoordinates_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LowerCoordinates",
          "");
      }

      if (!UpperCoordinates_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UpperCoordinates",
          "");
      }
    }

    box_type* box_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class box_type (*this, f, c);
    }

    box_type& box_type::
    operator= (const box_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LowerCoordinates_ = x.LowerCoordinates_;
        this->UpperCoordinates_ = x.UpperCoordinates_;
      }

      return *this;
    }

    box_type::
    ~box_type ()
    {
    }

    // stimulus_type
    //

    stimulus_type::
    stimulus_type (const Strength_type& Strength,
                   const Duration_type& Duration,
                   const Delay_type& Delay,
                   const Location_type& Location)
    : ::xml_schema::type (),
      Strength_ (Strength, this),
      Duration_ (Duration, this),
      Delay_ (Delay, this),
      Location_ (Location, this)
    {
    }

    stimulus_type::
    stimulus_type (::std::unique_ptr< Strength_type > Strength,
                   ::std::unique_ptr< Duration_type > Duration,
                   ::std::unique_ptr< Delay_type > Delay,
                   ::std::unique_ptr< Location_type > Location)
    : ::xml_schema::type (),
      Strength_ (std::move (Strength), this),
      Duration_ (std::move (Duration), this),
      Delay_ (std::move (Delay), this),
      Location_ (std::move (Location), this)
    {
    }

    stimulus_type::
    stimulus_type (const stimulus_type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Strength_ (x.Strength_, f, this),
      Duration_ (x.Duration_, f, this),
      Delay_ (x.Delay_, f, this),
      Location_ (x.Location_, f, this)
    {
    }

    stimulus_type::
    stimulus_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Strength_ (this),
      Duration_ (this),
      Delay_ (this),
      Location_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void stimulus_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Strength
        //
        if (n.name () == "Strength" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Strength_type > r (
            Strength_traits::create (i, f, this));

          if (!Strength_.present ())
          {
            this->Strength_.set (::std::move (r));
            continue;
          }
        }

        // Duration
        //
        if (n.name () == "Duration" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Duration_type > r (
            Duration_traits::create (i, f, this));

          if (!Duration_.present ())
          {
            this->Duration_.set (::std::move (r));
            continue;
          }
        }

        // Delay
        //
        if (n.name () == "Delay" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Delay_type > r (
            Delay_traits::create (i, f, this));

          if (!Delay_.present ())
          {
            this->Delay_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Strength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Strength",
          "");
      }

      if (!Duration_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Duration",
          "");
      }

      if (!Delay_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Delay",
          "");
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "");
      }
    }

    stimulus_type* stimulus_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class stimulus_type (*this, f, c);
    }

    stimulus_type& stimulus_type::
    operator= (const stimulus_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Strength_ = x.Strength_;
        this->Duration_ = x.Duration_;
        this->Delay_ = x.Delay_;
        this->Location_ = x.Location_;
      }

      return *this;
    }

    stimulus_type::
    ~stimulus_type ()
    {
    }

    // cell_heterogeneity_type
    //

    cell_heterogeneity_type::
    cell_heterogeneity_type (const ScaleFactorGks_type& ScaleFactorGks,
                             const ScaleFactorIto_type& ScaleFactorIto,
                             const ScaleFactorGkr_type& ScaleFactorGkr,
                             const Location_type& Location)
    : ::xml_schema::type (),
      ScaleFactorGks_ (ScaleFactorGks, this),
      ScaleFactorIto_ (ScaleFactorIto, this),
      ScaleFactorGkr_ (ScaleFactorGkr, this),
      Location_ (Location, this)
    {
    }

    cell_heterogeneity_type::
    cell_heterogeneity_type (::std::unique_ptr< ScaleFactorGks_type > ScaleFactorGks,
                             ::std::unique_ptr< ScaleFactorIto_type > ScaleFactorIto,
                             ::std::unique_ptr< ScaleFactorGkr_type > ScaleFactorGkr,
                             ::std::unique_ptr< Location_type > Location)
    : ::xml_schema::type (),
      ScaleFactorGks_ (std::move (ScaleFactorGks), this),
      ScaleFactorIto_ (std::move (ScaleFactorIto), this),
      ScaleFactorGkr_ (std::move (ScaleFactorGkr), this),
      Location_ (std::move (Location), this)
    {
    }

    cell_heterogeneity_type::
    cell_heterogeneity_type (const cell_heterogeneity_type& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ScaleFactorGks_ (x.ScaleFactorGks_, f, this),
      ScaleFactorIto_ (x.ScaleFactorIto_, f, this),
      ScaleFactorGkr_ (x.ScaleFactorGkr_, f, this),
      Location_ (x.Location_, f, this)
    {
    }

    cell_heterogeneity_type::
    cell_heterogeneity_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ScaleFactorGks_ (this),
      ScaleFactorIto_ (this),
      ScaleFactorGkr_ (this),
      Location_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cell_heterogeneity_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ScaleFactorGks
        //
        if (n.name () == "ScaleFactorGks" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ScaleFactorGks_type > r (
            ScaleFactorGks_traits::create (i, f, this));

          if (!ScaleFactorGks_.present ())
          {
            this->ScaleFactorGks_.set (::std::move (r));
            continue;
          }
        }

        // ScaleFactorIto
        //
        if (n.name () == "ScaleFactorIto" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ScaleFactorIto_type > r (
            ScaleFactorIto_traits::create (i, f, this));

          if (!ScaleFactorIto_.present ())
          {
            this->ScaleFactorIto_.set (::std::move (r));
            continue;
          }
        }

        // ScaleFactorGkr
        //
        if (n.name () == "ScaleFactorGkr" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ScaleFactorGkr_type > r (
            ScaleFactorGkr_traits::create (i, f, this));

          if (!ScaleFactorGkr_.present ())
          {
            this->ScaleFactorGkr_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ScaleFactorGks_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleFactorGks",
          "");
      }

      if (!ScaleFactorIto_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleFactorIto",
          "");
      }

      if (!ScaleFactorGkr_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleFactorGkr",
          "");
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "");
      }
    }

    cell_heterogeneity_type* cell_heterogeneity_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cell_heterogeneity_type (*this, f, c);
    }

    cell_heterogeneity_type& cell_heterogeneity_type::
    operator= (const cell_heterogeneity_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ScaleFactorGks_ = x.ScaleFactorGks_;
        this->ScaleFactorIto_ = x.ScaleFactorIto_;
        this->ScaleFactorGkr_ = x.ScaleFactorGkr_;
        this->Location_ = x.Location_;
      }

      return *this;
    }

    cell_heterogeneity_type::
    ~cell_heterogeneity_type ()
    {
    }

    // conductivity_heterogeneity_type
    //

    conductivity_heterogeneity_type::
    conductivity_heterogeneity_type (const Location_type& Location)
    : ::xml_schema::type (),
      IntracellularConductivities_ (this),
      ExtracellularConductivities_ (this),
      Location_ (Location, this)
    {
    }

    conductivity_heterogeneity_type::
    conductivity_heterogeneity_type (::std::unique_ptr< Location_type > Location)
    : ::xml_schema::type (),
      IntracellularConductivities_ (this),
      ExtracellularConductivities_ (this),
      Location_ (std::move (Location), this)
    {
    }

    conductivity_heterogeneity_type::
    conductivity_heterogeneity_type (const conductivity_heterogeneity_type& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IntracellularConductivities_ (x.IntracellularConductivities_, f, this),
      ExtracellularConductivities_ (x.ExtracellularConductivities_, f, this),
      Location_ (x.Location_, f, this)
    {
    }

    conductivity_heterogeneity_type::
    conductivity_heterogeneity_type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IntracellularConductivities_ (this),
      ExtracellularConductivities_ (this),
      Location_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void conductivity_heterogeneity_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntracellularConductivities
        //
        if (n.name () == "IntracellularConductivities" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IntracellularConductivities_type > r (
            IntracellularConductivities_traits::create (i, f, this));

          if (!this->IntracellularConductivities_)
          {
            this->IntracellularConductivities_.set (::std::move (r));
            continue;
          }
        }

        // ExtracellularConductivities
        //
        if (n.name () == "ExtracellularConductivities" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ExtracellularConductivities_type > r (
            ExtracellularConductivities_traits::create (i, f, this));

          if (!this->ExtracellularConductivities_)
          {
            this->ExtracellularConductivities_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "");
      }
    }

    conductivity_heterogeneity_type* conductivity_heterogeneity_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class conductivity_heterogeneity_type (*this, f, c);
    }

    conductivity_heterogeneity_type& conductivity_heterogeneity_type::
    operator= (const conductivity_heterogeneity_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IntracellularConductivities_ = x.IntracellularConductivities_;
        this->ExtracellularConductivities_ = x.ExtracellularConductivities_;
        this->Location_ = x.Location_;
      }

      return *this;
    }

    conductivity_heterogeneity_type::
    ~conductivity_heterogeneity_type ()
    {
    }

    // slab_type
    //

    slab_type::
    slab_type (const x_type& x,
               const y_type& y,
               const z_type& z,
               const inter_node_space_type& inter_node_space)
    : ::xml_schema::type (),
      x_ (x, this),
      y_ (y, this),
      z_ (z, this),
      inter_node_space_ (inter_node_space, this)
    {
    }

    slab_type::
    slab_type (const slab_type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      z_ (x.z_, f, this),
      inter_node_space_ (x.inter_node_space_, f, this)
    {
    }

    slab_type::
    slab_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (this),
      y_ (this),
      z_ (this),
      inter_node_space_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void slab_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "z" && n.namespace_ ().empty ())
        {
          this->z_.set (z_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "inter_node_space" && n.namespace_ ().empty ())
        {
          this->inter_node_space_.set (inter_node_space_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }

      if (!z_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "z",
          "");
      }

      if (!inter_node_space_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "inter_node_space",
          "");
      }
    }

    slab_type* slab_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class slab_type (*this, f, c);
    }

    slab_type& slab_type::
    operator= (const slab_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
        this->inter_node_space_ = x.inter_node_space_;
      }

      return *this;
    }

    slab_type::
    ~slab_type ()
    {
    }

    // sheet_type
    //

    sheet_type::
    sheet_type (const x_type& x,
                const y_type& y,
                const inter_node_space_type& inter_node_space)
    : ::xml_schema::type (),
      x_ (x, this),
      y_ (y, this),
      inter_node_space_ (inter_node_space, this)
    {
    }

    sheet_type::
    sheet_type (const sheet_type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      inter_node_space_ (x.inter_node_space_, f, this)
    {
    }

    sheet_type::
    sheet_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (this),
      y_ (this),
      inter_node_space_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void sheet_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "inter_node_space" && n.namespace_ ().empty ())
        {
          this->inter_node_space_.set (inter_node_space_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }

      if (!inter_node_space_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "inter_node_space",
          "");
      }
    }

    sheet_type* sheet_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class sheet_type (*this, f, c);
    }

    sheet_type& sheet_type::
    operator= (const sheet_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->inter_node_space_ = x.inter_node_space_;
      }

      return *this;
    }

    sheet_type::
    ~sheet_type ()
    {
    }

    // fibre_type
    //

    fibre_type::
    fibre_type (const x_type& x,
                const inter_node_space_type& inter_node_space)
    : ::xml_schema::type (),
      x_ (x, this),
      inter_node_space_ (inter_node_space, this)
    {
    }

    fibre_type::
    fibre_type (const fibre_type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      inter_node_space_ (x.inter_node_space_, f, this)
    {
    }

    fibre_type::
    fibre_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (this),
      inter_node_space_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void fibre_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "inter_node_space" && n.namespace_ ().empty ())
        {
          this->inter_node_space_.set (inter_node_space_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!inter_node_space_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "inter_node_space",
          "");
      }
    }

    fibre_type* fibre_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class fibre_type (*this, f, c);
    }

    fibre_type& fibre_type::
    operator= (const fibre_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->x_ = x.x_;
        this->inter_node_space_ = x.inter_node_space_;
      }

      return *this;
    }

    fibre_type::
    ~fibre_type ()
    {
    }

    // load_mesh_type
    //

    load_mesh_type::
    load_mesh_type (const name_type& name,
                    const conductivity_media_type& conductivity_media)
    : ::xml_schema::type (),
      name_ (name, this),
      conductivity_media_ (conductivity_media, this)
    {
    }

    load_mesh_type::
    load_mesh_type (const load_mesh_type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      conductivity_media_ (x.conductivity_media_, f, this)
    {
    }

    load_mesh_type::
    load_mesh_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      conductivity_media_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void load_mesh_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "conductivity_media" && n.namespace_ ().empty ())
        {
          this->conductivity_media_.set (conductivity_media_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!conductivity_media_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "conductivity_media",
          "");
      }
    }

    load_mesh_type* load_mesh_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class load_mesh_type (*this, f, c);
    }

    load_mesh_type& load_mesh_type::
    operator= (const load_mesh_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->conductivity_media_ = x.conductivity_media_;
      }

      return *this;
    }

    load_mesh_type::
    ~load_mesh_type ()
    {
    }

    // mesh_type
    //

    const mesh_type::unit_type mesh_type::unit_default_value_ (
      "cm");

    mesh_type::
    mesh_type ()
    : ::xml_schema::type (),
      Slab_ (this),
      Sheet_ (this),
      Fibre_ (this),
      LoadMesh_ (this),
      unit_ (unit_default_value (), this)
    {
    }

    mesh_type::
    mesh_type (const mesh_type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Slab_ (x.Slab_, f, this),
      Sheet_ (x.Sheet_, f, this),
      Fibre_ (x.Fibre_, f, this),
      LoadMesh_ (x.LoadMesh_, f, this),
      unit_ (x.unit_, f, this)
    {
    }

    mesh_type::
    mesh_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Slab_ (this),
      Sheet_ (this),
      Fibre_ (this),
      LoadMesh_ (this),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void mesh_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Slab
        //
        if (n.name () == "Slab" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Slab_type > r (
            Slab_traits::create (i, f, this));

          if (!this->Slab_)
          {
            this->Slab_.set (::std::move (r));
            continue;
          }
        }

        // Sheet
        //
        if (n.name () == "Sheet" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Sheet_type > r (
            Sheet_traits::create (i, f, this));

          if (!this->Sheet_)
          {
            this->Sheet_.set (::std::move (r));
            continue;
          }
        }

        // Fibre
        //
        if (n.name () == "Fibre" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Fibre_type > r (
            Fibre_traits::create (i, f, this));

          if (!this->Fibre_)
          {
            this->Fibre_.set (::std::move (r));
            continue;
          }
        }

        // LoadMesh
        //
        if (n.name () == "LoadMesh" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< LoadMesh_type > r (
            LoadMesh_traits::create (i, f, this));

          if (!this->LoadMesh_)
          {
            this->LoadMesh_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    mesh_type* mesh_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class mesh_type (*this, f, c);
    }

    mesh_type& mesh_type::
    operator= (const mesh_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Slab_ = x.Slab_;
        this->Sheet_ = x.Sheet_;
        this->Fibre_ = x.Fibre_;
        this->LoadMesh_ = x.LoadMesh_;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    mesh_type::
    ~mesh_type ()
    {
    }

    // conductivities_type
    //

    const conductivities_type::unit_type conductivities_type::unit_default_value_ (
      "mS/cm");

    conductivities_type::
    conductivities_type (const longi_type& longi,
                         const trans_type& trans,
                         const normal_type& normal)
    : ::xml_schema::type (),
      longi_ (longi, this),
      trans_ (trans, this),
      normal_ (normal, this),
      unit_ (unit_default_value (), this)
    {
    }

    conductivities_type::
    conductivities_type (const conductivities_type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      longi_ (x.longi_, f, this),
      trans_ (x.trans_, f, this),
      normal_ (x.normal_, f, this),
      unit_ (x.unit_, f, this)
    {
    }

    conductivities_type::
    conductivities_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      longi_ (this),
      trans_ (this),
      normal_ (this),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void conductivities_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "longi" && n.namespace_ ().empty ())
        {
          this->longi_.set (longi_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "trans" && n.namespace_ ().empty ())
        {
          this->trans_.set (trans_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "normal" && n.namespace_ ().empty ())
        {
          this->normal_.set (normal_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!longi_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "longi",
          "");
      }

      if (!trans_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "trans",
          "");
      }

      if (!normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "normal",
          "");
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    conductivities_type* conductivities_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class conductivities_type (*this, f, c);
    }

    conductivities_type& conductivities_type::
    operator= (const conductivities_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->longi_ = x.longi_;
        this->trans_ = x.trans_;
        this->normal_ = x.normal_;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    conductivities_type::
    ~conductivities_type ()
    {
    }

    // time_steps_type
    //

    const time_steps_type::unit_type time_steps_type::unit_default_value_ (
      "ms");

    time_steps_type::
    time_steps_type (const ode_type& ode,
                     const pde_type& pde,
                     const printing_type& printing)
    : ::xml_schema::type (),
      ode_ (ode, this),
      pde_ (pde, this),
      printing_ (printing, this),
      unit_ (unit_default_value (), this)
    {
    }

    time_steps_type::
    time_steps_type (const time_steps_type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ode_ (x.ode_, f, this),
      pde_ (x.pde_, f, this),
      printing_ (x.printing_, f, this),
      unit_ (x.unit_, f, this)
    {
    }

    time_steps_type::
    time_steps_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ode_ (this),
      pde_ (this),
      printing_ (this),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void time_steps_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ode" && n.namespace_ ().empty ())
        {
          this->ode_.set (ode_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "pde" && n.namespace_ ().empty ())
        {
          this->pde_.set (pde_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "printing" && n.namespace_ ().empty ())
        {
          this->printing_.set (printing_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }
      }

      if (!ode_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ode",
          "");
      }

      if (!pde_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "pde",
          "");
      }

      if (!printing_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "printing",
          "");
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }
    }

    time_steps_type* time_steps_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class time_steps_type (*this, f, c);
    }

    time_steps_type& time_steps_type::
    operator= (const time_steps_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ode_ = x.ode_;
        this->pde_ = x.pde_;
        this->printing_ = x.printing_;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    time_steps_type::
    ~time_steps_type ()
    {
    }

    // ksp_use_type
    //

    ksp_use_type::
    ksp_use_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ksp_use_type_convert ();
    }

    ksp_use_type::
    ksp_use_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ksp_use_type_convert ();
    }

    ksp_use_type::
    ksp_use_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ksp_use_type_convert ();
    }

    ksp_use_type* ksp_use_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ksp_use_type (*this, f, c);
    }

    ksp_use_type::value ksp_use_type::
    _xsd_ksp_use_type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_use_type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ksp_use_type_indexes_,
                        _xsd_ksp_use_type_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ksp_use_type_indexes_ + 2 || _xsd_ksp_use_type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ksp_use_type::
    _xsd_ksp_use_type_literals_[2] =
    {
      "relative",
      "absolute"
    };

    const ksp_use_type::value ksp_use_type::
    _xsd_ksp_use_type_indexes_[2] =
    {
      ::chaste::parameters::ksp_use_type::absolute,
      ::chaste::parameters::ksp_use_type::relative
    };

    // ksp_tolerances_type
    //

    ksp_tolerances_type::
    ksp_tolerances_type ()
    : ::xml_schema::type (),
      KSPRelative_ (this),
      KSPAbsolute_ (this)
    {
    }

    ksp_tolerances_type::
    ksp_tolerances_type (const ksp_tolerances_type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      KSPRelative_ (x.KSPRelative_, f, this),
      KSPAbsolute_ (x.KSPAbsolute_, f, this)
    {
    }

    ksp_tolerances_type::
    ksp_tolerances_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      KSPRelative_ (this),
      KSPAbsolute_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ksp_tolerances_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // KSPRelative
        //
        if (n.name () == "KSPRelative" && n.namespace_ ().empty ())
        {
          if (!this->KSPRelative_)
          {
            this->KSPRelative_.set (KSPRelative_traits::create (i, f, this));
            continue;
          }
        }

        // KSPAbsolute
        //
        if (n.name () == "KSPAbsolute" && n.namespace_ ().empty ())
        {
          if (!this->KSPAbsolute_)
          {
            this->KSPAbsolute_.set (KSPAbsolute_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    ksp_tolerances_type* ksp_tolerances_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ksp_tolerances_type (*this, f, c);
    }

    ksp_tolerances_type& ksp_tolerances_type::
    operator= (const ksp_tolerances_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->KSPRelative_ = x.KSPRelative_;
        this->KSPAbsolute_ = x.KSPAbsolute_;
      }

      return *this;
    }

    ksp_tolerances_type::
    ~ksp_tolerances_type ()
    {
    }

    // ksp_solver_type
    //

    ksp_solver_type::
    ksp_solver_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ksp_solver_type_convert ();
    }

    ksp_solver_type::
    ksp_solver_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ksp_solver_type_convert ();
    }

    ksp_solver_type::
    ksp_solver_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ksp_solver_type_convert ();
    }

    ksp_solver_type* ksp_solver_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ksp_solver_type (*this, f, c);
    }

    ksp_solver_type::value ksp_solver_type::
    _xsd_ksp_solver_type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_solver_type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ksp_solver_type_indexes_,
                        _xsd_ksp_solver_type_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ksp_solver_type_indexes_ + 3 || _xsd_ksp_solver_type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ksp_solver_type::
    _xsd_ksp_solver_type_literals_[3] =
    {
      "cg",
      "symmlq",
      "gmres"
    };

    const ksp_solver_type::value ksp_solver_type::
    _xsd_ksp_solver_type_indexes_[3] =
    {
      ::chaste::parameters::ksp_solver_type::cg,
      ::chaste::parameters::ksp_solver_type::gmres,
      ::chaste::parameters::ksp_solver_type::symmlq
    };

    // ksp_preconditioner_type
    //

    ksp_preconditioner_type::
    ksp_preconditioner_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ksp_preconditioner_type_convert ();
    }

    ksp_preconditioner_type::
    ksp_preconditioner_type (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ksp_preconditioner_type_convert ();
    }

    ksp_preconditioner_type::
    ksp_preconditioner_type (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ksp_preconditioner_type_convert ();
    }

    ksp_preconditioner_type* ksp_preconditioner_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ksp_preconditioner_type (*this, f, c);
    }

    ksp_preconditioner_type::value ksp_preconditioner_type::
    _xsd_ksp_preconditioner_type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_preconditioner_type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ksp_preconditioner_type_indexes_,
                        _xsd_ksp_preconditioner_type_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_ksp_preconditioner_type_indexes_ + 6 || _xsd_ksp_preconditioner_type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ksp_preconditioner_type::
    _xsd_ksp_preconditioner_type_literals_[6] =
    {
      "ilu",
      "jacobi",
      "bjacobi",
      "hypre",
      "blockdiagonal",
      "none"
    };

    const ksp_preconditioner_type::value ksp_preconditioner_type::
    _xsd_ksp_preconditioner_type_indexes_[6] =
    {
      ::chaste::parameters::ksp_preconditioner_type::bjacobi,
      ::chaste::parameters::ksp_preconditioner_type::blockdiagonal,
      ::chaste::parameters::ksp_preconditioner_type::hypre,
      ::chaste::parameters::ksp_preconditioner_type::ilu,
      ::chaste::parameters::ksp_preconditioner_type::jacobi,
      ::chaste::parameters::ksp_preconditioner_type::none
    };

    // simulation_type
    //

    simulation_type::
    simulation_type ()
    : ::xml_schema::type (),
      SpaceDimension_ (this),
      SimulationDuration_ (this),
      Domain_ (this),
      Mesh_ (this),
      IonicModels_ (this),
      Stimuli_ (this),
      CellHeterogeneities_ (this),
      ConductivityHeterogeneities_ (this),
      OutputDirectory_ (this),
      OutputFilenamePrefix_ (this)
    {
    }

    simulation_type::
    simulation_type (const simulation_type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SpaceDimension_ (x.SpaceDimension_, f, this),
      SimulationDuration_ (x.SimulationDuration_, f, this),
      Domain_ (x.Domain_, f, this),
      Mesh_ (x.Mesh_, f, this),
      IonicModels_ (x.IonicModels_, f, this),
      Stimuli_ (x.Stimuli_, f, this),
      CellHeterogeneities_ (x.CellHeterogeneities_, f, this),
      ConductivityHeterogeneities_ (x.ConductivityHeterogeneities_, f, this),
      OutputDirectory_ (x.OutputDirectory_, f, this),
      OutputFilenamePrefix_ (x.OutputFilenamePrefix_, f, this)
    {
    }

    simulation_type::
    simulation_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SpaceDimension_ (this),
      SimulationDuration_ (this),
      Domain_ (this),
      Mesh_ (this),
      IonicModels_ (this),
      Stimuli_ (this),
      CellHeterogeneities_ (this),
      ConductivityHeterogeneities_ (this),
      OutputDirectory_ (this),
      OutputFilenamePrefix_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void simulation_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SpaceDimension
        //
        if (n.name () == "SpaceDimension" && n.namespace_ ().empty ())
        {
          if (!this->SpaceDimension_)
          {
            this->SpaceDimension_.set (SpaceDimension_traits::create (i, f, this));
            continue;
          }
        }

        // SimulationDuration
        //
        if (n.name () == "SimulationDuration" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SimulationDuration_type > r (
            SimulationDuration_traits::create (i, f, this));

          if (!this->SimulationDuration_)
          {
            this->SimulationDuration_.set (::std::move (r));
            continue;
          }
        }

        // Domain
        //
        if (n.name () == "Domain" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Domain_type > r (
            Domain_traits::create (i, f, this));

          if (!this->Domain_)
          {
            this->Domain_.set (::std::move (r));
            continue;
          }
        }

        // Mesh
        //
        if (n.name () == "Mesh" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Mesh_type > r (
            Mesh_traits::create (i, f, this));

          if (!this->Mesh_)
          {
            this->Mesh_.set (::std::move (r));
            continue;
          }
        }

        // IonicModels
        //
        if (n.name () == "IonicModels" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IonicModels_type > r (
            IonicModels_traits::create (i, f, this));

          if (!this->IonicModels_)
          {
            this->IonicModels_.set (::std::move (r));
            continue;
          }
        }

        // Stimuli
        //
        if (n.name () == "Stimuli" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Stimuli_type > r (
            Stimuli_traits::create (i, f, this));

          if (!this->Stimuli_)
          {
            this->Stimuli_.set (::std::move (r));
            continue;
          }
        }

        // CellHeterogeneities
        //
        if (n.name () == "CellHeterogeneities" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CellHeterogeneities_type > r (
            CellHeterogeneities_traits::create (i, f, this));

          if (!this->CellHeterogeneities_)
          {
            this->CellHeterogeneities_.set (::std::move (r));
            continue;
          }
        }

        // ConductivityHeterogeneities
        //
        if (n.name () == "ConductivityHeterogeneities" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ConductivityHeterogeneities_type > r (
            ConductivityHeterogeneities_traits::create (i, f, this));

          if (!this->ConductivityHeterogeneities_)
          {
            this->ConductivityHeterogeneities_.set (::std::move (r));
            continue;
          }
        }

        // OutputDirectory
        //
        if (n.name () == "OutputDirectory" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< OutputDirectory_type > r (
            OutputDirectory_traits::create (i, f, this));

          if (!this->OutputDirectory_)
          {
            this->OutputDirectory_.set (::std::move (r));
            continue;
          }
        }

        // OutputFilenamePrefix
        //
        if (n.name () == "OutputFilenamePrefix" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< OutputFilenamePrefix_type > r (
            OutputFilenamePrefix_traits::create (i, f, this));

          if (!this->OutputFilenamePrefix_)
          {
            this->OutputFilenamePrefix_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    simulation_type* simulation_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class simulation_type (*this, f, c);
    }

    simulation_type& simulation_type::
    operator= (const simulation_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SpaceDimension_ = x.SpaceDimension_;
        this->SimulationDuration_ = x.SimulationDuration_;
        this->Domain_ = x.Domain_;
        this->Mesh_ = x.Mesh_;
        this->IonicModels_ = x.IonicModels_;
        this->Stimuli_ = x.Stimuli_;
        this->CellHeterogeneities_ = x.CellHeterogeneities_;
        this->ConductivityHeterogeneities_ = x.ConductivityHeterogeneities_;
        this->OutputDirectory_ = x.OutputDirectory_;
        this->OutputFilenamePrefix_ = x.OutputFilenamePrefix_;
      }

      return *this;
    }

    simulation_type::
    ~simulation_type ()
    {
    }

    // physiological_type
    //

    physiological_type::
    physiological_type ()
    : ::xml_schema::type (),
      IntracellularConductivities_ (this),
      ExtracellularConductivities_ (this),
      BathConductivity_ (this),
      SurfaceAreaToVolumeRatio_ (this),
      Capacitance_ (this)
    {
    }

    physiological_type::
    physiological_type (const physiological_type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IntracellularConductivities_ (x.IntracellularConductivities_, f, this),
      ExtracellularConductivities_ (x.ExtracellularConductivities_, f, this),
      BathConductivity_ (x.BathConductivity_, f, this),
      SurfaceAreaToVolumeRatio_ (x.SurfaceAreaToVolumeRatio_, f, this),
      Capacitance_ (x.Capacitance_, f, this)
    {
    }

    physiological_type::
    physiological_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IntracellularConductivities_ (this),
      ExtracellularConductivities_ (this),
      BathConductivity_ (this),
      SurfaceAreaToVolumeRatio_ (this),
      Capacitance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void physiological_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntracellularConductivities
        //
        if (n.name () == "IntracellularConductivities" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IntracellularConductivities_type > r (
            IntracellularConductivities_traits::create (i, f, this));

          if (!this->IntracellularConductivities_)
          {
            this->IntracellularConductivities_.set (::std::move (r));
            continue;
          }
        }

        // ExtracellularConductivities
        //
        if (n.name () == "ExtracellularConductivities" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ExtracellularConductivities_type > r (
            ExtracellularConductivities_traits::create (i, f, this));

          if (!this->ExtracellularConductivities_)
          {
            this->ExtracellularConductivities_.set (::std::move (r));
            continue;
          }
        }

        // BathConductivity
        //
        if (n.name () == "BathConductivity" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< BathConductivity_type > r (
            BathConductivity_traits::create (i, f, this));

          if (!this->BathConductivity_)
          {
            this->BathConductivity_.set (::std::move (r));
            continue;
          }
        }

        // SurfaceAreaToVolumeRatio
        //
        if (n.name () == "SurfaceAreaToVolumeRatio" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SurfaceAreaToVolumeRatio_type > r (
            SurfaceAreaToVolumeRatio_traits::create (i, f, this));

          if (!this->SurfaceAreaToVolumeRatio_)
          {
            this->SurfaceAreaToVolumeRatio_.set (::std::move (r));
            continue;
          }
        }

        // Capacitance
        //
        if (n.name () == "Capacitance" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Capacitance_type > r (
            Capacitance_traits::create (i, f, this));

          if (!this->Capacitance_)
          {
            this->Capacitance_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    physiological_type* physiological_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class physiological_type (*this, f, c);
    }

    physiological_type& physiological_type::
    operator= (const physiological_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IntracellularConductivities_ = x.IntracellularConductivities_;
        this->ExtracellularConductivities_ = x.ExtracellularConductivities_;
        this->BathConductivity_ = x.BathConductivity_;
        this->SurfaceAreaToVolumeRatio_ = x.SurfaceAreaToVolumeRatio_;
        this->Capacitance_ = x.Capacitance_;
      }

      return *this;
    }

    physiological_type::
    ~physiological_type ()
    {
    }

    // numerical_type
    //

    numerical_type::
    numerical_type ()
    : ::xml_schema::type (),
      TimeSteps_ (this),
      KSPTolerances_ (this),
      KSPSolver_ (this),
      KSPPreconditioner_ (this)
    {
    }

    numerical_type::
    numerical_type (const numerical_type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TimeSteps_ (x.TimeSteps_, f, this),
      KSPTolerances_ (x.KSPTolerances_, f, this),
      KSPSolver_ (x.KSPSolver_, f, this),
      KSPPreconditioner_ (x.KSPPreconditioner_, f, this)
    {
    }

    numerical_type::
    numerical_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TimeSteps_ (this),
      KSPTolerances_ (this),
      KSPSolver_ (this),
      KSPPreconditioner_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void numerical_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TimeSteps
        //
        if (n.name () == "TimeSteps" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TimeSteps_type > r (
            TimeSteps_traits::create (i, f, this));

          if (!this->TimeSteps_)
          {
            this->TimeSteps_.set (::std::move (r));
            continue;
          }
        }

        // KSPTolerances
        //
        if (n.name () == "KSPTolerances" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< KSPTolerances_type > r (
            KSPTolerances_traits::create (i, f, this));

          if (!this->KSPTolerances_)
          {
            this->KSPTolerances_.set (::std::move (r));
            continue;
          }
        }

        // KSPSolver
        //
        if (n.name () == "KSPSolver" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< KSPSolver_type > r (
            KSPSolver_traits::create (i, f, this));

          if (!this->KSPSolver_)
          {
            this->KSPSolver_.set (::std::move (r));
            continue;
          }
        }

        // KSPPreconditioner
        //
        if (n.name () == "KSPPreconditioner" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< KSPPreconditioner_type > r (
            KSPPreconditioner_traits::create (i, f, this));

          if (!this->KSPPreconditioner_)
          {
            this->KSPPreconditioner_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    numerical_type* numerical_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class numerical_type (*this, f, c);
    }

    numerical_type& numerical_type::
    operator= (const numerical_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TimeSteps_ = x.TimeSteps_;
        this->KSPTolerances_ = x.KSPTolerances_;
        this->KSPSolver_ = x.KSPSolver_;
        this->KSPPreconditioner_ = x.KSPPreconditioner_;
      }

      return *this;
    }

    numerical_type::
    ~numerical_type ()
    {
    }

    // postprocessing_type
    //

    postprocessing_type::
    postprocessing_type ()
    : ::xml_schema::type (),
      ActionPotentialDurationMap_ (this),
      UpstrokeTimeMap_ (this),
      MaxUpstrokeVelocityMap_ (this),
      ConductionVelocityMap_ (this)
    {
    }

    postprocessing_type::
    postprocessing_type (const postprocessing_type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ActionPotentialDurationMap_ (x.ActionPotentialDurationMap_, f, this),
      UpstrokeTimeMap_ (x.UpstrokeTimeMap_, f, this),
      MaxUpstrokeVelocityMap_ (x.MaxUpstrokeVelocityMap_, f, this),
      ConductionVelocityMap_ (x.ConductionVelocityMap_, f, this)
    {
    }

    postprocessing_type::
    postprocessing_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ActionPotentialDurationMap_ (this),
      UpstrokeTimeMap_ (this),
      MaxUpstrokeVelocityMap_ (this),
      ConductionVelocityMap_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void postprocessing_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ActionPotentialDurationMap
        //
        if (n.name () == "ActionPotentialDurationMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ActionPotentialDurationMap_type > r (
            ActionPotentialDurationMap_traits::create (i, f, this));

          this->ActionPotentialDurationMap_.push_back (::std::move (r));
          continue;
        }

        // UpstrokeTimeMap
        //
        if (n.name () == "UpstrokeTimeMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< UpstrokeTimeMap_type > r (
            UpstrokeTimeMap_traits::create (i, f, this));

          this->UpstrokeTimeMap_.push_back (::std::move (r));
          continue;
        }

        // MaxUpstrokeVelocityMap
        //
        if (n.name () == "MaxUpstrokeVelocityMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< MaxUpstrokeVelocityMap_type > r (
            MaxUpstrokeVelocityMap_traits::create (i, f, this));

          if (!this->MaxUpstrokeVelocityMap_)
          {
            this->MaxUpstrokeVelocityMap_.set (::std::move (r));
            continue;
          }
        }

        // ConductionVelocityMap
        //
        if (n.name () == "ConductionVelocityMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ConductionVelocityMap_type > r (
            ConductionVelocityMap_traits::create (i, f, this));

          this->ConductionVelocityMap_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    postprocessing_type* postprocessing_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class postprocessing_type (*this, f, c);
    }

    postprocessing_type& postprocessing_type::
    operator= (const postprocessing_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ActionPotentialDurationMap_ = x.ActionPotentialDurationMap_;
        this->UpstrokeTimeMap_ = x.UpstrokeTimeMap_;
        this->MaxUpstrokeVelocityMap_ = x.MaxUpstrokeVelocityMap_;
        this->ConductionVelocityMap_ = x.ConductionVelocityMap_;
      }

      return *this;
    }

    postprocessing_type::
    ~postprocessing_type ()
    {
    }

    // chaste_parameters_type
    //

    chaste_parameters_type::
    chaste_parameters_type (const Simulation_type& Simulation,
                            const Physiological_type& Physiological,
                            const Numerical_type& Numerical)
    : ::xml_schema::type (),
      Simulation_ (Simulation, this),
      Physiological_ (Physiological, this),
      Numerical_ (Numerical, this),
      PostProcessing_ (this)
    {
    }

    chaste_parameters_type::
    chaste_parameters_type (::std::unique_ptr< Simulation_type > Simulation,
                            ::std::unique_ptr< Physiological_type > Physiological,
                            ::std::unique_ptr< Numerical_type > Numerical)
    : ::xml_schema::type (),
      Simulation_ (std::move (Simulation), this),
      Physiological_ (std::move (Physiological), this),
      Numerical_ (std::move (Numerical), this),
      PostProcessing_ (this)
    {
    }

    chaste_parameters_type::
    chaste_parameters_type (const chaste_parameters_type& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Simulation_ (x.Simulation_, f, this),
      Physiological_ (x.Physiological_, f, this),
      Numerical_ (x.Numerical_, f, this),
      PostProcessing_ (x.PostProcessing_, f, this)
    {
    }

    chaste_parameters_type::
    chaste_parameters_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Simulation_ (this),
      Physiological_ (this),
      Numerical_ (this),
      PostProcessing_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void chaste_parameters_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Simulation
        //
        if (n.name () == "Simulation" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Simulation_type > r (
            Simulation_traits::create (i, f, this));

          if (!Simulation_.present ())
          {
            this->Simulation_.set (::std::move (r));
            continue;
          }
        }

        // Physiological
        //
        if (n.name () == "Physiological" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Physiological_type > r (
            Physiological_traits::create (i, f, this));

          if (!Physiological_.present ())
          {
            this->Physiological_.set (::std::move (r));
            continue;
          }
        }

        // Numerical
        //
        if (n.name () == "Numerical" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Numerical_type > r (
            Numerical_traits::create (i, f, this));

          if (!Numerical_.present ())
          {
            this->Numerical_.set (::std::move (r));
            continue;
          }
        }

        // PostProcessing
        //
        if (n.name () == "PostProcessing" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PostProcessing_type > r (
            PostProcessing_traits::create (i, f, this));

          if (!this->PostProcessing_)
          {
            this->PostProcessing_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Simulation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Simulation",
          "");
      }

      if (!Physiological_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Physiological",
          "");
      }

      if (!Numerical_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Numerical",
          "");
      }
    }

    chaste_parameters_type* chaste_parameters_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class chaste_parameters_type (*this, f, c);
    }

    chaste_parameters_type& chaste_parameters_type::
    operator= (const chaste_parameters_type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Simulation_ = x.Simulation_;
        this->Physiological_ = x.Physiological_;
        this->Numerical_ = x.Numerical_;
        this->PostProcessing_ = x.PostProcessing_;
      }

      return *this;
    }

    chaste_parameters_type::
    ~chaste_parameters_type ()
    {
    }

    // Stimuli
    //

    Stimuli::
    Stimuli ()
    : ::xml_schema::type (),
      Stimulus_ (this)
    {
    }

    Stimuli::
    Stimuli (const Stimuli& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Stimulus_ (x.Stimulus_, f, this)
    {
    }

    Stimuli::
    Stimuli (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Stimulus_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Stimuli::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Stimulus
        //
        if (n.name () == "Stimulus" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< Stimulus_type > r (
            Stimulus_traits::create (i, f, this));

          this->Stimulus_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Stimuli* Stimuli::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Stimuli (*this, f, c);
    }

    Stimuli& Stimuli::
    operator= (const Stimuli& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Stimulus_ = x.Stimulus_;
      }

      return *this;
    }

    Stimuli::
    ~Stimuli ()
    {
    }

    // CellHeterogeneities
    //

    CellHeterogeneities::
    CellHeterogeneities ()
    : ::xml_schema::type (),
      CellHeterogeneity_ (this)
    {
    }

    CellHeterogeneities::
    CellHeterogeneities (const CellHeterogeneities& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CellHeterogeneity_ (x.CellHeterogeneity_, f, this)
    {
    }

    CellHeterogeneities::
    CellHeterogeneities (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CellHeterogeneity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CellHeterogeneities::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CellHeterogeneity
        //
        if (n.name () == "CellHeterogeneity" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CellHeterogeneity_type > r (
            CellHeterogeneity_traits::create (i, f, this));

          this->CellHeterogeneity_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    CellHeterogeneities* CellHeterogeneities::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CellHeterogeneities (*this, f, c);
    }

    CellHeterogeneities& CellHeterogeneities::
    operator= (const CellHeterogeneities& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CellHeterogeneity_ = x.CellHeterogeneity_;
      }

      return *this;
    }

    CellHeterogeneities::
    ~CellHeterogeneities ()
    {
    }

    // ConductivityHeterogeneities
    //

    ConductivityHeterogeneities::
    ConductivityHeterogeneities ()
    : ::xml_schema::type (),
      ConductivityHeterogeneity_ (this)
    {
    }

    ConductivityHeterogeneities::
    ConductivityHeterogeneities (const ConductivityHeterogeneities& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ConductivityHeterogeneity_ (x.ConductivityHeterogeneity_, f, this)
    {
    }

    ConductivityHeterogeneities::
    ConductivityHeterogeneities (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ConductivityHeterogeneity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConductivityHeterogeneities::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ConductivityHeterogeneity
        //
        if (n.name () == "ConductivityHeterogeneity" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ConductivityHeterogeneity_type > r (
            ConductivityHeterogeneity_traits::create (i, f, this));

          this->ConductivityHeterogeneity_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ConductivityHeterogeneities* ConductivityHeterogeneities::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConductivityHeterogeneities (*this, f, c);
    }

    ConductivityHeterogeneities& ConductivityHeterogeneities::
    operator= (const ConductivityHeterogeneities& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ConductivityHeterogeneity_ = x.ConductivityHeterogeneity_;
      }

      return *this;
    }

    ConductivityHeterogeneities::
    ~ConductivityHeterogeneities ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace chaste
{
  namespace parameters
  {
    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > (
        ::chaste::parameters::ChasteParameters (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > (
        ::chaste::parameters::ChasteParameters (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > (
        ::chaste::parameters::ChasteParameters (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::chaste::parameters::ChasteParameters (isrc, f, p);
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::chaste::parameters::ChasteParameters (isrc, h, f, p);
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::chaste::parameters::ChasteParameters (isrc, h, f, p);
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::chaste::parameters::ChasteParameters (isrc, f, p);
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::chaste::parameters::ChasteParameters (isrc, h, f, p);
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::chaste::parameters::ChasteParameters (isrc, h, f, p);
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > (
        ::chaste::parameters::ChasteParameters (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > (
        ::chaste::parameters::ChasteParameters (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > (
        ::chaste::parameters::ChasteParameters (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > (
          ::chaste::parameters::ChasteParameters (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ChasteParameters" &&
          n.namespace_ () == "")
      {
        ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > r (
          ::xsd::cxx::tree::traits< ::chaste::parameters::chaste_parameters_type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ChasteParameters",
        "");
    }

    ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type >
    ChasteParameters (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ChasteParameters" &&
          n.namespace_ () == "")
      {
        ::std::unique_ptr< ::chaste::parameters::chaste_parameters_type > r (
          ::xsd::cxx::tree::traits< ::chaste::parameters::chaste_parameters_type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ChasteParameters",
        "");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace chaste
{
  namespace parameters
  {
    void
    operator<< (::xercesc::DOMElement& e, const time_type& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const dimensionless_type& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const conductivity_type& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const stimulus_strength_type& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const inverse_length_type& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const capacitance_type& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const location_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Cuboid
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cuboid",
            e));

        s << i.Cuboid ();
      }

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const domain_type& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const domain_type& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const domain_type& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ionic_models_available_type& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ionic_models_available_type& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ionic_models_available_type& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ionic_model_region_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IonicModel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IonicModel",
            e));

        s << i.IonicModel ();
      }

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            e));

        s << i.Location ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ionic_models_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Default
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Default",
            e));

        s << i.Default ();
      }

      // Region
      //
      for (ionic_models_type::Region_const_iterator
           b (i.Region ().begin ()), n (i.Region ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Region",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const apd_map_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // repolarisation_percentage
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "repolarisation_percentage",
            e));

        a << ::xml_schema::as_double(i.repolarisation_percentage ());
      }

      // threshold
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "threshold",
            e));

        a << ::xml_schema::as_double(i.threshold ());
      }

      // threshold_unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "threshold_unit",
            e));

        a << i.threshold_unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const upstrokes_map_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // threshold
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "threshold",
            e));

        a << ::xml_schema::as_double(i.threshold ());
      }

      // threshold_unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "threshold_unit",
            e));

        a << i.threshold_unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const empty_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const empty_type&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const empty_type&)
    {
    }

    void
    operator<< (::xercesc::DOMElement& e, const conduction_velocity_map_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // origin_node
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "origin_node",
            e));

        a << i.origin_node ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const media_type& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const media_type& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const media_type& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const point_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // x
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "x",
            e));

        a << ::xml_schema::as_double(i.x ());
      }

      // y
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "y",
            e));

        a << ::xml_schema::as_double(i.y ());
      }

      // z
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "z",
            e));

        a << ::xml_schema::as_double(i.z ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const box_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LowerCoordinates
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LowerCoordinates",
            e));

        s << i.LowerCoordinates ();
      }

      // UpperCoordinates
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UpperCoordinates",
            e));

        s << i.UpperCoordinates ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const stimulus_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Strength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Strength",
            e));

        s << i.Strength ();
      }

      // Duration
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Duration",
            e));

        s << i.Duration ();
      }

      // Delay
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Delay",
            e));

        s << i.Delay ();
      }

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            e));

        s << i.Location ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const cell_heterogeneity_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ScaleFactorGks
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleFactorGks",
            e));

        s << i.ScaleFactorGks ();
      }

      // ScaleFactorIto
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleFactorIto",
            e));

        s << i.ScaleFactorIto ();
      }

      // ScaleFactorGkr
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleFactorGkr",
            e));

        s << i.ScaleFactorGkr ();
      }

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            e));

        s << i.Location ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const conductivity_heterogeneity_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IntracellularConductivities
      //
      if (i.IntracellularConductivities ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntracellularConductivities",
            e));

        s << *i.IntracellularConductivities ();
      }

      // ExtracellularConductivities
      //
      if (i.ExtracellularConductivities ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExtracellularConductivities",
            e));

        s << *i.ExtracellularConductivities ();
      }

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            e));

        s << i.Location ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const slab_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // x
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "x",
            e));

        a << ::xml_schema::as_double(i.x ());
      }

      // y
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "y",
            e));

        a << ::xml_schema::as_double(i.y ());
      }

      // z
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "z",
            e));

        a << ::xml_schema::as_double(i.z ());
      }

      // inter_node_space
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "inter_node_space",
            e));

        a << ::xml_schema::as_double(i.inter_node_space ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const sheet_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // x
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "x",
            e));

        a << ::xml_schema::as_double(i.x ());
      }

      // y
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "y",
            e));

        a << ::xml_schema::as_double(i.y ());
      }

      // inter_node_space
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "inter_node_space",
            e));

        a << ::xml_schema::as_double(i.inter_node_space ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const fibre_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // x
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "x",
            e));

        a << ::xml_schema::as_double(i.x ());
      }

      // inter_node_space
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "inter_node_space",
            e));

        a << ::xml_schema::as_double(i.inter_node_space ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const load_mesh_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // conductivity_media
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "conductivity_media",
            e));

        a << i.conductivity_media ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const mesh_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Slab
      //
      if (i.Slab ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Slab",
            e));

        s << *i.Slab ();
      }

      // Sheet
      //
      if (i.Sheet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sheet",
            e));

        s << *i.Sheet ();
      }

      // Fibre
      //
      if (i.Fibre ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Fibre",
            e));

        s << *i.Fibre ();
      }

      // LoadMesh
      //
      if (i.LoadMesh ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LoadMesh",
            e));

        s << *i.LoadMesh ();
      }

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const conductivities_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // longi
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "longi",
            e));

        a << ::xml_schema::as_double(i.longi ());
      }

      // trans
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "trans",
            e));

        a << ::xml_schema::as_double(i.trans ());
      }

      // normal
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "normal",
            e));

        a << ::xml_schema::as_double(i.normal ());
      }

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const time_steps_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ode
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ode",
            e));

        a << ::xml_schema::as_double(i.ode ());
      }

      // pde
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "pde",
            e));

        a << ::xml_schema::as_double(i.pde ());
      }

      // printing
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "printing",
            e));

        a << ::xml_schema::as_double(i.printing ());
      }

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ksp_use_type& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ksp_use_type& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ksp_use_type& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ksp_tolerances_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // KSPRelative
      //
      if (i.KSPRelative ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KSPRelative",
            e));

        s << ::xml_schema::as_double(*i.KSPRelative ());
      }

      // KSPAbsolute
      //
      if (i.KSPAbsolute ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KSPAbsolute",
            e));

        s << ::xml_schema::as_double(*i.KSPAbsolute ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ksp_solver_type& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ksp_solver_type& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ksp_solver_type& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ksp_preconditioner_type& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ksp_preconditioner_type& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ksp_preconditioner_type& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const simulation_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SpaceDimension
      //
      if (i.SpaceDimension ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SpaceDimension",
            e));

        s << *i.SpaceDimension ();
      }

      // SimulationDuration
      //
      if (i.SimulationDuration ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SimulationDuration",
            e));

        s << *i.SimulationDuration ();
      }

      // Domain
      //
      if (i.Domain ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Domain",
            e));

        s << *i.Domain ();
      }

      // Mesh
      //
      if (i.Mesh ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Mesh",
            e));

        s << *i.Mesh ();
      }

      // IonicModels
      //
      if (i.IonicModels ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IonicModels",
            e));

        s << *i.IonicModels ();
      }

      // Stimuli
      //
      if (i.Stimuli ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Stimuli",
            e));

        s << *i.Stimuli ();
      }

      // CellHeterogeneities
      //
      if (i.CellHeterogeneities ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CellHeterogeneities",
            e));

        s << *i.CellHeterogeneities ();
      }

      // ConductivityHeterogeneities
      //
      if (i.ConductivityHeterogeneities ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConductivityHeterogeneities",
            e));

        s << *i.ConductivityHeterogeneities ();
      }

      // OutputDirectory
      //
      if (i.OutputDirectory ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OutputDirectory",
            e));

        s << *i.OutputDirectory ();
      }

      // OutputFilenamePrefix
      //
      if (i.OutputFilenamePrefix ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OutputFilenamePrefix",
            e));

        s << *i.OutputFilenamePrefix ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const physiological_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IntracellularConductivities
      //
      if (i.IntracellularConductivities ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntracellularConductivities",
            e));

        s << *i.IntracellularConductivities ();
      }

      // ExtracellularConductivities
      //
      if (i.ExtracellularConductivities ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExtracellularConductivities",
            e));

        s << *i.ExtracellularConductivities ();
      }

      // BathConductivity
      //
      if (i.BathConductivity ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BathConductivity",
            e));

        s << *i.BathConductivity ();
      }

      // SurfaceAreaToVolumeRatio
      //
      if (i.SurfaceAreaToVolumeRatio ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceAreaToVolumeRatio",
            e));

        s << *i.SurfaceAreaToVolumeRatio ();
      }

      // Capacitance
      //
      if (i.Capacitance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Capacitance",
            e));

        s << *i.Capacitance ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const numerical_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TimeSteps
      //
      if (i.TimeSteps ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimeSteps",
            e));

        s << *i.TimeSteps ();
      }

      // KSPTolerances
      //
      if (i.KSPTolerances ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KSPTolerances",
            e));

        s << *i.KSPTolerances ();
      }

      // KSPSolver
      //
      if (i.KSPSolver ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KSPSolver",
            e));

        s << *i.KSPSolver ();
      }

      // KSPPreconditioner
      //
      if (i.KSPPreconditioner ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KSPPreconditioner",
            e));

        s << *i.KSPPreconditioner ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const postprocessing_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ActionPotentialDurationMap
      //
      for (postprocessing_type::ActionPotentialDurationMap_const_iterator
           b (i.ActionPotentialDurationMap ().begin ()), n (i.ActionPotentialDurationMap ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActionPotentialDurationMap",
            e));

        s << *b;
      }

      // UpstrokeTimeMap
      //
      for (postprocessing_type::UpstrokeTimeMap_const_iterator
           b (i.UpstrokeTimeMap ().begin ()), n (i.UpstrokeTimeMap ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UpstrokeTimeMap",
            e));

        s << *b;
      }

      // MaxUpstrokeVelocityMap
      //
      if (i.MaxUpstrokeVelocityMap ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxUpstrokeVelocityMap",
            e));

        s << *i.MaxUpstrokeVelocityMap ();
      }

      // ConductionVelocityMap
      //
      for (postprocessing_type::ConductionVelocityMap_const_iterator
           b (i.ConductionVelocityMap ().begin ()), n (i.ConductionVelocityMap ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConductionVelocityMap",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const chaste_parameters_type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Simulation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Simulation",
            e));

        s << i.Simulation ();
      }

      // Physiological
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Physiological",
            e));

        s << i.Physiological ();
      }

      // Numerical
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Numerical",
            e));

        s << i.Numerical ();
      }

      // PostProcessing
      //
      if (i.PostProcessing ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PostProcessing",
            e));

        s << *i.PostProcessing ();
      }
    }

    void
    ChasteParameters (::std::ostream& o,
                      const ::chaste::parameters::chaste_parameters_type& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::chaste::parameters::ChasteParameters (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ChasteParameters (::std::ostream& o,
                      const ::chaste::parameters::chaste_parameters_type& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::chaste::parameters::ChasteParameters (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ChasteParameters (::std::ostream& o,
                      const ::chaste::parameters::chaste_parameters_type& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::chaste::parameters::ChasteParameters (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ChasteParameters (::xercesc::XMLFormatTarget& t,
                      const ::chaste::parameters::chaste_parameters_type& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::chaste::parameters::ChasteParameters (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ChasteParameters (::xercesc::XMLFormatTarget& t,
                      const ::chaste::parameters::chaste_parameters_type& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::chaste::parameters::ChasteParameters (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ChasteParameters (::xercesc::XMLFormatTarget& t,
                      const ::chaste::parameters::chaste_parameters_type& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::chaste::parameters::ChasteParameters (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ChasteParameters (::xercesc::DOMDocument& d,
                      const ::chaste::parameters::chaste_parameters_type& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ChasteParameters" &&
          n.namespace_ () == "")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "ChasteParameters",
          "");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    ChasteParameters (const ::chaste::parameters::chaste_parameters_type& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "ChasteParameters",
          "",
          m, f));

      ::chaste::parameters::ChasteParameters (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Stimuli& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Stimulus
      //
      for (Stimuli::Stimulus_const_iterator
           b (i.Stimulus ().begin ()), n (i.Stimulus ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Stimulus",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CellHeterogeneities& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CellHeterogeneity
      //
      for (CellHeterogeneities::CellHeterogeneity_const_iterator
           b (i.CellHeterogeneity ().begin ()), n (i.CellHeterogeneity ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CellHeterogeneity",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConductivityHeterogeneities& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ConductivityHeterogeneity
      //
      for (ConductivityHeterogeneities::ConductivityHeterogeneity_const_iterator
           b (i.ConductivityHeterogeneity ().begin ()), n (i.ConductivityHeterogeneity ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConductivityHeterogeneity",
            e));

        s << *b;
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
// LCOV_EXCL_STOP
//
// End epilogue.

